<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="-l60HPLrjDNbr3Ni1wLsNkiKiCWUAmxiC_ObB8vNMF0"><meta name="msvalidate.01" content="AF3396A141E1B198CA1BE76915B3969F"><meta name="yandex-verification" content="ee8492bd2e7708db"><meta name="baidu-site-verification" content="code-OBKi1CbRLy"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"vivounicorn.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"always",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:{enable:!0,onlypost:!1,loadingImg:"./images/loading.gif",isSPA:!1,preloadRatio:3},pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="本章对于机器学习在自动驾驶及ADAS方面的一些应用和实践做了初步介绍。"><meta property="og:type" content="article"><meta property="og:title" content="机器学习与人工智能技术分享-第十三章 ADAS与自动驾驶"><meta property="og:url" content="https://vivounicorn.github.io/article/a9650e95.html"><meta property="og:site_name" content="业精于勤，荒于嬉；行成于思，毁于随。"><meta property="og:description" content="本章对于机器学习在自动驾驶及ADAS方面的一些应用和实践做了初步介绍。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli89ckr14ka1sqbuno1qbuc366i.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli60hpj1j04gi91abv186d16p59.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli66io81lrn15221ut21mmi1vf3m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6aip6u5sqm2ko03ed4nc2a.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6mfrk11vnq1q462n091jq37.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6o9q61qpfni4mfbham1bgu3k.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6pva419nv18f21jrq1tb21est4h.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6t9i11jb4j51nf71iinfms4u.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6tsav1ah0jsh18s1rvb186f5b.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli70g8p1ok11bp1bie10bjgau5o.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli8812s15301q59jnmcf1pjk65.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli89ckr14ka1sqbuno1qbuc366i.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli89qvj1or51di21oaon311f0q6v.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli8b4mn1j4bi0uq991fv318jo7c.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli8c8t9kjj1sbo1rlc1m2l1eks89.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1c46fgh5c1mfbku5no873sfrd9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1c46hoq7b1r3bfdm129uh0c1ana9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1c46j7d2f3rcotc1o151jtu1etr13.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1c990brk81ppk51c1sk3ki4cvg9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1cbejbb011k1lom1rhmeiub94m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1cbp32u28aco15aso7p1qglrdi9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1cbr4iu57354pdj1a331jnhhie9.png"><meta property="article:published_time" content="2021-09-12T10:55:44.000Z"><meta property="article:modified_time" content="2022-01-04T01:55:09.790Z"><meta property="article:author" content="张磊"><meta property="article:tag" content="机器学习"><meta property="article:tag" content="自动驾驶"><meta property="article:tag" content="ADAS"><meta property="article:tag" content="第十三章"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli89ckr14ka1sqbuno1qbuc366i.png"><link rel="canonical" href="https://vivounicorn.github.io/article/a9650e95.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>机器学习与人工智能技术分享-第十三章 ADAS与自动驾驶 | 业精于勤，荒于嬉；行成于思，毁于随。</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">业精于勤，荒于嬉；行成于思，毁于随。</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">花晨月夕</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div><img itemprop="image" src="https://vivounicorn.github.io/images/background.jpg"></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://vivounicorn.github.io/article/a9650e95.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://vivounicorn.github.io/images/wali.png"><meta itemprop="name" content="张磊"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="业精于勤，荒于嬉；行成于思，毁于随。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">机器学习与人工智能技术分享-第十三章 ADAS与自动驾驶</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-12 18:55:44" itemprop="dateCreated datePublished" datetime="2021-09-12T18:55:44+08:00">2021-09-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a> </span></span><span id="/article/a9650e95.html" class="post-meta-item leancloud_visitors" data-flag-title="机器学习与人工智能技术分享-第十三章 ADAS与自动驾驶" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/article/a9650e95.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/article/a9650e95.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>34k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>31 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli89ckr14ka1sqbuno1qbuc366i.png" width="266"> 本章对于机器学习在自动驾驶及ADAS方面的一些应用和实践做了初步介绍。 <span id="more"></span></p><h1 id="adas自动驾驶">13. ADAS&amp;自动驾驶</h1><h2 id="openpilot">13.1 Openpilot</h2><h3 id="项目简介">13.1.1 项目简介</h3><p>Comma.ai是由天才黑客George Hotz（第一个破解iPhone、PS 3的人，相关介绍：https://www.bloomberg.com/features/2015-george-hotz-self-driving-car/） 创立的专注自动驾驶的公司，目标是1000刀实现自动驾驶，但公司由于受到美国国家公路交通安全管理局的严格管制，于是“一怒之下”的把整个系统开源，取名openpilot，从功能上完全具备了目前特斯拉的autopilot具有的能力，主要表现在ACC和LKAS上。目前为止所有自动驾驶汽车都属于level 2，包括Waymo、Cruise、comma.ai、Ford、Tesla，特点是需要驾驶员坐在驾驶位且持续关注行车状态并随时接管汽车，实验室车辆在我看来也就Leve 2+，Level 3阶段，在特定路段驾驶员可以完全不用关注汽车行驶状态，目前没有厂商实现L3。openpilot目前主要能力是在6min内无需人的干预(但人需要盯着)控制本田和讴歌某几款车的加速、刹车、转向，从效果看，是我个人目前最看好的开源项目，且与我之前的构想一致：无需对汽车进行改造，无需昂贵的硬件设备，即插即用实现自动辅助驾驶。另外消费者不一定买同一品牌汽车，他们的数据也可以互相共享，从而降低自动驾驶造成的事故发生几率。</p><h3 id="基本概念">13.1.2 基本概念</h3>1、CAN CAN总线：(Controller Area Network, CAN)即控制器局域网络，是由以研发和生产汽车电子产品著称的德国BOSCH公司开发的，并最终成为国际标准（ISO 11898），是国际上应用最广泛的现场总线之一。不仅用于汽车，也广泛运用于工业，商业等领域。 在汽车领域，CAN是用于连接电子控制单元[ECU]的多主串行总线标准（通讯总线）。CAN网络需要两个或多个节点进行通信。节点的复杂性可以从简单的I / O设备到具有CAN接口和复杂软件的嵌入式计算机。节点还可以是允许标准计算机通过USB或以太网端口与CAN网络上的设备进行通信的网关。所有节点通过两线总线相互连接。电线为120Ω额定双绞线。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli60hpj1j04gi91abv186d16p59.png" width="400"></center><p>2、LIN LIN总线：(Local Interconnect Network)本地互联网，是一种低成本的串行通讯网络，用于实现汽车中的分布式电子系统控制。LIN 的目标是为现有汽车网络(例如CAN 总线)提供辅助功能，因此LIN总线是一种辅助的总线网络。在不需要CAN 总线的带宽和多功能的场合，比如智能传感器和制动装置之间的通讯使用LIN 总线可大大节省成本。 在汽车电控系统中，数据交换主要经由CAN总线完成，LIN总线是其补充与完善，不仅仅是出于成本的考量，更是（当今通讯技术发展条件下）充分保证高速数据交互效率的完美结合。 3、NEO 一个开源机器人软件开发平台,目前和 Neo 适配的智能手机只有中国厂商一加生产的一加 3 手机，只有这部手机权限足够开放，而且相机和芯片 （高通骁龙820）都符合要求，且会利用该手机的GPS。硬件成本700刀。 4、panda 通用汽车接口软件，用来控制与CAN和LIN的通信。</p><h3 id="系统架构">13.1.3 系统架构</h3><center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli66io81lrn15221ut21mmi1vf3m.png" width="500"></center><ul><li><p>汽车平台 目前只支持本田旗下几款车（且它们并没有公司间合作）： Acura ILX 2016 with AcuraWatch Plus、Honda Civic 2016 with Honda Sensing、Honda CR-V Touring 2015-2016这几款车型。通过几个接口可以扩展到其他车型，https://comma.ai/bounties.html 为鼓励计划，目前看汽车本身无需安装其他硬件设备。</p></li><li><p>硬件平台</p>1、NEO/Panda用于支持CAN/LIN通信，前者是一个机器人软件开发平台，后者是与汽车通信接口软硬件，平台开源可以方便支持OpenXC 、 Kvaser、 CANBus Triple。目前在本田上的所有通信实现只依赖2个CAN总线，1个车辆CAN、1个雷达CAN。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6aip6u5sqm2ko03ed4nc2a.png" width="200"></center><p>2、雷达 使用车载雷达即可，无需安装其他雷达</p><p>3、摄像头、GPS、智能手机 没有使用独立的摄像头和GPS模块，而是通过一部智能手机支持，目前全球能够支持的只有一加3手机，因为其权限足够开放，配备骁龙820、6GB RAM、以及光学+电子防抖，但目前看能够承担的运算不能太复杂，例如：车道检测和车辆识别的inference部分，车道线合并等。 相关视频： https://www.youtube.com/watch?v=3lIc3WnAxw8 https://www.youtube.com/watch?v=64Wvt5pYQmE&amp;feature=youtu.be https://www.youtube.com/watch?v=EQJZvVeihZk</p></li><li><p>软件平台</p><p>1、openpilot 框架比较清晰的软件架构，后面介绍</p><p>2、opendbc 依据车型订制的CAN通信消息封装接口</p><p>3、panda 与panda硬件配合的用于和汽车CAN/LIN通信的接口，关于它的详细说明：https://medium.com/<span class="citation" data-cites="comma_ai/a-panda-and-a-cabana-how-to-get-started-car-hacking-with-comma-ai-b5e46fae8646">@comma_ai/a-panda-and-a-cabana-how-to-get-started-car-hacking-with-comma-ai-b5e46fae8646</span></p></li><li><p>服务平台</p>1、仿真平台 仿真对于自动驾驶来说至关重要，openpilot目前无UI界面，通过后端跑仿真测试样例，并将结果绘图方式展示：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6mfrk11vnq1q462n091jq37.png" width="800"></center>加速仿真：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6o9q61qpfni4mfbham1bgu3k.png" width="300"></center>距离仿真：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6pva419nv18f21jrq1tb21est4h.png" width="300"></center>踏板仿真：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6t9i11jb4j51nf71iinfms4u.png" width="300"></center>加速度仿真：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli6tsav1ah0jsh18s1rvb186f5b.png" width="300"></center>2、chffr 众包的数据收集app应用，目前有 1,000,000 miles的用户上传数据，通过积分、现金鼓励的方式运营，性价比比较高，另外还有一个比较牛的东西是automatic ground truthing engine（未开源），可以自动把chffr上的数据或任意视频数据做自动gt标注。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli70g8p1ok11bp1bie10bjgau5o.png" width="400"></center><p>不过大体做法也许可以参考下面论文，基本思路还是利用语义分割做： http://www.es.ele.tue.nl/~sander/publications/icip14.pdf http://vladlen.info/papers/playing-for-data.pdf ps：常规的思路是例如https://commacoloring.herokuapp.com/ 这样的人工标注平台，不过光它产生的这些数据就值不少钱。</p></li></ul><h3 id="软件架构">13.1.4 软件架构</h3><center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli8812s15301q59jnmcf1pjk65.png" width="800"></center><p>代码层面，由c/c++和python完成。</p><h3 id="汽车基础组建">13.1.5 汽车基础组建</h3><p>1、Panda 一个独立的开源项目，与panda硬件配合，是汽车通信的硬件接口，支持手机/pc与汽车的CAN/LIN通信，整个硬件仅需要88刀。</p><p>2、Opendbc 封装标准的CAN通信消息，依据车型订制，消息结构为：</p>identifier +11-bit标准段+29-bit扩展段，整个消息长度可扩展到8 bytes。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli89ckr14ka1sqbuno1qbuc366i.png" width="500"></center>identifier 标识了如何解析消息，dbc文件是标准的CAN消息格式，例如本田思域的一段转向控制消息：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BO_ <span class="number">228</span> STEERING_CONTROL: <span class="number">5</span> ADAS</span><br><span class="line">  SG_ STEER_TORQUE : <span class="number">7</span>|<span class="number">16</span>@<span class="number">0</span>- (<span class="number">1</span>,<span class="number">0</span>) [-<span class="number">3840</span>|<span class="number">3840</span>] <span class="string">&quot;&quot;</span>  EPS</span><br><span class="line">  SG_ STEER_TORQUE_REQUEST : <span class="number">23</span>|<span class="number">1</span>@<span class="number">0</span>+ (<span class="number">1</span>,<span class="number">0</span>) [<span class="number">0</span>|<span class="number">1</span>] <span class="string">&quot;&quot;</span>  EPS</span><br><span class="line">  SG_ CHECKSUM : <span class="number">39</span>|<span class="number">4</span>@<span class="number">0</span>+ (<span class="number">1</span>,<span class="number">0</span>) [<span class="number">0</span>|<span class="number">15</span>] <span class="string">&quot;&quot;</span>  EPS</span><br><span class="line">  SG_ COUNTER : <span class="number">33</span>|<span class="number">2</span>@<span class="number">0</span>+ (<span class="number">1</span>,<span class="number">0</span>) [<span class="number">0</span>|<span class="number">3</span>] <span class="string">&quot;&quot;</span>  EPS</span><br></pre></td></tr></table></figure>第一行表示该消息是转向控制，标识符为228.后面四行为与转向相关消息。每个车型的消息结构可能都不一样，所以需要各自封装：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli89qvj1or51di21oaon311f0q6v.png" width="600"></center><p>Dbc文件抽象及其格式解析的通用代码分别在： https://github.com/commaai/openpilot/blob/v0.3.2/common/dbc.py https://github.com/commaai/openpilot/blob/v0.3.2/selfdrive/car/honda/can_parser.py</p><h3 id="公共组件">13.1.6 公共组件</h3><p>这里封装公用库函数，例如：卡尔曼滤波器、dbc文件管理、异常管理、车系管理、计算加速、参数封装、实时时间读写封装等，全为python代码。</p><h3 id="手机组件">13.1.7 手机组件</h3>智能手机是openpilot的最大硬件，所有通信、数据收集、计算、展现都是通过手机作为载体。整个openpilot采用cap’n proto做消息序列化封装，使用ZMQ做消息通信，很高效，整体架构提前做了ROS 2.0想做的事。 can’n proto(https://capnproto.org/)的效率更加适用于这种嵌入式场景：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli8b4mn1j4bi0uq991fv318jo7c.png" width="200"></center><p>ZMQ（ZeroMQ，http://zeromq.org/）是跨平台、高效的分布式消息队列，同样很适用于嵌入式场景。</p><ul><li><p>cereal 封装所有用于手机端日志记录的消息接口，由两部分组成： log.capnp，封装了手机日志记录相关接口； car.capnp，车相关抽象层，核心是CarStateCarControl接口，如果想新加一种车，需要实现这个。</p></li><li><p>phonelibs 封装手机相关库，纯基于c的，有些库只有so。</p></li></ul><h3 id="自动驾驶组件">13.1.8 自动驾驶组件</h3>自适应巡航使用传统方法，这里不讲，主要讲车道辅助驾驶部分，整体结构如下：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1bli8c8t9kjj1sbo1rlc1m2l1eks89.png" width="800"></center><ul><li><p>感知 在openpilot中感知主要是车道检测和传感器数据处理，前者使用的是一个深度神经网路，但网络结构没有开源，API开源，所以允许你定义模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ModelData &#123;</span><br><span class="line">  frameId @<span class="number">0</span> :UInt32;</span><br><span class="line">  path @<span class="number">1</span> :路径数据;</span><br><span class="line">  leftLane @<span class="number">2</span> :左行车道;</span><br><span class="line">  rightLane @<span class="number">3</span> :右行车道;</span><br><span class="line">  lead @<span class="number">4</span> :前方引领车辆;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p></p></li><li><p>定位 未看到实现</p></li><li><p>预测 在openpilot中预测主要是路径预测，先预测前方某个长度路径是直的还是弯的，然后将这些局部路径合成一个长路径。</p></li><li><p>决策 依据当前车道信息、前车距离信息、自动驾驶时长信息做控制命令生成。</p></li><li><p>路径规划 一个独立进程，并没有做什么规划动作，主要是根据预测阶段产生的路径及决策信息决定后续路径。</p></li><li><p>控制 依据前面的信息产生后续动作并通过CAN/LIN接口执行消息发送以控制汽车姿态。 代码中：</p></li></ul><p>○ 底层支持层</p><p>Assets用于UI字体支持； Common为封装的公共组件函数； Logcatd为独立进程，做Android日志管理，基于zmq和cap’nproto做消息通信； Proclogd为独立进程，做进程日志管理，基于zmq和cap’nproto做消息通信.</p><p>○ 对外交互层</p><p>Boardd为独立进程，用于车、机USB消息交换； Sensord为GPS/IMU接口代码，但未开源； Visiond为车道检测算法，前面有讲；</p><p>○ 行为执行层</p><p>Loggerd用于记录车辆行驶过程中的数据，用于后续模型训练； Car为封装的汽车抽象层前面有介绍； Controls为控制单元，是这一层的核心，包括了自适应巡航、距离控制、路径规划等； Radar为交互接口。</p><p>○ 前端表现层</p><p>UI用于绘制前端显示的行车线、车辆检测框、校准线等； Debug用于调试； Test/plant为相对简单的仿真后台。</p><h3 id="总结">13.1.9 总结</h3><p>总的来说，自动驾驶最终解决方案一定不是不计成本的硬件投入，而是基于普通摄像头和车载雷达的低成本高性能解决方案。 所以我认为自动驾驶的技术核心是：</p><p>1、工程架构能力：如何满足可扩展性、高性能等要求；</p><p>2、核心模块的算法能力：主要是基于深度学习，需要tradeoff性能与效果，在嵌入式环境哪怕1ms都需要争取；</p><p>3、数据能力：两方面，收集数据的能力和数据标注的能力；</p><p>4、仿真能力：决定模型效果迭代能走多快。</p><p>目前开源软件能让我们达到Level 2，但要实现更高级别必须解决上面4个问题。</p><p>百度的apollo工程架构上设计比较合理，各子系统松耦合，但是目前整个项目是个空壳子，没有相关算法支撑，仿真系统也很粗糙，另外需要车载电脑等硬件支持，在通信性能方面我也有疑虑。 Openpilot在工程架构上比较合理，在资源消耗上比较小，硬件需求不强，我认为思路是未来的发展方向之一，缺点是没有大公司支持，属于个人英雄主义，且很多东西未开源。</p><p>整体来说开源自动驾驶技术方面大家都不完善，而自动驾驶的场景很重要，只研究技术是不够的，在我看来未来围绕着它有三大角色：</p><p>1、平台</p><p>2、主机厂</p><p>3、运营商</p><p>虽然趋势是合作共赢，但未来大家在这方面人才上的竞争会愈发激烈。</p><h2 id="基于视觉的车道检测">13.2 基于视觉的车道检测</h2><h3 id="传统车道检测方法">13.2.1 传统车道检测方法</h3><p>车道检测(LD)是ADAS/自动驾驶领域中的一个基本问题，可以基于激光雷达、视觉或者多传感器融合去做。但总的来说车道检测是个比较难的问题，原因在于：车道线和道路的多样化，例如：高速路、城乡结合部、土路、不同地区、不同国家对车道线的标准不同等；道路干扰因素较多，比如：树荫、遮挡、强光反射等；恶劣的视觉环境，比如：雨、雪、雾天气等。 其中，基于视觉的方法分为传统方法和深度学习方法。 传统方法一般需要做以下工作：</p><ul><li>图像预处理 图像去噪；删除图像中不相关部分，如车辆、行人、障碍物；对图像中过暗或过亮部分做归一化修正；去除图像中阴影（如：树荫）；根据摄像头位置提取图像ROI；图像边缘检测；腐蚀膨胀等。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1c46fgh5c1mfbku5no873sfrd9.png" width="400"></center></li><li>特征提取 通过人工方法直接在原图或通过原图生成的鸟瞰图提取亮度峰值、HOG、道路纹理、道路分割、车道曲率等特征。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1c46hoq7b1r3bfdm129uh0c1ana9.png" width="400"></center></li><li>模型拟合 模型需要做先验假设，可以采用参数学习（典型的像直线、曲线）、半参数学习、非参学习，然后采用合适的损失函数（如Square Loss）做优化求解。典型的传统算法如Hough变换，其本质是对图像进行坐标变换，让变换结果易于检测和识别；当车道线不清晰或存在其他干扰的情况下，传统方法会利用类似Gabor滤波做消失点预测（Vanishing Point：三维空间中的两条平行线在二维空间中的交叉点，简单说就是两个车道线的交点位置），然后利用消失点做车道线预测。也可以用卡尔曼滤波利用前几帧预测下一帧车道线位置。总的来说传统方法的天花板比较明显。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1c46j7d2f3rcotc1o151jtu1etr13.png" width="500"></center></li><li><p>上下文信息集成 利用前几帧的信息提高下一帧的预测准确度以及复用前几帧的特征减少计算量。</p></li><li><p>图像后处理 对车道线之类的做其他处理使其能在真实世界中表示出来。</p></li></ul><h3 id="深度学习套路">13.2.2 深度学习套路</h3><p>基本上，深度学习的方法出来后大家套路日趋一致：</p><p>1、人工或半人工标注数据集（理论上越多样化、越多越好），改进对小物体的标注</p><p>2、数据预处理，例如做IPM；</p><p>3、选择一个基础网络做自动特征提取；</p><p>4、构建一个多任务网络分别做：BBox Regression、Classification、Object Mask、VP Prediction等；</p><p>5、使用现有数据集做模型Transfer Learning（fine tune）；</p><p>6、使用FCN、FPN、Quantization之类的方法改进网络效果或做加速，裁剪模型降低模型大小；</p><p>7、使用scale权衡速度与精度；</p><p>8、使用类似RNN或LSTM融合上下文信息。</p><p>不管哪种方法，对于硬件和工程的要求越来越高，因为你要保证inference的时间是实时的。当硬件条件不佳时（车联网领域用的较多的MTK8665芯片，采用ARM架构、MALI GPU）就得在工程上做很多优化的事情，例如图片的预处理、矩阵乘法之类的需要在ARM架构下利用寄存器做优化。如果你很有钱，用高端的Nvidia芯片，那这方面麻烦会小些，但你的产品性价比可能下降。</p><h3 id="vanishing-point-guided-network">13.2.3 Vanishing Point Guided Network</h3><p>这是去年10月份提出的一个基于深度学习的方法，应该是目前为止实测效果最好的之一，亮点有：多种气候环境下的标注数据集；一个带VP预测的多任务网络。</p><ul><li><p>数据集</p><p>车道线数据相比其他检测、分类数据最大的不同是标注数据比较窄（车道线）且不容易标注类似的Bounding Box，而且这种标注会有以下问题：</p><p>1)、特征提取阶段由于convolution和pooling操作会导致信息损失甚至消失；</p><p>2)、由于一般网络输入会有resize操作，所以车道线的标注信息有可能因为图片太小而看不到。</p>所以为了解决以上问题，对车道线标注采用grid-level网格级标注，示例如下：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1c990brk81ppk51c1sk3ki4cvg9.png" width="500"></center><p>如果网格中的任意一个像素位于某类车道线的标注线内，则整个网格都会被标记为该类。假设网络输入为640×480，输出为80×60，缩放系数为1/8，所以启发式的可以将网格大小设置为8×8(不一定非得这么设置)。 除车道线外，还需要标注VP（消失点），当然VP的标注是纯人工标注，为道路所有车道线在远端的交叉点。注意，不管道路是直的还是弯的都会有VP。</p></li><li><p>整体网络结构</p>整个网络是一个multi-task网络，可完成对车道线、路上交通标志、以及消失点的检测和识别，共享特征提取部分，有4个分支网络：预测VP的网络（VPP）、多分类网络（Multi-label）、bbox回归网络（Grid Box）、目标检测网络（Object Mask），结构描述如下：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1cbejbb011k1lom1rhmeiub94m.png" width="800"></center><p>需要注意，bbox回归对有固定形状的物体可以做一个box来框柱物体，但对车道线没法用一个box框定，所以文中做了一个车道线检测回归的创新：对网格里的像素，回归到与其最近的网格单元（网格粒度的regression），这样对普通物体、道路上的交通标志、车道线在检测回归上得到框架上的统一。在后处理阶段，普通物体分类只需要使用多分类网络的结果，道路上的交通标志、车道线结合bbox回归和多分类网络的结果就可知道。 整个网络的损失函数描述如下： <span class="math display">\[Loss=w_1L_{reg}+w_2L_{om}+w_3L_{ml}+w_4L_{vp}\]</span> 其中<span class="math inline">\(L_{reg}\)</span>是一个<em>grid regression L1</em>损失，<span class="math inline">\(L_{om}、L_{ml}、L_{vp}\)</span>是交叉熵损失。</p></li><li><p>消失点预测</p><p>消失点（Vanishing Point）在复杂环境下对车道线的检测等应用有较好的辅助作用，它其实是提供了相对全局的地理信息，举个例子：当行驶在没有车道线的乡间小路上，根据VP的位置可以做车道线绘制；下雨天，根据消失点可以做车道线预测。 在确定VPP损失函数上，文章做了几种尝试：</p><ul><li>使用回归损失函数：由于和其他任务的损失函数在尺度上不一致，所以很难去平衡整体函数损失；</li><li>使用二分类交叉熵损失函数：交叉熵本质上衡量的是实际数据的概率分布与我们假设模型的概率分布是否一致，交叉熵损失可以平衡不同任务的梯度传播（思考一个问题：平常我们经常会出于对数值平滑、控制值域范围、概率的乘法转加法等目的对数值做log运算，那么从熵的角度如何考虑这个变换的意义？）。最简单处理VP的方式是，用一个圈把VP圈出来，然后对所有像素做二分类：处于圈内还是圈外，由于天然的样本不平衡，圈外的样本远多于圈内，所以模型的稳定性和收敛性都比较差，比如所有像素倾向于全部分配到圈外。</li><li>使用多分类交叉熵：交叉熵的好处同上，我认为文章<strong>最大的亮点</strong>在于提出用象限去识别VP，即：以VP为中心，把图片划分为四个象限，反过来，四个象限的交叉点即为VP；VPP这个模型的通道有5个：默认通道（代表不是VP），象限1、象限2、象限3、象限4；每个像素都会出现在这5个通道中的1个，对于VP中的任何一个像素会被分配到某个象限通道且不会出现在默认通道中，当VP信息较弱时，所有像素趋向于被分配到默认通道，此时默认通道的平均置信度会比较高。<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1cbp32u28aco15aso7p1qglrdi9.png" width="600"></center>上图展示了两种不同方式的区别，通过这5个通道的值，可以生成VP的位置（四个象限的交汇点），计算方法如下： <span class="math display">\[P_{avg}=\frac{1-(\sum p_0(x,y))/(m×n)}{4}\]</span> <span class="math display">\[loc_{vp}=argmin_{x,y}\sum_{n=1}^4|p_{avg}-p_n(x,y)|^2\]</span> 其中<span class="math inline">\(p_{avg}\)</span>是图片中存在VP的概率，<span class="math inline">\(p_n(x,y)\)</span>是<span class="math inline">\((x,y)\)</span>在第<span class="math inline">\(n_{th}\)</span>个通道的置信度，<span class="math inline">\(m×n\)</span>是置信区域的大小，<span class="math inline">\(loc_{vp}\)</span>是VP的位置。</li></ul><p><strong>观察任务特点</strong>：VPP任务的和车道线检测任务有潜在相关性（车道线在远处的交汇点即为VP），所以如果两个任务同时进行会互相影响，因此，训练过程需要分为两个阶段：</p><ul><li><p>第一阶段仅训练VPP网络：除了VPP外，其他网络的学习率设置为0，虽然如此，可以观察到VPP训练结束后，其他网络的损失函数值会下降20%左右，因为大家共用同一套特征提取网络，也侧面印证了前面说的VPP和其他任务的先验相关性。</p></li><li><p>第二阶段所有网络同时训练：通过<span class="math inline">\(w_1\)</span>~<span class="math inline">\(w_4\)</span>控制不同损失的权重，权重初始值为1，当初始损失函数值出现后，这些权重值会被设置为这些损失函数值的倒数，在训练的任何阶段，如果发现损失函数值之间的尺度差异过大，则利用上面方法调整；网络不断学习，直到其在验证集上的精度收敛。</p></li></ul></li><li><p>图像后处理</p><ul><li><p>车道线：首先，在多分类网络的车道线通道抽样局部最优值，这些值对应的点是潜在的车道线分割点；其次，通过逆透视变换（IPM）生成鸟瞰图，并把上述点映射到鸟瞰图；再次，应用基于密度的聚类算法（如：DBSCAN）对上述点做聚类，注：这里有个技巧，根据纵坐标对像素点做概率降序排列，然后做分桶操作，通过这个方法降低聚类时间复杂度；最后，利用上述方法生成VP。</p></li><li><p>路面交通标志：首先，从多分类网络输出中对每个类以高置信度从网格回归任务中提取网格单元格；然后，我们选择每个网格的角点并将它们与附近的网格单元迭代合并；如果没有更多的相邻网格单元属于同一类，则合并终止。某些道路标记（如人行横道或安全区域）很难通过单个框定义，因此会通过网格采样进行定位。</p></li></ul></li><li>代码示例 由于三星没有公开数据集，所以只能用<a target="_blank" rel="noopener" href="http://www.mohamedaly.info/datasets/caltech-lanes">Caltech Lanes Dataset</a>数据集做测试。<ul><li><p>生成训练数据和测试数据标注（根据原始的点标注生成网格级标注），需要安装MATLAB，代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">close all; clc;</span><br><span class="line">category = <span class="string">&#x27;cordova1&#x27;</span>;</span><br><span class="line">addpath(genpath(<span class="string">&#x27;./caltech-lane-detection/matlab&#x27;</span>))</span><br><span class="line">path = <span class="string">&#x27;./&#x27;</span>;</span><br><span class="line">file =  sprintf(<span class="string">&#x27;/%s/labels.ccvl&#x27;</span>, category);</span><br><span class="line">gLabelData = ccvLabel(<span class="string">&#x27;read&#x27;</span>, [path file]);</span><br><span class="line">h = <span class="number">0.02</span>;</span><br><span class="line">height = <span class="number">480</span>;</span><br><span class="line">width = <span class="number">640</span>;</span><br><span class="line">gg = <span class="number">8</span>;</span><br><span class="line">grid_x = <span class="number">1</span>:gg:<span class="number">481</span>;</span><br><span class="line">grid_y = <span class="number">1</span>:gg:<span class="number">641</span>;</span><br><span class="line">thickness = <span class="number">2</span>;</span><br><span class="line">fileID = fopen(sprintf(<span class="string">&#x27;./%s.txt&#x27;</span>, category),<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">numFrames = <span class="built_in">size</span>(gLabelData.frames,<span class="number">2</span>);</span><br><span class="line">gLabelSubtypes = &#123;<span class="string">&#x27;bw&#x27;</span>, <span class="string">&#x27;sw&#x27;</span>, <span class="string">&#x27;dy&#x27;</span>, <span class="string">&#x27;by&#x27;</span>, <span class="string">&#x27;sy&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:numFrames</span><br><span class="line">    <span class="built_in">disp</span>(sprintf(<span class="string">&#x27;frame: %03d&#x27;</span>,<span class="built_in">i</span>))</span><br><span class="line">    numLanes = <span class="built_in">size</span>(gLabelData.frames(<span class="built_in">i</span>).labels, <span class="number">2</span>);</span><br><span class="line">    segs = [];</span><br><span class="line">    splines = &#123;numLanes&#125;;</span><br><span class="line">    sptypes = &#123;numLanes&#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:numLanes</span><br><span class="line">    splines&#123;<span class="built_in">j</span>&#125; = ccvEvalBezSpline(gLabelData.frames(<span class="built_in">i</span>).labels(<span class="built_in">j</span>).points, h);     <span class="comment">% convert 4 point to spline</span></span><br><span class="line">    sptypes&#123;<span class="built_in">j</span>&#125; = gLabelData.frames(<span class="built_in">i</span>).labels(<span class="built_in">j</span>).subtype;</span><br><span class="line">    splines_x1 = splines&#123;<span class="built_in">j</span>&#125;;</span><br><span class="line">    splines_x2 = splines&#123;<span class="built_in">j</span>&#125;;</span><br><span class="line">    splines_x1(:,<span class="number">1</span>) = splines_x1(:,<span class="number">1</span>) - thickness;</span><br><span class="line">    splines_x2(:,<span class="number">1</span>) = splines_x2(:,<span class="number">1</span>) + thickness;</span><br><span class="line">    splines&#123;<span class="built_in">j</span>&#125; = [splines&#123;<span class="built_in">j</span>&#125;; splines_x1; splines_x2];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">size</span>(splines&#123;<span class="built_in">j</span>&#125;,<span class="number">1</span>)    <span class="comment">% make spline points into bounding box</span></span><br><span class="line">        grid_pos_x = <span class="built_in">floor</span>((splines&#123;<span class="built_in">j</span>&#125;(k,<span class="number">1</span>)<span class="number">-1</span>)/gg);</span><br><span class="line">        grid_pos_y = <span class="built_in">floor</span>((splines&#123;<span class="built_in">j</span>&#125;(k,<span class="number">2</span>)<span class="number">-1</span>)/gg);</span><br><span class="line">        xmin = grid_pos_x * gg + <span class="number">1</span>;</span><br><span class="line">        xmax = grid_pos_x * gg + gg;</span><br><span class="line">        ymin = grid_pos_y * gg + <span class="number">1</span>;</span><br><span class="line">        ymax = grid_pos_y * gg + gg;</span><br><span class="line">        grid_width = xmax - xmin;</span><br><span class="line">        grid_height = ymax - ymin;</span><br><span class="line">        inst_id = <span class="built_in">j</span>;</span><br><span class="line">        lane_id = <span class="built_in">find</span>(<span class="built_in">ismember</span>(gLabelSubtypes, sptypes&#123;<span class="built_in">j</span>&#125;));</span><br><span class="line">        segs = [segs; xmin, ymin, xmax, ymax, inst_id, lane_id];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    segs = unique(segs, <span class="string">&#x27;rows&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">numLaneSegs = <span class="built_in">size</span>(segs, <span class="number">1</span>) - numLanes;</span><br><span class="line">fprintf(fileID,<span class="string">&#x27;/%s/f%05d.png  %d&#x27;</span>,category, <span class="built_in">i</span><span class="number">-1</span>, <span class="built_in">size</span>(segs,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(segs,<span class="number">1</span>)</span><br><span class="line">    xmin = segs(<span class="built_in">j</span>,<span class="number">1</span>);</span><br><span class="line">    ymin = segs(<span class="built_in">j</span>,<span class="number">2</span>);</span><br><span class="line">    xmax = segs(<span class="built_in">j</span>,<span class="number">3</span>);</span><br><span class="line">    ymax = segs(<span class="built_in">j</span>,<span class="number">4</span>);</span><br><span class="line">    inst_id = segs(<span class="built_in">j</span>,<span class="number">5</span>);</span><br><span class="line">    lane_id = segs(<span class="built_in">j</span>,<span class="number">6</span>);</span><br><span class="line">    fprintf(fileID, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    fprintf( fileID, <span class="string">&#x27; %d&#x27;</span>, xmin );</span><br><span class="line">    fprintf( fileID, <span class="string">&#x27; %d&#x27;</span>, ymin );</span><br><span class="line">    fprintf( fileID, <span class="string">&#x27; %d&#x27;</span>, xmax );</span><br><span class="line">    fprintf( fileID, <span class="string">&#x27; %d&#x27;</span>, ymax );</span><br><span class="line">    fprintf( fileID, <span class="string">&#x27; %d&#x27;</span>, lane_id ); <span class="comment">% depth data -&gt; lane_id</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fprintf(fileID,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(<span class="string">&#x27;all&#x27;</span>);</span><br></pre></td></tr></table></figure><p></p></li><li>生成lmdb格式的训练和测试数据，代码：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Declare <span class="variable">$PATH_TO_DATASET_DIR</span> and <span class="variable">$PATH_TO_DATASET_LIST</span></span></span><br><span class="line">PATH_TO_DATASET_DIR=/data1/workspace/liyiran/VPGNet/caltech-lanes-dataset</span><br><span class="line">PATH_TO_DATASET_LIST=/data1/workspace/liyiran/VPGNet/caltech-lanes-dataset/dataset/all.txt</span><br><span class="line"></span><br><span class="line">../../build/tools/convert_driving_data $PATH_TO_DATASET_DIR $PATH_TO_DATASET_LIST LMDB_train</span><br><span class="line">../../build/tools/compute_driving_mean LMDB_train ./driving_mean_train.binaryproto lmdb</span><br><span class="line"></span><br><span class="line">PATH_TO_DATASET_LIST=/data1/workspace/liyiran/VPGNet/caltech-lanes-dataset/dataset/test.txt</span><br><span class="line">../../build/tools/convert_driving_data $PATH_TO_DATASET_DIR $PATH_TO_DATASET_LIST LMDB_test</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>训练模型:</p><ul><li>solver.prototxt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">net: &quot;./train_val.prototxt&quot;</span><br><span class="line"></span><br><span class="line">test_iter: 20</span><br><span class="line">test_interval: 100</span><br><span class="line">test_compute_loss: true</span><br><span class="line"></span><br><span class="line">base_lr: 0.005</span><br><span class="line">lr_policy: &quot;step&quot;</span><br><span class="line">gamma: 0.1</span><br><span class="line">stepsize: 100000</span><br><span class="line">display: 10</span><br><span class="line">max_iter: 100000</span><br><span class="line">momentum: 0.9</span><br><span class="line">weight_decay: 0.0005</span><br><span class="line">snapshot: 2500</span><br><span class="line">snapshot_prefix: &quot;./snapshots/split&quot;</span><br><span class="line">solver_mode: GPU</span><br></pre></td></tr></table></figure></li><li>train.sh<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../build/tools/caffe train --solver=./solver.prototxt -weights ./snapshots/split_iter_100000.caffemodel -gpu all &gt;&gt; ./output/output.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li><li>pre-trained model，大概446M，传不上去，有需要单找我吧。</li></ul></li><li>后处理及模型inference<ul><li>caffe_inference.cpp，inference的c++版本，需要安装配置好caffe：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;caffe/caffe.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> caffe;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INPUT_SIDE 640;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_INPUT_SIDE 480;</span></span><br><span class="line">std::string caffe_root = <span class="string">&quot;/data1/workspace/liyiran/VPGNet/caffe/models/vpgnet-novp/inference/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dump caffe feature map</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaffeDump</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CaffeDump</span>(<span class="keyword">const</span> std::string&amp; net_file, <span class="keyword">const</span> std::string&amp; weight_file, <span class="keyword">const</span> <span class="keyword">int</span> GPUID);</span><br><span class="line">	~<span class="built_in">CaffeDump</span>();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">caffe_forward</span><span class="params">(cv::Mat, <span class="keyword">const</span> std::string&amp; , <span class="keyword">int</span>, <span class="keyword">const</span> std::string&amp;, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preprocess</span><span class="params">(<span class="keyword">const</span> cv::Mat cv_image)</span></span>;</span><br><span class="line">	<span class="function">cv::Mat <span class="title">image_translation</span><span class="params">(cv::Mat &amp; srcImage, <span class="keyword">int</span> x0ffset, <span class="keyword">int</span> y0ffset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_ptr&lt;Net&lt;<span class="keyword">float</span>&gt; &gt; net_;</span><br><span class="line">	<span class="keyword">int</span> num_channels_;</span><br><span class="line">	<span class="keyword">float</span> threshold_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CaffeDump::<span class="built_in">CaffeDump</span>(<span class="keyword">const</span> std::string&amp; net_file, <span class="keyword">const</span> std::string&amp; weights_file, <span class="keyword">const</span> <span class="keyword">int</span> GPUID)</span><br><span class="line">&#123;</span><br><span class="line">	Caffe::<span class="built_in">SetDevice</span>(GPUID);</span><br><span class="line">	Caffe::<span class="built_in">set_mode</span>(Caffe::GPU);</span><br><span class="line"></span><br><span class="line">	net_.<span class="built_in">reset</span>(<span class="keyword">new</span> Net&lt;<span class="keyword">float</span>&gt;(net_file, caffe::TEST));</span><br><span class="line">	net_-&gt;<span class="built_in">CopyTrainedLayersFrom</span>(weights_file);</span><br><span class="line"></span><br><span class="line">	Blob&lt;<span class="keyword">float</span>&gt;* input_layer = net_-&gt;<span class="built_in">input_blobs</span>()[<span class="number">0</span>];</span><br><span class="line">	num_channels_ = input_layer-&gt;<span class="built_in">channels</span>();</span><br><span class="line">	<span class="built_in">CHECK_EQ</span>(num_channels_, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;Input layer should have 3 channels.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CaffeDump::~<span class="built_in">CaffeDump</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CaffeDump::caffe_forward</span><span class="params">(cv::Mat cv_image, <span class="keyword">const</span> std::string&amp; layer_name, <span class="keyword">int</span> channel, <span class="keyword">const</span> std::string&amp; filepath, <span class="keyword">int</span> factor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cv_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Can not reach the image&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">preprocess</span>(cv_image);</span><br><span class="line"></span><br><span class="line">	net_-&gt;<span class="built_in">ForwardFrom</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	shared_ptr&lt;caffe::Blob&lt;<span class="keyword">float</span>&gt;&gt; layerData =net_-&gt;<span class="built_in">blob_by_name</span>(layer_name);</span><br><span class="line">	<span class="keyword">int</span> batch_size = layerData-&gt;<span class="built_in">num</span>();</span><br><span class="line">	<span class="keyword">int</span> dim_features = layerData-&gt;<span class="built_in">count</span>() / batch_size;</span><br><span class="line">	<span class="keyword">int</span> channels = layerData-&gt;<span class="built_in">channels</span>();</span><br><span class="line">	<span class="keyword">int</span> height = layerData-&gt;<span class="built_in">height</span>();</span><br><span class="line">	<span class="keyword">int</span> width = layerData-&gt;<span class="built_in">width</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;batch size:&quot;</span> &lt;&lt; batch_size &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;dimension:&quot;</span> &lt;&lt; dim_features &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;channels:&quot;</span> &lt;&lt; channels &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;height:&quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;width:&quot;</span> &lt;&lt; width &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;channels*height*width:&quot;</span> &lt;&lt; channels*height*width &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CHECK_LT</span>(channel, channels) &lt;&lt; <span class="string">&quot;Input channel number should small than channels.&quot;</span>;</span><br><span class="line">	<span class="keyword">float</span>* feature_blob_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; batch_size; ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		feature_blob_data = layerData-&gt;<span class="built_in">mutable_cpu_data</span>() +</span><br><span class="line">			layerData-&gt;<span class="built_in">offset</span>(n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> *arr = (<span class="built_in"><span class="keyword">float</span></span>(*))<span class="built_in">malloc</span>(height*width*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">		<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; dim_features; ++d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (idx &lt; height*width)&#123;</span><br><span class="line">				arr[idx] = feature_blob_data[idx+channel*height*width];</span><br><span class="line">				idx++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> len = height*width;</span><br><span class="line">		<span class="keyword">float</span> min_val = *std::<span class="built_in">min_element</span> (arr,arr+len);</span><br><span class="line">		<span class="keyword">float</span> max_val = *std::<span class="built_in">max_element</span>(arr,arr+len);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;size of feature:&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot;,max &quot;</span></span><br><span class="line">			&lt;&lt; *std::<span class="built_in">max_element</span>(arr,arr+len) &lt;&lt; <span class="string">&quot;,min &quot;</span> &lt;&lt;*std::<span class="built_in">min_element</span> (arr,arr+len)&lt;&lt;std::endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			arr[i] = <span class="number">255</span>*(arr[i]-min_val)/(max_val-min_val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">const</span> cv::Mat <span class="title">img</span><span class="params">(cv::Size(width, height), CV_32FC1, arr)</span></span>;</span><br><span class="line"></span><br><span class="line">		cv::<span class="built_in">imwrite</span>(filepath+<span class="string">&quot;.jpg&quot;</span>, img);</span><br><span class="line">		<span class="function"><span class="keyword">const</span> cv::Mat <span class="title">scale_img</span><span class="params">(cv::Size(width*factor, height*factor), CV_32FC1, arr)</span></span>;</span><br><span class="line">		cv::<span class="built_in">imwrite</span>(filepath+<span class="string">&quot;_&quot;</span>+std::<span class="built_in">to_string</span>(factor)+<span class="string">&quot;x.jpg&quot;</span>, scale_img);</span><br><span class="line"></span><br><span class="line">		cv::Mat srcImage=cv::<span class="built_in">imread</span>(filepath+<span class="string">&quot;_&quot;</span>+std::<span class="built_in">to_string</span>(factor)+<span class="string">&quot;x.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> x0ffset = <span class="number">-180</span>;</span><br><span class="line">		<span class="keyword">int</span> y0ffset = <span class="number">-180</span>;</span><br><span class="line">		<span class="comment">//图像左平移不改变大小</span></span><br><span class="line">		cv::Mat resultImage1 = <span class="built_in">image_translation</span>(srcImage, x0ffset, y0ffset);</span><br><span class="line">		cv::<span class="built_in">imwrite</span>(filepath+<span class="string">&quot;_&quot;</span>+std::<span class="built_in">to_string</span>(factor)+<span class="string">&quot;x-off.jpg&quot;</span>, resultImage1);</span><br><span class="line">		std::cout &lt;&lt; (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;  <span class="comment">// for (int n = 0; n &lt; batch_size; ++n)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">CaffeDump::image_translation</span><span class="params">(cv::Mat &amp; srcImage, <span class="keyword">int</span> x0ffset, <span class="keyword">int</span> y0ffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nRows = srcImage.rows;</span><br><span class="line">	<span class="keyword">int</span> nCols = srcImage.cols;</span><br><span class="line">	<span class="function">cv::Mat <span class="title">resultImage</span><span class="params">(srcImage.size(), srcImage.type())</span></span>;</span><br><span class="line">	<span class="comment">//int nRows = srcImage.rows + abs(y0ffset);</span></span><br><span class="line">	<span class="comment">//int nCols = srcImage.cols + abs(x0ffset);</span></span><br><span class="line">	<span class="comment">//cv::Mat resultImage(nRows, nCols, srcImage.type());</span></span><br><span class="line">	<span class="comment">//遍历图像</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nRows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nCols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//映射变换</span></span><br><span class="line">			<span class="keyword">int</span> x = j - x0ffset;</span><br><span class="line">			<span class="keyword">int</span> y = i - y0ffset;</span><br><span class="line">			<span class="comment">//边界判断</span></span><br><span class="line">			<span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; nCols &amp;&amp; y &lt; nRows)</span><br><span class="line">			&#123;</span><br><span class="line">				resultImage.at&lt;cv::Vec3b&gt;(i, j) = srcImage.ptr&lt;cv::Vec3b&gt;(y)[x];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CaffeDump::preprocess</span><span class="params">(<span class="keyword">const</span> cv::Mat cv_image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">cv::Mat <span class="title">cv_new</span><span class="params">(cv_image.rows, cv_image.cols, CV_32FC3, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">	<span class="keyword">int</span> height = cv_image.rows;</span><br><span class="line">	<span class="keyword">int</span> width = cv_image.cols;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Mean normalization (in this case it may not be the average of the training) */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; height; ++h) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; width; ++w) &#123;</span><br><span class="line">			cv_new.at&lt;cv::Vec3f&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">0</span>] = <span class="built_in"><span class="keyword">float</span></span>(cv_image.at&lt;cv::Vec3b&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">0</span>]);<span class="comment">// - float(102.9801);</span></span><br><span class="line">			cv_new.at&lt;cv::Vec3f&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">1</span>] = <span class="built_in"><span class="keyword">float</span></span>(cv_image.at&lt;cv::Vec3b&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">1</span>]);<span class="comment">// - float(115.9465);</span></span><br><span class="line">			cv_new.at&lt;cv::Vec3f&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">2</span>] = <span class="built_in"><span class="keyword">float</span></span>(cv_image.at&lt;cv::Vec3b&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">2</span>]) ;<span class="comment">//- float(122.7717);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Max image size comparation to know if resize is needed */</span></span><br><span class="line">	<span class="keyword">int</span> max_side = <span class="built_in">MAX</span>(height, width);</span><br><span class="line">	<span class="keyword">int</span> min_side = <span class="built_in">MIN</span>(height, width);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> max_side_scale = <span class="built_in"><span class="keyword">float</span></span>(max_side) / MAX_INPUT_SIDE;</span><br><span class="line">	<span class="keyword">float</span> min_side_scale = <span class="built_in"><span class="keyword">float</span></span>(min_side) / MIN_INPUT_SIDE;</span><br><span class="line">	<span class="keyword">float</span> max_scale = <span class="built_in">MAX</span>(max_side_scale, min_side_scale);</span><br><span class="line">	<span class="keyword">float</span> img_scale = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (max_scale &gt; <span class="number">1</span>)</span><br><span class="line">		img_scale = <span class="built_in"><span class="keyword">float</span></span>(<span class="number">1</span>) / max_scale;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> height_resized = <span class="built_in"><span class="keyword">int</span></span>(height * img_scale);</span><br><span class="line">	<span class="keyword">int</span> width_resized = <span class="built_in"><span class="keyword">int</span></span>(width * img_scale);</span><br><span class="line"></span><br><span class="line">	cv::Mat cv_resized;</span><br><span class="line">	cv::<span class="built_in">resize</span>(cv_new, cv_resized, cv::<span class="built_in">Size</span>(width_resized, height_resized));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> data_buf[height_resized*width_resized * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; height_resized; ++h)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; width_resized; ++w)</span><br><span class="line">		&#123;</span><br><span class="line">			data_buf[(<span class="number">0</span> * height_resized + h)*width_resized + w] = <span class="built_in"><span class="keyword">float</span></span>(cv_resized.at&lt;cv::Vec3f&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">0</span>]);</span><br><span class="line">			data_buf[(<span class="number">1</span> * height_resized + h)*width_resized + w] = <span class="built_in"><span class="keyword">float</span></span>(cv_resized.at&lt;cv::Vec3f&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">1</span>]);</span><br><span class="line">			data_buf[(<span class="number">2</span> * height_resized + h)*width_resized + w] = <span class="built_in"><span class="keyword">float</span></span>(cv_resized.at&lt;cv::Vec3f&gt;(cv::<span class="built_in">Point</span>(w, h))[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	net_-&gt;<span class="built_in">blob_by_name</span>(<span class="string">&quot;data&quot;</span>)-&gt;<span class="built_in">Reshape</span>(<span class="number">1</span>, num_channels_, height_resized, width_resized);</span><br><span class="line">	Blob&lt;<span class="keyword">float</span>&gt; * input_blobs = net_-&gt;<span class="built_in">input_blobs</span>()[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (Caffe::<span class="built_in">mode</span>()) &#123;</span><br><span class="line">		<span class="keyword">case</span> Caffe::CPU:</span><br><span class="line">			<span class="built_in">memcpy</span>(input_blobs-&gt;<span class="built_in">mutable_cpu_data</span>(), data_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>) * input_blobs-&gt;<span class="built_in">count</span>());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> Caffe::GPU:</span><br><span class="line">			<span class="built_in">caffe_gpu_memcpy</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)* input_blobs-&gt;<span class="built_in">count</span>(), data_buf, input_blobs-&gt;<span class="built_in">mutable_gpu_data</span>());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Unknow Caffe mode&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage caffe_test &lt;net.prototxt&gt; &lt;net.caffemodel&gt; &lt;inputFile_txt&gt; &lt;outputDirectory&gt; &lt;output_prefix&gt;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> GPUID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	std::string  prototxt_file = argv[<span class="number">1</span>];</span><br><span class="line">	std::string caffemodel_file = argv[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * input_files_path = argv[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * output_directory = argv[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Reading the given prototxt file : &quot;</span> &lt;&lt; prototxt_file &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Reading the given caffemodel file: &quot;</span> &lt;&lt; caffemodel_file &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	FILE * fs;</span><br><span class="line">	<span class="keyword">char</span> * image_path = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> buff_size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">ssize_t</span> read;</span><br><span class="line"></span><br><span class="line">	fs = <span class="built_in">fopen</span>(input_files_path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!fs) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Unable to open the file.&quot;</span> &lt;&lt; input_files_path &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">CaffeDump <span class="title">dump</span><span class="params">(prototxt_file.c_str(), caffemodel_file.c_str(), GPUID)</span></span>;</span><br><span class="line"></span><br><span class="line">	cv::Mat image = cv::<span class="built_in">imread</span>(input_files_path, CV_LOAD_IMAGE_COLOR);</span><br><span class="line">	std::cout &lt;&lt; input_files_path &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//dump.caffe_forward(image, &quot;bb-output-tiled&quot;, 0);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		dump.<span class="built_in">caffe_forward</span>(image, <span class="string">&quot;multi-label&quot;</span>, i, <span class="string">&quot;./l&quot;</span>+std::<span class="built_in">to_string</span>(i), <span class="number">8</span>);&#125;</span><br><span class="line">	dump.<span class="built_in">caffe_forward</span>(image, <span class="string">&quot;data&quot;</span> ,<span class="number">2</span>, <span class="string">&quot;./org&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//dump.caffe_forward(image, &quot;type-conv-tiled&quot; ,0);</span></span><br><span class="line"></span><br><span class="line">	BlobProto blob_proto;</span><br><span class="line">	string mean_file = <span class="string">&quot;/data1/workspace/liyiran/VPGNet/caffe/models/vpgnet-novp/driving_mean_train.binaryproto&quot;</span>;</span><br><span class="line">	<span class="built_in">ReadProtoFromBinaryFileOrDie</span>(mean_file, &amp;blob_proto);</span><br><span class="line">	Blob&lt;<span class="keyword">float</span>&gt; data_mean_;</span><br><span class="line">	data_mean_.<span class="built_in">FromProto</span>(blob_proto);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;mean file:&quot;</span> &lt;&lt; data_mean_.<span class="built_in">num</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; data_mean_.<span class="built_in">channels</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; data_mean_.<span class="built_in">height</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; data_mean_.<span class="built_in">width</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>make.sh，具体路径根据实际机器情况自行配置：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/local/boost/lib:/usr/local/cuda/lib64:/usr/local/lib</span><br><span class="line">g++ -std=c++11 caffe_inference.cpp `pkg-config --libs opencv` -I /data1/workspace/liyiran/VPGNet/caffe/build/ -I /data1/workspace/liyiran/VPGNet/caffe/build/src/  -L /data1/workspace/liyiran/VPGNet/caffe/build/lib/ -o caffe_inference -lboost_system -lcaffe -lglog -g</span><br></pre></td></tr></table></figure></li></ul></li><li><p>python版inference及后处理</p><ul><li><p>deploy.prototxt</p><p><a href="https://vivounicorn.github.io/images/ai_chapter_13/deploy.prototxt">点击下载 deploy.prototxt 文件</a></p></li><li><p>py_inference.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> NaN, Inf, arange, isscalar, asarray, array</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> scipy.signal <span class="keyword">as</span> signal</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> compiler.ast <span class="keyword">import</span> flatten</span><br><span class="line"></span><br><span class="line">caffe_root = <span class="string">&#x27;/data1/workspace/liyiran/VPGNet/caffe/&#x27;</span></span><br><span class="line"></span><br><span class="line">deployPrototxt = <span class="string">&#x27;../deploy.prototxt&#x27;</span></span><br><span class="line">modelFile = <span class="string">&#x27;../snapshots/split_iter_100000.caffemodel&#x27;</span></span><br><span class="line">meanFile = <span class="string">&#x27;/models/vpgnet-novp/driving_mean_train.binaryproto&#x27;</span></span><br><span class="line">imageListFile = <span class="string">&#x27;./image_list.txt&#x27;</span></span><br><span class="line">resultFile = <span class="string">&#x27;PredictResult.txt&#x27;</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>, caffe_root + <span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"></span><br><span class="line">colors = &#123;<span class="number">1</span>:<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>:<span class="string">&#x27;g&#x27;</span>, <span class="number">4</span>:<span class="string">&#x27;k&#x27;</span>, <span class="number">5</span>:<span class="string">&#x27;y&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#网络初始化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initilize</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;initilize ... &#x27;</span></span><br><span class="line">    caffe.set_mode_gpu()</span><br><span class="line">    caffe.set_device(<span class="number">0</span>)</span><br><span class="line">    net = caffe.Net(deployPrototxt, modelFile,caffe.TEST)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_mean</span>(<span class="params">binMean,npyMean</span>):</span></span><br><span class="line">    blob = caffe.proto.caffe_pb2.BlobProto()</span><br><span class="line">    bin_mean = <span class="built_in">open</span>(binMean, <span class="string">&#x27;rb&#x27;</span> ).read()</span><br><span class="line">    blob.ParseFromString(bin_mean)</span><br><span class="line">    arr = np.array( caffe.io.blobproto_to_array(blob) )</span><br><span class="line">    npy_mean = arr[<span class="number">0</span>]</span><br><span class="line">    np.save(npyMean, npy_mean )</span><br><span class="line"></span><br><span class="line"><span class="comment">#取出网络中的params和net.blobs的中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference</span>(<span class="params">image, net</span>):</span></span><br><span class="line">    <span class="comment"># input preprocessing: &#x27;data&#x27; is the name of the input blob == net.inputs[0]</span></span><br><span class="line">    transformer = caffe.io.Transformer(&#123;<span class="string">&#x27;data&#x27;</span>: net.blobs[<span class="string">&#x27;data&#x27;</span>].data.shape&#125;)</span><br><span class="line">    transformer.set_transpose(<span class="string">&#x27;data&#x27;</span>, (<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    binMean=caffe_root + meanFile</span><br><span class="line">    npyMean=caffe_root+<span class="string">&#x27;/models/vpgnet-novp/driving_mean_train.npy&#x27;</span></span><br><span class="line">    convert_mean(binMean,npyMean)</span><br><span class="line">    transformer.set_mean(<span class="string">&#x27;data&#x27;</span>, np.load(npyMean).mean(<span class="number">1</span>).mean(<span class="number">1</span>)) <span class="comment"># mean pixel</span></span><br><span class="line">    transformer.set_raw_scale(<span class="string">&#x27;data&#x27;</span>, <span class="number">255</span>)</span><br><span class="line">    <span class="comment"># the reference model operates on images in [0,255] range instead of [0,1]</span></span><br><span class="line">    transformer.set_channel_swap(<span class="string">&#x27;data&#x27;</span>, (<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">    <span class="comment"># the reference model has channels in BGR order instead of RGB</span></span><br><span class="line"></span><br><span class="line">    net.blobs[<span class="string">&#x27;data&#x27;</span>].data[...] = transformer.preprocess(<span class="string">&#x27;data&#x27;</span>, caffe.io.load_image(image))</span><br><span class="line">    out = net.forward()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;# blob info of net...&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span>.join(<span class="built_in">str</span>(k)+<span class="string">&quot;:&quot;</span>+<span class="built_in">str</span>(v) <span class="keyword">for</span> k,v <span class="keyword">in</span> [(k, v.data.shape) <span class="keyword">for</span> k, v <span class="keyword">in</span> net.blobs.items()])</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;# param info of net...&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span>.join(<span class="built_in">str</span>(k)+<span class="string">&quot;:&quot;</span>+<span class="built_in">str</span>(v) <span class="keyword">for</span> k,v <span class="keyword">in</span> [(k, v[<span class="number">0</span>].data.shape) <span class="keyword">for</span> k, v <span class="keyword">in</span> net.params.items()])</span><br><span class="line">    <span class="comment">#网络提取L6c的卷积核</span></span><br><span class="line">    <span class="comment">#filters = net.params[&#x27;L6c&#x27;][0].data</span></span><br><span class="line">    <span class="comment">#with open(&#x27;FirstLayerFilter.pickle&#x27;,&#x27;wb&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#   pickle.dump(filters,f)</span></span><br><span class="line">    <span class="comment">#vis_square(filters.transpose(0, 2, 3, 1))</span></span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_features</span>(<span class="params">net,layer_name,channels,fname,single_layer=<span class="number">0</span>,factor=<span class="number">8</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> net.blobs.has_key(layer_name):</span><br><span class="line"> 	<span class="built_in">print</span> <span class="string">&quot;layer&#x27;s name is not exist.&quot;</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> channels &lt; <span class="number">1</span>:</span><br><span class="line">    	fea = net.blobs[layer_name].data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> single_layer == <span class="number">0</span>:</span><br><span class="line">   	fea = net.blobs[layer_name].data[<span class="number">0</span>][<span class="number">0</span>:channels]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fea = net.blobs[layer_name].data[<span class="number">0</span>][channels-<span class="number">1</span>:channels]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#multi_label_shifted = fea</span></span><br><span class="line">    multi_label_shifted = np.zeros(fea.shape)</span><br><span class="line">    multi_label_shifted[:,<span class="number">1</span>:,<span class="number">1</span>:] = fea[:,:-<span class="number">1</span>,:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    vis_and_resize(multi_label_shifted,<span class="number">0</span>,<span class="number">0</span>,factor,fname)</span><br><span class="line">    <span class="keyword">if</span> channels &gt;= <span class="number">1</span>:</span><br><span class="line">    	prob_histogram(multi_label_shifted,fname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vis_and_resize</span>(<span class="params">data, padsize=<span class="number">1</span>, padval=<span class="number">0</span>, factor=<span class="number">8</span>, fname=<span class="string">&#x27;heatmap.jpg&#x27;</span></span>):</span></span><br><span class="line">    data -= data.<span class="built_in">min</span>()</span><br><span class="line">    data /= data.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#让合成图为方</span></span><br><span class="line">    n = <span class="built_in">int</span>(np.ceil(np.sqrt(data.shape[<span class="number">0</span>])))</span><br><span class="line">    padding = ((<span class="number">0</span>, n ** <span class="number">2</span> - data.shape[<span class="number">0</span>]), (<span class="number">0</span>, padsize), (<span class="number">0</span>, padsize)) + ((<span class="number">0</span>, <span class="number">0</span>),) * (data.ndim - <span class="number">3</span>)</span><br><span class="line">    data = np.pad(data, padding, mode=<span class="string">&#x27;constant&#x27;</span>, constant_values=(padval, padval))</span><br><span class="line">    <span class="comment">#合并卷积图到一个图像中</span></span><br><span class="line"></span><br><span class="line">    data = data.reshape((n, n) + data.shape[<span class="number">1</span>:]).transpose((<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>) + <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">4</span>, data.ndim + <span class="number">1</span>)))</span><br><span class="line">    data = data.reshape((n * data.shape[<span class="number">1</span>], n * data.shape[<span class="number">3</span>]) + data.shape[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(data.shape[<span class="number">1</span>], data.shape[<span class="number">0</span>]),dpi=<span class="number">1</span>)</span><br><span class="line">    plt.subplots_adjust(top=<span class="number">1</span>,bottom=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">1</span>,hspace=<span class="number">0</span>,wspace=<span class="number">0</span>)</span><br><span class="line">    frame = plt.gca()</span><br><span class="line">    frame.axes.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    frame.axes.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    plt.imshow(data)</span><br><span class="line">    plt.savefig(fname)</span><br><span class="line">    plt.close(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    img = cv2.imread(fname)</span><br><span class="line">    height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line">    img = cv2.resize(img, <span class="literal">None</span>, fx=factor, fy=factor, interpolation=cv2.INTER_AREA)</span><br><span class="line">    name = fname.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name)==<span class="number">2</span>:</span><br><span class="line">    	cv2.imwrite(name[<span class="number">0</span>]+<span class="string">&quot;_8x.&quot;</span>+name[<span class="number">1</span>], img)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">	cv2.imwrite(fname+<span class="string">&quot;_8x.jpg&quot;</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prob_histogram</span>(<span class="params">prob,fname=<span class="string">&#x27;heatmap_his.jpg&#x27;</span></span>):</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">30</span>, <span class="number">15</span>))</span><br><span class="line">    plt.plot(prob.flat)</span><br><span class="line">    name = fname.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name)==<span class="number">2</span>:</span><br><span class="line">	plt.savefig(name[<span class="number">0</span>]+<span class="string">&quot;_his.&quot;</span>+name[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">	plt.savefig(fname+<span class="string">&quot;_his.jpg&quot;</span>)</span><br><span class="line">    plt.close(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line">    width = prob.shape[<span class="number">1</span>] * prob.shape[<span class="number">2</span>]</span><br><span class="line">    x_vals = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, width))</span><br><span class="line">    y_vals = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, width))</span><br><span class="line">    z_vals = []</span><br><span class="line">    <span class="keyword">for</span> p1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,prob.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment">#print smapling_peaks(prob.tolist()[0][p1])</span></span><br><span class="line">	<span class="keyword">for</span> p2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,prob.shape[<span class="number">2</span>]):</span><br><span class="line">		z_vals.append(prob.tolist()[<span class="number">0</span>][p1][p2])</span><br><span class="line">    ax.plot(x_vals, y_vals, z_vals)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name)==<span class="number">2</span>:</span><br><span class="line">	plt.savefig(name[<span class="number">0</span>]+<span class="string">&quot;_3d.&quot;</span>+name[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       	plt.savefig(fname+<span class="string">&quot;_3d.jpg&quot;</span>)</span><br><span class="line">    plt.close(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peakdet</span>(<span class="params">v, delta, x = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Converted from MATLAB script at http://billauer.co.il/peakdet.html</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns two arrays</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function [maxtab, mintab]=peakdet(v, delta, x)</span></span><br><span class="line"><span class="string">    %PEAKDET Detect peaks in a vector</span></span><br><span class="line"><span class="string">    %        [MAXTAB, MINTAB] = PEAKDET(V, DELTA) finds the local</span></span><br><span class="line"><span class="string">    %        maxima and minima (&quot;peaks&quot;) in the vector V.</span></span><br><span class="line"><span class="string">    %        MAXTAB and MINTAB consists of two columns. Column 1</span></span><br><span class="line"><span class="string">    %        contains indices in V, and column 2 the found values.</span></span><br><span class="line"><span class="string">    %</span></span><br><span class="line"><span class="string">    %        With [MAXTAB, MINTAB] = PEAKDET(V, DELTA, X) the indices</span></span><br><span class="line"><span class="string">    %        in MAXTAB and MINTAB are replaced with the corresponding</span></span><br><span class="line"><span class="string">    %        X-values.</span></span><br><span class="line"><span class="string">    %</span></span><br><span class="line"><span class="string">    %        A point is considered a maximum peak if it has the maximal</span></span><br><span class="line"><span class="string">    %        value, and was preceded (to the left) by a value lower by</span></span><br><span class="line"><span class="string">    %        DELTA.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    % Eli Billauer, 3.4.05 (Explicitly not copyrighted).</span></span><br><span class="line"><span class="string">    % This function is released to the public domain; Any use is allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    maxtab = []</span><br><span class="line">    mintab = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        x = arange(<span class="built_in">len</span>(v))</span><br><span class="line"></span><br><span class="line">    v = asarray(v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(v) != <span class="built_in">len</span>(x):</span><br><span class="line">        sys.exit(<span class="string">&#x27;Input vectors v and x must have same length&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isscalar(delta):</span><br><span class="line">        sys.exit(<span class="string">&#x27;Input argument delta must be a scalar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> delta &lt;= <span class="number">0</span>:</span><br><span class="line">        sys.exit(<span class="string">&#x27;Input argument delta must be positive&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    mn, mx = Inf, -Inf</span><br><span class="line">    mnpos, mxpos = NaN, NaN</span><br><span class="line">    lookformax = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arange(<span class="built_in">len</span>(v)):</span><br><span class="line">        this = v[i]</span><br><span class="line">        <span class="keyword">if</span> this &gt; mx:</span><br><span class="line">            mx = this</span><br><span class="line">            mxpos = x[i]</span><br><span class="line">        <span class="keyword">if</span> this &lt; mn:</span><br><span class="line">            mn = this</span><br><span class="line">            mnpos = x[i]</span><br><span class="line">        <span class="keyword">if</span> lookformax:</span><br><span class="line">            <span class="keyword">if</span> this &lt; mx-delta:</span><br><span class="line">                maxtab.append((mxpos, mx))</span><br><span class="line">                mn = this</span><br><span class="line">                mnpos = x[i]</span><br><span class="line">                lookformax = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> this &gt; mn+delta:</span><br><span class="line">                mintab.append((mnpos, mn))</span><br><span class="line">                mx = this</span><br><span class="line">                mxpos = x[i]</span><br><span class="line">                lookformax = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array(maxtab), array(mintab)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smapling_peaks</span>(<span class="params">series</span>):</span></span><br><span class="line">    window = signal.general_gaussian(<span class="number">51</span>, p=<span class="number">1</span>, sig=<span class="number">5</span>)</span><br><span class="line">    filtered = signal.fftconvolve(window, series)</span><br><span class="line">    filtered = (np.average(series) / np.average(filtered)) * filtered</span><br><span class="line">    filtered = np.roll(filtered, -<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    maxtab, mintab = peakdet(filtered,<span class="built_in">abs</span>(<span class="built_in">min</span>(filtered)))</span><br><span class="line">    <span class="comment">#plot(filtered, color=&#x27;red&#x27;)</span></span><br><span class="line">    <span class="comment">#plot(series, color=&#x27;blue&#x27;)</span></span><br><span class="line">    <span class="comment">#scatter(array(maxtab)[:,0], array(maxtab)[:,1], color=&#x27;blue&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> array(maxtab)[:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_processing</span>(<span class="params">oname, fname, clo, th=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> colors.has_key(clo):</span><br><span class="line">    	<span class="built_in">print</span> <span class="string">&#x27;color key error!&#x27;</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    name = fname.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    img2 = cv2.imread(name[<span class="number">0</span>]+<span class="string">&quot;_8x.&quot;</span>+name[<span class="number">1</span>],<span class="number">0</span>)</span><br><span class="line">    height, width = img2.shape[:<span class="number">2</span>]</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    min_val = <span class="built_in">min</span>(flatten(img2.tolist()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        peaks = smapling_peaks(img2[i].tolist()).tolist()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> peaks[:]:</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">abs</span>(img2[i].tolist()[<span class="built_in">int</span>(item)]-min_val)&lt;=th:</span><br><span class="line">			peaks.remove(item)</span><br><span class="line"></span><br><span class="line">    	y.extend([i]*<span class="built_in">len</span>(peaks))</span><br><span class="line">        x.extend(peaks)</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(width, height),dpi=<span class="number">1</span>)</span><br><span class="line">    plt.subplots_adjust(top=<span class="number">1</span>,bottom=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">1</span>,hspace=<span class="number">0</span>,wspace=<span class="number">0</span>)</span><br><span class="line">    frame = plt.gca()</span><br><span class="line">    frame.axes.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    frame.axes.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    org = cv2.imread(oname)</span><br><span class="line">    plt.imshow(org)</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.plot(x,y, marker=<span class="string">&#x27;o&#x27;</span>, c=colors[clo],markersize=<span class="number">200</span>)</span><br><span class="line">    plt.savefig(name[<span class="number">0</span>]+<span class="string">&quot;_post.&quot;</span>+name[<span class="number">1</span>])</span><br><span class="line">    plt.close(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x, y, clo</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    net = initilize()</span><br><span class="line">    testimage = <span class="string">&#x27;f00125.png&#x27;</span></span><br><span class="line">    newt = testimage.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    layer_name = <span class="string">&#x27;multi-label&#x27;</span></span><br><span class="line">    net = inference(testimage, net)</span><br><span class="line">    <span class="comment">#extract_features(net,layer_name, channels=2,fname=&#x27;data_2_&#x27;+testimage,single_layer=1,factor=8)</span></span><br><span class="line">    extract_features(net,layer_name, channels=<span class="number">3</span>,fname=<span class="string">&#x27;data_3_&#x27;</span>+testimage,single_layer=<span class="number">1</span>,factor=<span class="number">8</span>)</span><br><span class="line">    extract_features(net,layer_name, channels=<span class="number">4</span>,fname=<span class="string">&#x27;data_4_&#x27;</span>+testimage,single_layer=<span class="number">1</span>,factor=<span class="number">8</span>)</span><br><span class="line">    extract_features(net,layer_name, channels=<span class="number">5</span>,fname=<span class="string">&#x27;data_5_&#x27;</span>+testimage,single_layer=<span class="number">1</span>,factor=<span class="number">8</span>)</span><br><span class="line">    <span class="comment">#extract_features(net,layer_name, channels=6,fname=&#x27;data_6_&#x27;+testimage,single_layer=1,factor=8)</span></span><br><span class="line">    <span class="comment">#post_processing(testimage, &#x27;data_2_&#x27;+testimage, 1)</span></span><br><span class="line">    x1,y1,z1 = post_processing(testimage, <span class="string">&#x27;data_3_&#x27;</span>+testimage, <span class="number">1</span>)</span><br><span class="line">    x2,y2,z2 = post_processing(<span class="string">&#x27;data_3_&#x27;</span>+newt[<span class="number">0</span>]+<span class="string">&#x27;_post.&#x27;</span>+newt[<span class="number">1</span>], <span class="string">&#x27;data_4_&#x27;</span>+testimage, <span class="number">4</span>)</span><br><span class="line">    x3,y3,z3 = post_processing(<span class="string">&#x27;data_4_&#x27;</span>+newt[<span class="number">0</span>]+<span class="string">&#x27;_post.&#x27;</span>+newt[<span class="number">1</span>], <span class="string">&#x27;data_5_&#x27;</span>+testimage, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    x = []</span><br><span class="line">    x.extend(x1)</span><br><span class="line">    x.extend(x2)</span><br><span class="line">    x.extend(x3)</span><br><span class="line">    y = []</span><br><span class="line">    y.extend(y1)</span><br><span class="line">    y.extend(y2)</span><br><span class="line">    y.extend(y3)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> x,<span class="string">&#x27;,&#x27;</span>,y</span><br><span class="line">    data = np.c_[x,y]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">    	<span class="built_in">print</span> <span class="string">&#x27;[&#x27;</span>,data[i][<span class="number">0</span>],<span class="string">&#x27;,&#x27;</span>,data[i][<span class="number">4</span>],<span class="string">&#x27;],&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#post_processing(&#x27;data_5_&#x27;+newt[0]+&#x27;_post.&#x27;+newt[1], &#x27;data_6_&#x27;+testimage, 5)</span></span><br></pre></td></tr></table></figure><p></p></li></ul>不同通道后处理后演示如下：<center><img data-src="https://vivounicorn.github.io/images/ai_chapter_13/image_1cbr4iu57354pdj1a331jnhhie9.png" width="800"></center></li></ul></li></ul><h1 id="references">References</h1><p>如有遗漏请提醒我补充：</p><p align="left">1、《Understanding the Bias-Variance Tradeoff》http://scott.fortmann-roe.com/docs/BiasVariance.html</p><p align="left">2、《Boosting Algorithms as Gradient Descent in Function Space》http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.51.6893&amp;rep=rep1&amp;type=pdf</p><p align="left">3、《Optimal Action Extraction for Random Forests and Boosted Trees》http://www.cse.wustl.edu/~ychen/public/OAE.pdf</p><p align="left">4、《Applying Neural Network Ensemble Concepts for Modelling Project Success》http://www.iaarc.org/publications/fulltext/Applying_Neural_Network_Ensemble_Concepts_for_Modelling_Project_Success.pdf</p><p align="left">5、《Introduction to Boosted Trees》https://homes.cs.washington.edu/~tqchen/data/pdf/BoostedTree.pdf</p><p align="left">6、《Machine Learning:Perceptrons》http://ml.informatik.uni-freiburg.de/_media/documents/teaching/ss09/ml/perceptrons.pdf</p><p align="left">7、《An overview of gradient descent optimization algorithms》http://sebastianruder.com/optimizing-gradient-descent/</p><p align="left">8、《Ad Click Prediction: a View from the Trenches》https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf</p><p align="left">9、《ADADELTA: AN ADAPTIVE LEARNING RATE METHOD》http://www.matthewzeiler.com/pubs/googleTR2012/googleTR2012.pdf</p><p align="left">9、《Improving the Convergence of Back-Propagation Learning with Second Order Methods》http://yann.lecun.com/exdb/publis/pdf/becker-lecun-89.pdf</p><p align="left">10、《ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION》https://arxiv.org/pdf/1412.6980v8.pdf</p><p align="left">11、《Adaptive Subgradient Methods for Online Learning and Stochastic Optimization》http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf</p><p align="left">11、《Sparse Allreduce: Efficient Scalable Communication for Power-Law Data》https://arxiv.org/pdf/1312.3020.pdf</p><p align="left">12、《Asynchronous Parallel Stochastic Gradient Descent》https://arxiv.org/pdf/1505.04956v5.pdf</p><p align="left">13、《Large Scale Distributed Deep Networks》https://papers.nips.cc/paper/4687-large-scale-distributed-deep-networks.pdf</p><p align="left">14、《Introduction to Optimization —— Second Order Optimization Methods》https://ipvs.informatik.uni-stuttgart.de/mlr/marc/teaching/13-Optimization/04-secondOrderOpt.pdf</p><p align="left">15、《On the complexity of steepest descent, Newton’s and regularized Newton’s methods for nonconvex unconstrained optimization》http://www.maths.ed.ac.uk/ERGO/pubs/ERGO-09-013.pdf</p><p align="left">16、《On Discriminative vs. Generative classifiers: A comparison of logistic regression and naive Bayes 》http://papers.nips.cc/paper/2020-on-discriminative-vs-generative-classifiers-a-comparison-of-logistic-regression-and-naive-bayes.pdf</p><p align="left">17、《Parametric vs Nonparametric Models》http://mlss.tuebingen.mpg.de/2015/slides/ghahramani/gp-neural-nets15.pdf</p><p align="left">18、《XGBoost: A Scalable Tree Boosting System》https://arxiv.org/abs/1603.02754</p><p align="left">19、一个可视化CNN的网站 http://shixialiu.com/publications/cnnvis/demo/</p><p align="left">20、《Computer vision: LeNet-5, AlexNet, VGG-19, GoogLeNet》http://euler.stat.yale.edu/~tba3/stat665/lectures/lec18/notebook18.html</p><p align="left">21、François Chollet在Quora上的专题问答：https://www.quora.com/session/Fran%C3%A7ois-Chollet/1</p><p align="left">22、《将Keras作为tensorflow的精简接口》https://keras-cn.readthedocs.io/en/latest/blog/keras_and_tensorflow/</p><p align="left">23、《Upsampling and Image Segmentation with Tensorflow and TF-Slim》https://warmspringwinds.github.io/tensorflow/tf-slim/2016/11/22/upsampling-and-image-segmentation-with-tensorflow-and-tf-slim/</p><p align="left">24、《DENSELY CONNECTED CONVOLUTIONAL NETWORKS》http://www.cs.cornell.edu/~gaohuang/papers/DenseNet-CVPR-Slides.pdf</p><p align="left">25、https://github.com/vivounicorn/convnet-study</p></div><div class="popular-posts-header">相关文章推荐</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/d677b2e0.html" rel="bookmark">机器学习与人工智能技术分享-第三章 机器学习中的统一框架</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/307f39c.html" rel="bookmark">机器学习与人工智能技术分享-第二章 建模方法回顾</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/ad2261a2.html" rel="bookmark">机器学习与人工智能技术分享-第四章 最优化原理</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/b12a240.html" rel="bookmark">机器学习与人工智能技术分享-第九章 语义分割</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/fb9cd06d.html" rel="bookmark">机器学习与人工智能技术分享-第七章 金融风控</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"># 机器学习</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" rel="tag"># 自动驾驶</a> <a href="/tags/ADAS/" rel="tag"># ADAS</a> <a href="/tags/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" rel="tag"># 第十三章</a></div><div class="post-nav"><div class="post-nav-item"><a href="/article/b539fa9.html" rel="prev" title="机器学习与人工智能技术分享-第十二章 机器学习框架"><i class="fa fa-chevron-left"></i> 机器学习与人工智能技术分享-第十二章 机器学习框架</a></div><div class="post-nav-item"><a href="/article/ecf91ad8.html" rel="next" title="有趣的微积分">有趣的微积分 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#adas%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6"><span class="nav-text">13. ADAS&amp;自动驾驶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#openpilot"><span class="nav-text">13.1 Openpilot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B"><span class="nav-text">13.1.1 项目简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">13.1.2 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-text">13.1.3 系统架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-text">13.1.4 软件架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%BD%E8%BD%A6%E5%9F%BA%E7%A1%80%E7%BB%84%E5%BB%BA"><span class="nav-text">13.1.5 汽车基础组建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6"><span class="nav-text">13.1.6 公共组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E6%9C%BA%E7%BB%84%E4%BB%B6"><span class="nav-text">13.1.7 手机组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%BB%84%E4%BB%B6"><span class="nav-text">13.1.8 自动驾驶组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">13.1.9 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%A7%86%E8%A7%89%E7%9A%84%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B"><span class="nav-text">13.2 基于视觉的车道检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="nav-text">13.2.1 传统车道检测方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%A5%97%E8%B7%AF"><span class="nav-text">13.2.2 深度学习套路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vanishing-point-guided-network"><span class="nav-text">13.2.3 Vanishing Point Guided Network</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#references"><span class="nav-text">References</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="张磊" src="https://vivounicorn.github.io/images/wali.png"><p class="site-author-name" itemprop="name">张磊</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="sidebar-button motion-element"><i class="fa fa-comment"></i> Chat</div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/vivounicorn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vivounicorn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:zhangleisuper@gmail.com" title="E-Mail → mailto:zhangleisuper@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://weibo.com/vivounicorn" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;vivounicorn" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张磊</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">576k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">8:44</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="//cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{load:["[tex]/mhchem"],source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},packages:{"[+]":["mhchem"]},tags:"ams"},options:{renderActions:{findScript:[10,d=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new d.options.MathItem(e.textContent,d.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},d.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.5/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!0,appId:"m8FPP0CqMpxyTuUvaVOX9qVV-gzGzoHsz",appKey:"Ori6X9PXqQyURvwgl7HT5TJj",placeholder:"赠人玫瑰，手有余香",avatar:"mm",meta:e,pageSize:"10",visitor:!0,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script></body></html>