<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="-l60HPLrjDNbr3Ni1wLsNkiKiCWUAmxiC_ObB8vNMF0"><meta name="msvalidate.01" content="AF3396A141E1B198CA1BE76915B3969F"><meta name="yandex-verification" content="ee8492bd2e7708db"><meta name="baidu-site-verification" content="code-OBKi1CbRLy"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"vivounicorn.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="本章对机器学习在计算机视觉尤其是目标检测与识别方面的各种代表性模型和算法做了原理介绍和效果展示。"><meta property="og:type" content="article"><meta property="og:title" content="机器学习与人工智能技术分享-第八章 目标检测与识别"><meta property="og:url" content="https://vivounicorn.github.io/article/8deb4264.html"><meta property="og:site_name" content="业精于勤，荒于嬉；行成于思，毁于随。"><meta property="og:description" content="本章对机器学习在计算机视觉尤其是目标检测与识别方面的各种代表性模型和算法做了原理介绍和效果展示。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/cm_mask.jpg"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bg86igedlru9801vgh8f913g4m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bga5pfj1d621rq7i851vvprc19.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bga9sm381ben1hhu167411ng1h9f13.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bga9fgjm5ei1r9ks661milsvpm.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgaclat41i5iddrrsg198m4h529.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgagj3gmmo21cu5v0tsvacou2m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgagloviabk1f61cm2ldoco733.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgcn7re5ia8isa12v2gih4do9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgdcp5041m4g1ftk6aq1db91tk4m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgdefki817bkpp61od4bq61ch713.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgf6dah21ok1hj71cl1h1h1p1j9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgf7av4q1fasqp1uimn2c1uvkm.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgfb34cc7i713lcnhr3881oqs1g.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbntg01g031n4o1l4ge7uasv3u.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbfv0e1i8n4as1l6qn70ome2n.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbl582ucc3981voe1dgg1o8b3h.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbj2es9mh1m4tkkgmv6tsb34.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgfh5oqq50153t9n15a4fr1t.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1baou2biq9uhumh1tm1d95du99.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgpup10fl1g1he71goo1o9617jem.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgsbrok31sh917c5ju5jvrn1qm.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgs6vv3j1uqh179e1aalshh1r0h9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgscko9j1q99uf5fkaq31ifv13.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgsg5gtkprvdbthhf4793bd1g.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgsg8da2e9abus1i219c61ulb1t.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgunun1usbfjgt1p0o1rhq1fgq9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgur286f1vmo1f71uau8jh1tp8m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bh4i570957619rpopqks14r4p.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bh4kt6mh1vhbm2b1e161oob2eh16.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bhehjb06nst2511lbr19d64jt39.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bhes1rl71nh81e9ljv41nnbpr23m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bhet2nk1per1nd3c3tg5f1u7m43.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bivqa5cb1hbeksa7gbdm123o1g.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bivr14vrusab6vouf12a9la11t.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bivq6gre1al81aqq1cgcflq78m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bj1mie6rheb17fo2hh1sk3js59.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjht1v6fjkca6cpa49jh11j926.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjjioarcna9g52sdk98v1ko72j.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjjiq26o181l1m5r1d6r1ktq1td30.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjhhinlo1b97tjeralm8r1iddv.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/VGG16-fasterrcnn.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjk8ruf11p2rkalrqph4u1jk53p.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjhi2u9n1aahsa712s5s2gi621c.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjmrl00f1l1f8pnpg2qkbb1o9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjka01lv1t6k184g1pt81r69ek746.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bord2chg3k91e1918ga1lb4dcb9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bordnnep1lfsh8h13hdu2lo0h1m.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1borduslh1ghka2p1odb2o1fk323.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1borjgjtc16vu1od1qk619t61k8f30.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1borjid0t1m1qeeaj281ja31o1j3d.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bnq3ig3p88edhnnlq17ml1ng2v.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bnq32c2323o12giggg1q6ri5k9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1bnmv6i6n181gsds1ea7r1q13v49.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9b0b69pfu15spn1q1r8e3ug9.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9idtee10si1p1d1gvm1djp1uikm.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9ksjj1pmb1sa6cm92lv1pga52.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9l3s1j1ogm198q14ed1oc116fo5f.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9m0fcunr3ou4143msh6160h5s.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9mgbktmq3qm6tt17bd1g746p.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/k-growth.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9ne9qt9661umllgh1pif1rgc76.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9q7n3n1mrnnh555lvddl087j.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ckcktrsoqnj16k0103c1o78vbi80.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/image_1ckckvl6c1jofn1i10ji1666cr58d.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/a07ym-aobhi.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/mask-rcnn.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/me.jpeg"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Identity.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Rotate.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Linear_interpolation.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/Bilinear_interpolation.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/RoiPooling.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/STN.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/RoiAligngrid.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/RoiAlignsimple.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/RoiAlignmax.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/roialign_org.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/roialign_roi.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/roialign_fm.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/roialign_sample.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/roialign_ex.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/roialign_all.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/roialign_out.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/maskrcnn_head.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/bce.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/cm.jpg"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/cm_mask.jpg"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/street1.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/street1_mask.jpg"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/street2.png"><meta property="og:image" content="https://vivounicorn.github.io/images/ai_chapter_8/street2_mask.jpg"><meta property="article:published_time" content="2021-09-11T06:25:42.000Z"><meta property="article:modified_time" content="2021-12-20T06:25:42.000Z"><meta property="article:author" content="张磊"><meta property="article:tag" content="机器学习"><meta property="article:tag" content="第八章"><meta property="article:tag" content="目标检测"><meta property="article:tag" content="目标识别"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://vivounicorn.github.io/images/ai_chapter_8/cm_mask.jpg"><link rel="canonical" href="https://vivounicorn.github.io/article/8deb4264.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>机器学习与人工智能技术分享-第八章 目标检测与识别 | 业精于勤，荒于嬉；行成于思，毁于随。</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/dplayer/1.26.0/DPlayer.min.js"></script></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">业精于勤，荒于嬉；行成于思，毁于随。</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">花晨月夕</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div><img itemprop="image" src="https://vivounicorn.github.io/images/background.jpg"></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://vivounicorn.github.io/article/8deb4264.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://vivounicorn.github.io/images/wali.png"><meta itemprop="name" content="张磊"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="业精于勤，荒于嬉；行成于思，毁于随。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">机器学习与人工智能技术分享-第八章 目标检测与识别</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-11 14:25:42" itemprop="dateCreated datePublished" datetime="2021-09-11T14:25:42+08:00">2021-09-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-12-20 14:25:42" itemprop="dateModified" datetime="2021-12-20T14:25:42+08:00">2021-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a> </span></span><span id="/article/8deb4264.html" class="post-meta-item leancloud_visitors" data-flag-title="机器学习与人工智能技术分享-第八章 目标检测与识别" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/article/8deb4264.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/article/8deb4264.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>93k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1:25</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="https://vivounicorn.github.io/images/ai_chapter_8/cm_mask.jpg" width="30%"> 本章对机器学习在计算机视觉尤其是目标检测与识别方面的各种代表性模型和算法做了原理介绍和效果展示。 <span id="more"></span></p><h1 id="目标检测与识别">8. 目标检测与识别</h1>目标检测的发展历程大致如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bg86igedlru9801vgh8f913g4m.png" width="800"></center><h2 id="selective-search">8.1 Selective Search</h2>对于目标识别任务，比如判断一张图片中有没有车、是什么车，一般需要解决两个问题：目标检测、目标识别。而目标检测任务中通常需要先通过某种方法做图像分割，事先得到候选框；直观的做法是：给定窗口，对整张图片滑动扫描，结束后改变窗口大小重复上面步骤，缺点很明显：重复劳动耗费资源、精度和质量不高等等。 针对上面的问题，一种解决方案是借鉴启发式搜索的方法，充分利用人类的先验知识。J.R.R. Uijlings在《<a target="_blank" rel="noopener" href="https://www.koen.me/research/pub/uijlings-ijcv2013-draft.pdf">Selective Search for Object Recoginition</a>》提出一种方法：基于数据驱动，与具体类别无关的多种策略融合的启发式生成方法。图片包含各种丰富信息，例如：大小、形状、颜色、纹理、物体重叠关系等，如果只使用一种信息往往不能解决大部分问题，例如：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bga5pfj1d621rq7i851vvprc19.png" width="500"></center><p>左边的两只猫可以通过颜色区别而不是通过纹理，右面的变色龙却只能通过纹理区别而不是颜色。</p><h3 id="启发式生成设计准则">8.1.1 启发式生成设计准则</h3><p>所以概括来说：</p><ul><li>能够捕捉到各种尺度物体，大的、小的、边界清楚的、边界模糊的等等； 多尺度的例子： <img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bga9sm381ben1hhu167411ng1h9f13.png" alt="多尺度例子"></li><li>策略多样性，采用多样的策略集合共同作用；</li><li>计算快速，由于生成候选框只是检测第一步，所以计算上它决不能成为瓶颈。</li></ul><h3 id="selective-search-1">8.1.2 Selective Search</h3><p>基于以上准则设计Selective Search算法：</p><ul><li><p>采用层次分组算法解决尺度问题</p><p>引入图像分割中的自下而上分组思想，由于整个过程是层次的，在将整个图合并成一个大的区域的过程中会输出不同尺度的多个子区域。整个过程如下：</p><p>1、利用《<a target="_blank" rel="noopener" href="https://cs.brown.edu/~pff/papers/seg-ijcv.pdf">Efficient Graph-Based Image Segmentation</a>》（基本思想：将图像中每个像素表示为图上的一个节点，用于连接不同节点的无向边都有一个权重，这个权重表示两个节点之间的不相似度，通过贪心算法利用最小生成树做图像分割）生成初始候选区域；</p>2、采用贪心算法合并区域，计算任意两个领域的相似度，把达到阈值的合并，再计算新区域和其所有领域的相似度，循环迭代，直到整个图变成了一个区域，算法如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bga9fgjm5ei1r9ks661milsvpm.png" width="800"></center></li><li><p>多样化策略</p><p>三个方面：使用多种颜色空间、使用多种相似度计算方法、搜索起始区域不固定。</p><p>1、颜色空间有很多种：RGB、HSV、Lab等等，不是论文重点；</p>2、相似度衡量算法，结合了4重策略：<ul><li><p>颜色相似度</p><p>以RGB为例，使用L1-norm归一化每个图像通道的色彩直方图（bins=25），每个区域被表示为25×3维向量:<span class="math inline">\(C_i=\{c_i^1,...,c_i^n\}\)</span>; 颜色相似度定义为： <span class="math display">\[S_{color}(r_i,r_j)=\sum_{k=1}^nmin(c_i^k,c_j^k)\]</span> 区域合并后对新的区域计算其色彩直方图： <span class="math display">\[C_t=\frac{size(r_i)×C_i+size(r_j)×C_j}{size(r_i)+size(r_j)}\]</span> 新区域的大小为：<span class="math inline">\(size(r_t)=size(r_i)+size(r_j)\)</span></p></li><li><p>纹理相似度</p><p>使用快速生成的类SIFT特征，对每个颜色通道在8个方向上应用方差为1的高斯滤波器，对每个颜色通道的每个方向提取bins=10的直方图，所以整个纹理向量维度为：3×8×10=240，表示为：<span class="math inline">\(T_i=\{t_i^1,...,t_i^n\}\)</span>; 纹理相似度定义为： <span class="math display">\[S_{texture}(r_i,r_j)=\sum_{k=1}^nmin(t_i^k,t_j^k)\]</span></p></li><li><p>大小相似度</p><p>该策略希望小的区域能尽早合并，让合并操作比较平滑，防止出现某个大区域逐步吞并其他小区域的情况。相似度定义为： <span class="math display">\[S_{size}=1-\frac{size(r_i)+size(r_j)}{size(im)}\]</span> 其中<span class="math inline">\(size(im)\)</span>为图像包含像素点数目。</p></li><li><p>区域规则度相似度</p><p>能够框住合并后的两个区域的矩形大小越小说明两个区域的合并越规则，如： 区域规则度相似度定义为： <span class="math display">\[S_{fill}=1-\frac{size(BB_{i,j})-size(r_i)-size(r_j)}{size(im)}\]</span></p></li></ul><p>最终相似度为所有策略加权和，文中采用等权方式： <span class="math display">\[S_{r_i,r_j}=\alpha_1\cdot S_{color}(r_i,r_j)+\alpha_2\cdot S_{texture}(r_i,r_j)+\alpha_3\cdot S_{size}(r_i,r_j)+\alpha_4\cdot S_{fill}(r_i,r_j)\]</span></p></li></ul><h3 id="使用selective-search做目标识别">8.1.3 使用Selective Search做目标识别</h3>训练过程包含：提取候选框、提取特征、生成正负样本、训练模型，图示如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgaclat41i5iddrrsg198m4h529.png" width="800"></center><p>早期图像特征提取往往是各种HOG特征或BoW特征，现在CNN特征几乎一统天下。 检测定位效果评价采用Average Best Overlap（ABO）和Mean Average Best Overlap（MABO）： <span class="math display">\[ ABO=\frac{1}{|G^c|}\sum_{g_i^c\in G^c}max_{I_j\in L} Overlap(g_i^c,l_j) \]</span> 其中：<span class="math inline">\(c\)</span>为类别标注、<span class="math inline">\(g_i^c\)</span>为类别<span class="math inline">\(c\)</span>下的ground truth，<span class="math inline">\(L\)</span>为通过Selective Search生成的候选框。 <span class="math display">\[ MABO=\frac{1}{|C|}\sum_{i=1}^n ABO(C_i) \]</span></p><h3 id="代码实践">8.1.4 代码实践</h3><p>参见<a target="_blank" rel="noopener" href="https://github.com/vivounicorn/selectivesearch">AlpacaDB</a>。</p><ul><li>selectivesearch.py<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> skimage.io</span><br><span class="line"><span class="keyword">import</span> skimage.feature</span><br><span class="line"><span class="keyword">import</span> skimage.color</span><br><span class="line"><span class="keyword">import</span> skimage.transform</span><br><span class="line"><span class="keyword">import</span> skimage.util</span><br><span class="line"><span class="keyword">import</span> skimage.segmentation</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;Selective Search for Object Recognition&quot; by J.R.R. Uijlings et al.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  - Modified version with LBP extractor for texture vectorization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_segments</span>(<span class="params">im_orig, scale, sigma, min_size</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        segment smallest regions by the algorithm of Felzenswalb and</span></span><br><span class="line"><span class="string">        Huttenlocher</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># open the Image</span></span><br><span class="line">    im_mask = skimage.segmentation.felzenszwalb(</span><br><span class="line">        skimage.util.img_as_float(im_orig), scale=scale, sigma=sigma,</span><br><span class="line">        min_size=min_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># merge mask channel to the image as a 4th channel</span></span><br><span class="line">    im_orig = numpy.append(</span><br><span class="line">        im_orig, numpy.zeros(im_orig.shape[:<span class="number">2</span>])[:, :, numpy.newaxis], axis=<span class="number">2</span>)</span><br><span class="line">    im_orig[:, :, <span class="number">3</span>] = im_mask</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> im_orig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_sim_colour</span>(<span class="params">r1, r2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        calculate the sum of histogram intersection of colour</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="built_in">min</span>(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(r1[<span class="string">&quot;hist_c&quot;</span>], r2[<span class="string">&quot;hist_c&quot;</span>])])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_sim_texture</span>(<span class="params">r1, r2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        calculate the sum of histogram intersection of texture</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="built_in">min</span>(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(r1[<span class="string">&quot;hist_t&quot;</span>], r2[<span class="string">&quot;hist_t&quot;</span>])])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_sim_size</span>(<span class="params">r1, r2, imsize</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        calculate the size similarity over the image</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - (r1[<span class="string">&quot;size&quot;</span>] + r2[<span class="string">&quot;size&quot;</span>]) / imsize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_sim_fill</span>(<span class="params">r1, r2, imsize</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        calculate the fill similarity over the image</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    bbsize = (</span><br><span class="line">        (<span class="built_in">max</span>(r1[<span class="string">&quot;max_x&quot;</span>], r2[<span class="string">&quot;max_x&quot;</span>]) - <span class="built_in">min</span>(r1[<span class="string">&quot;min_x&quot;</span>], r2[<span class="string">&quot;min_x&quot;</span>]))</span><br><span class="line">        * (<span class="built_in">max</span>(r1[<span class="string">&quot;max_y&quot;</span>], r2[<span class="string">&quot;max_y&quot;</span>]) - <span class="built_in">min</span>(r1[<span class="string">&quot;min_y&quot;</span>], r2[<span class="string">&quot;min_y&quot;</span>]))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - (bbsize - r1[<span class="string">&quot;size&quot;</span>] - r2[<span class="string">&quot;size&quot;</span>]) / imsize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_calc_sim</span>(<span class="params">r1, r2, imsize</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (_sim_colour(r1, r2) + _sim_texture(r1, r2)</span><br><span class="line">            + _sim_size(r1, r2, imsize) + _sim_fill(r1, r2, imsize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_calc_colour_hist</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        calculate colour histogram for each region</span></span><br><span class="line"><span class="string">        the size of output histogram will be BINS * COLOUR_CHANNELS(3)</span></span><br><span class="line"><span class="string">        number of bins is 25 as same as [uijlings_ijcv2013_draft.pdf]</span></span><br><span class="line"><span class="string">        extract HSV</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    BINS = <span class="number">25</span></span><br><span class="line">    hist = numpy.array([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> colour_channel <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># extracting one colour channel</span></span><br><span class="line">        c = img[:, colour_channel]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate histogram for each colour and join to the result</span></span><br><span class="line">        hist = numpy.concatenate(</span><br><span class="line">            [hist] + [numpy.histogram(c, BINS, (<span class="number">0.0</span>, <span class="number">255.0</span>))[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># L1 normalize</span></span><br><span class="line">    hist = hist / <span class="built_in">len</span>(img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_calc_texture_gradient</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        calculate texture gradient for entire image</span></span><br><span class="line"><span class="string">        The original SelectiveSearch algorithm proposed Gaussian derivative</span></span><br><span class="line"><span class="string">        for 8 orientations, but we use LBP instead.</span></span><br><span class="line"><span class="string">        output will be [height(*)][width(*)]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ret = numpy.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>], img.shape[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> colour_channel <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        ret[:, :, colour_channel] = skimage.feature.local_binary_pattern(</span><br><span class="line">            img[:, :, colour_channel], <span class="number">8</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_calc_texture_hist</span>(<span class="params">img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        calculate texture histogram for each region</span></span><br><span class="line"><span class="string">        calculate the histogram of gradient for each colours</span></span><br><span class="line"><span class="string">        the size of output histogram will be</span></span><br><span class="line"><span class="string">            BINS * ORIENTATIONS * COLOUR_CHANNELS(3)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    BINS = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    hist = numpy.array([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> colour_channel <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mask by the colour channel</span></span><br><span class="line">        fd = img[:, colour_channel]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate histogram for each orientation and concatenate them all</span></span><br><span class="line">        <span class="comment"># and join to the result</span></span><br><span class="line">        hist = numpy.concatenate(</span><br><span class="line">            [hist] + [numpy.histogram(fd, BINS, (<span class="number">0.0</span>, <span class="number">1.0</span>))[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># L1 Normalize</span></span><br><span class="line">    hist = hist / <span class="built_in">len</span>(img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_extract_regions</span>(<span class="params">img</span>):</span></span><br><span class="line"></span><br><span class="line">    R = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get hsv image</span></span><br><span class="line">    hsv = skimage.color.rgb2hsv(img[:, :, :<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass 1: count pixel positions</span></span><br><span class="line">    <span class="keyword">for</span> y, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(img):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x, (r, g, b, l) <span class="keyword">in</span> <span class="built_in">enumerate</span>(i):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># initialize a new region</span></span><br><span class="line">            <span class="keyword">if</span> l <span class="keyword">not</span> <span class="keyword">in</span> R:</span><br><span class="line">                R[l] = &#123;</span><br><span class="line">                    <span class="string">&quot;min_x&quot;</span>: <span class="number">0xffff</span>, <span class="string">&quot;min_y&quot;</span>: <span class="number">0xffff</span>,</span><br><span class="line">                    <span class="string">&quot;max_x&quot;</span>: <span class="number">0</span>, <span class="string">&quot;max_y&quot;</span>: <span class="number">0</span>, <span class="string">&quot;labels&quot;</span>: [l]&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># bounding box</span></span><br><span class="line">            <span class="keyword">if</span> R[l][<span class="string">&quot;min_x&quot;</span>] &gt; x:</span><br><span class="line">                R[l][<span class="string">&quot;min_x&quot;</span>] = x</span><br><span class="line">            <span class="keyword">if</span> R[l][<span class="string">&quot;min_y&quot;</span>] &gt; y:</span><br><span class="line">                R[l][<span class="string">&quot;min_y&quot;</span>] = y</span><br><span class="line">            <span class="keyword">if</span> R[l][<span class="string">&quot;max_x&quot;</span>] &lt; x:</span><br><span class="line">                R[l][<span class="string">&quot;max_x&quot;</span>] = x</span><br><span class="line">            <span class="keyword">if</span> R[l][<span class="string">&quot;max_y&quot;</span>] &lt; y:</span><br><span class="line">                R[l][<span class="string">&quot;max_y&quot;</span>] = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass 2: calculate texture gradient</span></span><br><span class="line">    tex_grad = _calc_texture_gradient(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass 3: calculate colour histogram of each region</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> R.items():</span><br><span class="line"></span><br><span class="line">        <span class="comment"># colour histogram</span></span><br><span class="line">        masked_pixels = hsv[:, :, :][img[:, :, <span class="number">3</span>] == k]</span><br><span class="line">        R[k][<span class="string">&quot;size&quot;</span>] = <span class="built_in">len</span>(masked_pixels / <span class="number">4</span>)</span><br><span class="line">        R[k][<span class="string">&quot;hist_c&quot;</span>] = _calc_colour_hist(masked_pixels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># texture histogram</span></span><br><span class="line">        R[k][<span class="string">&quot;hist_t&quot;</span>] = _calc_texture_hist(tex_grad[:, :][img[:, :, <span class="number">3</span>] == k])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_extract_neighbours</span>(<span class="params">regions</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="string">&quot;min_x&quot;</span>] &lt; b[<span class="string">&quot;min_x&quot;</span>] &lt; a[<span class="string">&quot;max_x&quot;</span>]</span><br><span class="line">                <span class="keyword">and</span> a[<span class="string">&quot;min_y&quot;</span>] &lt; b[<span class="string">&quot;min_y&quot;</span>] &lt; a[<span class="string">&quot;max_y&quot;</span>]) <span class="keyword">or</span> (</span><br><span class="line">            a[<span class="string">&quot;min_x&quot;</span>] &lt; b[<span class="string">&quot;max_x&quot;</span>] &lt; a[<span class="string">&quot;max_x&quot;</span>]</span><br><span class="line">                <span class="keyword">and</span> a[<span class="string">&quot;min_y&quot;</span>] &lt; b[<span class="string">&quot;max_y&quot;</span>] &lt; a[<span class="string">&quot;max_y&quot;</span>]) <span class="keyword">or</span> (</span><br><span class="line">            a[<span class="string">&quot;min_x&quot;</span>] &lt; b[<span class="string">&quot;min_x&quot;</span>] &lt; a[<span class="string">&quot;max_x&quot;</span>]</span><br><span class="line">                <span class="keyword">and</span> a[<span class="string">&quot;min_y&quot;</span>] &lt; b[<span class="string">&quot;max_y&quot;</span>] &lt; a[<span class="string">&quot;max_y&quot;</span>]) <span class="keyword">or</span> (</span><br><span class="line">            a[<span class="string">&quot;min_x&quot;</span>] &lt; b[<span class="string">&quot;max_x&quot;</span>] &lt; a[<span class="string">&quot;max_x&quot;</span>]</span><br><span class="line">                <span class="keyword">and</span> a[<span class="string">&quot;min_y&quot;</span>] &lt; b[<span class="string">&quot;min_y&quot;</span>] &lt; a[<span class="string">&quot;max_y&quot;</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    R = regions.items()</span><br><span class="line">    neighbours = []</span><br><span class="line">    <span class="keyword">for</span> cur, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(R[:-<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> R[cur + <span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> intersect(a[<span class="number">1</span>], b[<span class="number">1</span>]):</span><br><span class="line">                neighbours.append((a, b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbours</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_merge_regions</span>(<span class="params">r1, r2</span>):</span></span><br><span class="line">    new_size = r1[<span class="string">&quot;size&quot;</span>] + r2[<span class="string">&quot;size&quot;</span>]</span><br><span class="line">    rt = &#123;</span><br><span class="line">        <span class="string">&quot;min_x&quot;</span>: <span class="built_in">min</span>(r1[<span class="string">&quot;min_x&quot;</span>], r2[<span class="string">&quot;min_x&quot;</span>]),</span><br><span class="line">        <span class="string">&quot;min_y&quot;</span>: <span class="built_in">min</span>(r1[<span class="string">&quot;min_y&quot;</span>], r2[<span class="string">&quot;min_y&quot;</span>]),</span><br><span class="line">        <span class="string">&quot;max_x&quot;</span>: <span class="built_in">max</span>(r1[<span class="string">&quot;max_x&quot;</span>], r2[<span class="string">&quot;max_x&quot;</span>]),</span><br><span class="line">        <span class="string">&quot;max_y&quot;</span>: <span class="built_in">max</span>(r1[<span class="string">&quot;max_y&quot;</span>], r2[<span class="string">&quot;max_y&quot;</span>]),</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: new_size,</span><br><span class="line">        <span class="string">&quot;hist_c&quot;</span>: (</span><br><span class="line">            r1[<span class="string">&quot;hist_c&quot;</span>] * r1[<span class="string">&quot;size&quot;</span>] + r2[<span class="string">&quot;hist_c&quot;</span>] * r2[<span class="string">&quot;size&quot;</span>]) / new_size,</span><br><span class="line">        <span class="string">&quot;hist_t&quot;</span>: (</span><br><span class="line">            r1[<span class="string">&quot;hist_t&quot;</span>] * r1[<span class="string">&quot;size&quot;</span>] + r2[<span class="string">&quot;hist_t&quot;</span>] * r2[<span class="string">&quot;size&quot;</span>]) / new_size,</span><br><span class="line">        <span class="string">&quot;labels&quot;</span>: r1[<span class="string">&quot;labels&quot;</span>] + r2[<span class="string">&quot;labels&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selective_search</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        im_orig, scale=<span class="number">1.0</span>, sigma=<span class="number">0.8</span>, min_size=<span class="number">50</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Selective Search</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">        im_orig : ndarray</span></span><br><span class="line"><span class="string">            Input image</span></span><br><span class="line"><span class="string">        scale : int</span></span><br><span class="line"><span class="string">            Free parameter. Higher means larger clusters in felzenszwalb segmentation.</span></span><br><span class="line"><span class="string">        sigma : float</span></span><br><span class="line"><span class="string">            Width of Gaussian kernel for felzenszwalb segmentation.</span></span><br><span class="line"><span class="string">        min_size : int</span></span><br><span class="line"><span class="string">            Minimum component size for felzenszwalb segmentation.</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">        img : ndarray</span></span><br><span class="line"><span class="string">            image with region label</span></span><br><span class="line"><span class="string">            region label is stored in the 4th value of each pixel [r,g,b,(region)]</span></span><br><span class="line"><span class="string">        regions : array of dict</span></span><br><span class="line"><span class="string">            [</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &#x27;rect&#x27;: (left, top, right, bottom),</span></span><br><span class="line"><span class="string">                    &#x27;labels&#x27;: [...]</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> im_orig.shape[<span class="number">2</span>] == <span class="number">3</span>, <span class="string">&quot;3ch image is expected&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># load image and get smallest regions</span></span><br><span class="line">    <span class="comment"># region label is stored in the 4th value of each pixel [r,g,b,(region)]</span></span><br><span class="line">    img = _generate_segments(im_orig, scale, sigma, min_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">    imsize = img.shape[<span class="number">0</span>] * img.shape[<span class="number">1</span>]</span><br><span class="line">    R = _extract_regions(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extract neighbouring information</span></span><br><span class="line">    neighbours = _extract_neighbours(R)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calculate initial similarities</span></span><br><span class="line">    S = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (ai, ar), (bi, br) <span class="keyword">in</span> neighbours:</span><br><span class="line">        S[(ai, bi)] = _calc_sim(ar, br, imsize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hierarchal search</span></span><br><span class="line">    <span class="keyword">while</span> S != &#123;&#125;:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get highest similarity</span></span><br><span class="line">        i, j = <span class="built_in">sorted</span>(S.items(), cmp=<span class="keyword">lambda</span> a, b: cmp(a[<span class="number">1</span>], b[<span class="number">1</span>]))[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># merge corresponding regions</span></span><br><span class="line">        t = <span class="built_in">max</span>(R.keys()) + <span class="number">1.0</span></span><br><span class="line">        R[t] = _merge_regions(R[i], R[j])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mark similarities for regions to be removed</span></span><br><span class="line">        key_to_delete = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> S.items():</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> k) <span class="keyword">or</span> (j <span class="keyword">in</span> k):</span><br><span class="line">                key_to_delete.append(k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># remove old similarities of related regions</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> key_to_delete:</span><br><span class="line">            <span class="keyword">del</span> S[k]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate similarity set with the new region</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="keyword">lambda</span> a: a != (i, j), key_to_delete):</span><br><span class="line">            n = k[<span class="number">1</span>] <span class="keyword">if</span> k[<span class="number">0</span>] <span class="keyword">in</span> (i, j) <span class="keyword">else</span> k[<span class="number">0</span>]</span><br><span class="line">            S[(t, n)] = _calc_sim(R[t], R[n], imsize)</span><br><span class="line"></span><br><span class="line">    regions = []</span><br><span class="line">    <span class="keyword">for</span> k, r <span class="keyword">in</span> R.items():</span><br><span class="line">        regions.append(&#123;</span><br><span class="line">            <span class="string">&#x27;rect&#x27;</span>: (</span><br><span class="line">                r[<span class="string">&#x27;min_x&#x27;</span>], r[<span class="string">&#x27;min_y&#x27;</span>],</span><br><span class="line">                r[<span class="string">&#x27;max_x&#x27;</span>] - r[<span class="string">&#x27;min_x&#x27;</span>], r[<span class="string">&#x27;max_y&#x27;</span>] - r[<span class="string">&#x27;min_y&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;size&#x27;</span>: r[<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;labels&#x27;</span>: r[<span class="string">&#x27;labels&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img, regions</span><br></pre></td></tr></table></figure></li><li>example.py<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&quot;Agg&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> skimage.data</span><br><span class="line"><span class="keyword">import</span> skimage.io</span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> use_plugin,imread</span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> mpatches</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> savefig</span><br><span class="line"><span class="keyword">import</span> selectivesearch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># loading astronaut image</span></span><br><span class="line">    <span class="comment">#img = skimage.data.astronaut()</span></span><br><span class="line">    use_plugin(<span class="string">&#x27;pil&#x27;</span>)</span><br><span class="line">    img = imread(<span class="string">&#x27;car.jpg&#x27;</span>, as_grey=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># perform selective search</span></span><br><span class="line">    img_lbl, regions = selectivesearch.selective_search(</span><br><span class="line">        img, scale=<span class="number">500</span>, sigma=<span class="number">0.9</span>, min_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    candidates = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> regions:</span><br><span class="line">        <span class="comment"># excluding same rectangle (with different segments)</span></span><br><span class="line">        <span class="keyword">if</span> r[<span class="string">&#x27;rect&#x27;</span>] <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># excluding regions smaller than 2000 pixels</span></span><br><span class="line">        <span class="keyword">if</span> r[<span class="string">&#x27;size&#x27;</span>] &lt; <span class="number">2000</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># distorted rects</span></span><br><span class="line">        x, y, w, h = r[<span class="string">&#x27;rect&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> w / h &gt; <span class="number">1.2</span> <span class="keyword">or</span> h / w &gt; <span class="number">1.2</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        candidates.add(r[<span class="string">&#x27;rect&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># draw rectangles on the original image</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    fig, ax = plt.subplots(ncols=<span class="number">1</span>, nrows=<span class="number">1</span>, figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">    ax.imshow(img)</span><br><span class="line">    <span class="keyword">for</span> x, y, w, h <span class="keyword">in</span> candidates:</span><br><span class="line">        <span class="built_in">print</span> x, y, w, h</span><br><span class="line">        rect = mpatches.Rectangle(</span><br><span class="line">            (x, y), w, h, fill=<span class="literal">False</span>, edgecolor=<span class="string">&#x27;red&#x27;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">        ax.add_patch(rect)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#plt.show()</span></span><br><span class="line">    savefig(<span class="string">&#x27;MyFig.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><a href="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgagj3gmmo21cu5v0tsvacou2m.png">car.jpg原图</a>如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgagj3gmmo21cu5v0tsvacou2m.png" width="500"></center>结果图如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgagloviabk1f61cm2ldoco733.png" width="500"></center><h2 id="overfeat">8.2 OverFeat</h2><p>计算机视觉有三大任务：分类(识别)、定位、检测，从左到右每个任务是下个任务的子任务，所以难度递增。OverFeat是2014年《<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1312.6229">OverFeat:Integrated Recognition, Localization and Detection using Convolutional Networks</a>》中提出的一个基于卷积神经网络的特征提取框架，论文的最大亮点在于通过一个统一的框架去解决图像分类、定位、检测问题，并提出<strong>feature map上的一个点可以还原并对应到原图的一个区域</strong>，于是一些在原图上的操作可以转到在feature map上做，这点对以后的检测算法有较深远的影响。它在ImageNet 2013的task 3定位任务中获得第一，在检测和分类任务中也有不错的表现。</p><h3 id="overfeat分类任务">8.2.1 OverFeat分类任务</h3>文中借鉴了AlexNet的结构，并做了些结构改进和提高了线上inference效率，结构如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgcn7re5ia8isa12v2gih4do9.png" width="800"></center><p>相对AlexNet，网络结构几乎一样，区别在于：</p><blockquote><p>去掉了LRN层，不做额外归一化操作</p></blockquote><blockquote><p>使用区域非重叠pooling</p></blockquote><blockquote><p>前两层使用较小的stride，从而产生较大的feature map，提高了模型精度</p></blockquote><ul><li>Offset Pooling 分类任务中一大亮点是提出利用Offset Pooling做多尺度分类的概念，在一维情况的解释如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgdcp5041m4g1ftk6aq1db91tk4m.png" width="600"></center></li></ul><p>a图代表经过第5个卷积层后的feature map有20个神经元，选取stride=3做非重叠pooling，有以下3种方式：（通常我们只使用第一种）</p><pre><code>&gt; △=0分组:[1,2,3]，[4,5,6],[7,8,9],...,[16,17,18]
&gt; △=1分组:[2,3,4]，[5,6,7],[8,9,10],...,[17,18,19]
&gt; △=2分组:[3,4,5]，[6,7,8],[9,10,11],...,[18,19,20]</code></pre><p>在二维情况下，输入图像在经过FCN及第5个卷积层后得到若干个feature map，使用3x3 filter在feature map上做滑动窗口（注意此时不在原图上做，节省大量计算消耗）。按上图的原理，滑动窗口总共要做9次，从(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)处分别滑动。得到的feature map分别经过后面的3个FC层，得到多组特征，最后拼接起来得到最终特征向量并用于分类。</p><ul><li>Inference自适应输入图片大小</li></ul>训练模型时往往采用的是固定大小图片(后面的SPP-net、Fast R-CNN等模型通过SPP或ROI pooling可以允许输入大小可变)，当inference阶段遇到比规定大小更大的图片时怎么办？可以利用Fully Convolutional Networks（《<a target="_blank" rel="noopener" href="https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf">Fully Convolutional Networks for Semantic Segmentation</a>》）的思想：把卷积层到全连接层映射看成对整张图的卷积操作，把全连接层到全连接层的映射可以看成采用1x1卷积核的卷积操作。以下图说明：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgdefki817bkpp61od4bq61ch713.png" width="600"></center><p>绿色代表卷积核，蓝色代表feature map，当输入大于规定尺寸时，在黄色区域会有额外计算，最终的输出也不是一个值而是一个矩阵，可以用各种策略输出最终结果，比如一种简单做法是用矩阵平均值作为最终分类结果。</p><h3 id="overfeat定位任务">8.2.2 OverFeat定位任务</h3><ul><li><p>回归训练</p>相对于分类问题，定位问题可以与其共享前1~5层网络结构，这种方式也被后面的模型所借鉴，区别是增加了一个<span class="math inline">\(l_2\)</span>的回归损失函数，基本思路是对同一张图缩放产生多尺度图片做输入，用回归网络预测Bounding Box（后面简写为BB）后再做融合，需要注意回归层是与类别相关的，如果有1000个类则有1000个版本，每类一个。回归示意图如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgf6dah21ok1hj71cl1h1h1p1j9.png" width="400"></center><p>第5层pooling结果作为输入，共256个通道，以FCN的思想理解，先走一个4096通道的全连接层再走一个1024通道的全连接层，与前面类似使用Offet Pooing和滑动窗口对每类生成一个4通道矩阵，4个通道分别代表BB的四条边的坐标。</p></li><li><p>网络输出</p>回归网络的输出例子如下，单图下生成多个BB的预测，这些BB倾向于收敛到一个固定位置并且可以定位物体姿势多样化的情况，当然计算复杂度不小，所以没法用到实时检测中。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgf7av4q1fasqp1uimn2c1uvkm.png" width="500"></center></li><li><p>预测融合策略</p><ol type="a"><li>同一幅图在6种不同缩放尺度下分别输入<strong>分类</strong>网络，每种尺度下选top k类别作为标定，用<span class="math inline">\(C_s\)</span>表示；</li><li>对任意尺度<span class="math inline">\(s\)</span>分别输入BB <strong>回归</strong>网络，用<span class="math inline">\(B_s\)</span>表示每个类别对应的BB集合；</li><li>将所有<span class="math inline">\(B_s\)</span>合并为大集合<span class="math inline">\(B\)</span>；</li><li>重复以下过程直到结束： <span class="math display">\[ \begin{array}{l} (b_1^*,b_2^*)=argmin_{b_1\neq b_2 \in B}\text{match_score}(b_1,b_2)\\ if \quad \text{match_score}(b_1^*,b_2^*)&gt;t \quad \\ then \quad stop.\\ Otherwise \quad set \quad B=B-\{b_1^*,b_2^*\}\cup \text{box_merge}(b_1^*,b_2^*) \end{array} \]</span> 其中match_score为两个BB的中心点之间的距离及BB重合区域面积之和，box_merge为两个BB坐标均值，过程很好理解：所有分类（如可能有熊、鲸鱼等）的BB被放在一个大集合，多尺度得到的分类集合中，正确分类会占有优势（置信度、匹配度、BB连续度等），随着迭代的过程正确分类的BB被加强，错误分类的BB被减弱直到消失，不过这个方法确实复杂，可以看到在后来的算法有各种改进和替换。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgfb34cc7i713lcnhr3881oqs1g.png" width="600"></center></li></ol></li></ul><h3 id="overfeat检测任务">8.2.3 OverFeat检测任务</h3><p>与分类类似但需要考虑位置信息，同样采用网络结构共享特征提取，在预测分类中还需要加“背景”这一类。</p><h3 id="代码实践-1">8.2.4 代码实践</h3><p>可参见：<a target="_blank" rel="noopener" href="https://github.com/sermanet/OverFeat">OverFeat</a></p><h2 id="r-cnn">8.3 R-CNN</h2><p>过去若干年，目标检测使用的都是滑动窗口的方式，这种方式计算效率较差，另外以往CNN在ImageNet比赛分类问题的表现更加突出，如何利用这些成果以及ImageNet的大量训练数据去借力打力也是一个值得研究的课题。R-CNN由Ross Girshick等人在《<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1311.2524">Rich feature hierarchies for accurate object detection and semantic segmentation</a>》中提出，OverFeat从某种程度可以看做R-CNN的特例，R-CNN在图像检测领域有很大的影响力，该算法的亮点在于：使用Selective Search代替传统滑动窗口方式生成候选框并使用CNN提取特征；把分类和回归方法同时应用在检测中；当训练数据不足时，通过预训练利用领域数据（知识）做transfer learning，在对象数据集上再应用fine-tuning继续训练。</p><h3 id="iou">8.3.1 IoU</h3>IoU（intersection over union），是用来衡量Bounding Box定位精度的指标，它的定义类似Jaccard距离，假设A为人工标定的BB，B为预测的BB则： <span class="math display">\[IOU=\frac{area(A \cap B)}{area(A \cup B)}\]</span><center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbntg01g031n4o1l4ge7uasv3u.png" width="500"></center><h3 id="nms">8.3.2 NMS</h3>NMS（non-maximum suppression）在目标检测中用来依据置信度消除重叠度过高的重复候选框，从而提高检测算法效率。 例如，<a href="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbfv0e1i8n4as1l6qn70ome2n.png">原图</a>为：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbfv0e1i8n4as1l6qn70ome2n.png" width="500"></center>原图+候选框为：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbl582ucc3981voe1dgg1o8b3h.png" width="500"></center>执行NMS后为：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgnbj2es9mh1m4tkkgmv6tsb34.png" width="500"></center><p>代码可参考：<a target="_blank" rel="noopener" href="http://www.pyimagesearch.com/2014/11/17/non-maximum-suppression-object-detection-python/">Non-Maximum Suppression for Object Detection in Python</a> <strong>nms.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the necessary packages</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#  Felzenszwalb et al.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_max_suppression_slow</span>(<span class="params">boxes, overlapThresh</span>):</span></span><br><span class="line">	<span class="comment"># if there are no boxes, return an empty list</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(boxes) == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">	<span class="comment"># initialize the list of picked indexes</span></span><br><span class="line">	pick = []</span><br><span class="line"></span><br><span class="line">	<span class="comment"># grab the coordinates of the bounding boxes</span></span><br><span class="line">	x1 = boxes[:,<span class="number">0</span>]</span><br><span class="line">	y1 = boxes[:,<span class="number">1</span>]</span><br><span class="line">	x2 = boxes[:,<span class="number">2</span>]</span><br><span class="line">	y2 = boxes[:,<span class="number">3</span>]</span><br><span class="line">	scores = boxes[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># compute the area of the bounding boxes and sort the bounding</span></span><br><span class="line">	<span class="comment"># boxes by the bottom-right y-coordinate of the bounding box</span></span><br><span class="line">	area = (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)</span><br><span class="line">	idxs = np.argsort(scores)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># keep looping while some indexes still remain in the indexes</span></span><br><span class="line">	<span class="comment"># list</span></span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">len</span>(idxs) &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="comment"># grab the last index in the indexes list, add the index</span></span><br><span class="line">		<span class="comment"># value to the list of picked indexes, then initialize</span></span><br><span class="line">		<span class="comment"># the suppression list (i.e. indexes that will be deleted)</span></span><br><span class="line">		<span class="comment"># using the last index</span></span><br><span class="line">		last = <span class="built_in">len</span>(idxs) - <span class="number">1</span></span><br><span class="line">		i = idxs[last]</span><br><span class="line">		pick.append(i)</span><br><span class="line">		suppress = [last]</span><br><span class="line"></span><br><span class="line">		<span class="comment"># loop over all indexes in the indexes list</span></span><br><span class="line">		<span class="keyword">for</span> pos <span class="keyword">in</span> xrange(<span class="number">0</span>, last):</span><br><span class="line">			<span class="comment"># grab the current index</span></span><br><span class="line">			j = idxs[pos]</span><br><span class="line"></span><br><span class="line">			<span class="comment"># find the largest (x, y) coordinates for the start of</span></span><br><span class="line">			<span class="comment"># the bounding box and the smallest (x, y) coordinates</span></span><br><span class="line">			<span class="comment"># for the end of the bounding box</span></span><br><span class="line">			xx1 = <span class="built_in">max</span>(x1[i], x1[j])</span><br><span class="line">			yy1 = <span class="built_in">max</span>(y1[i], y1[j])</span><br><span class="line">			xx2 = <span class="built_in">min</span>(x2[i], x2[j])</span><br><span class="line">			yy2 = <span class="built_in">min</span>(y2[i], y2[j])</span><br><span class="line"></span><br><span class="line">			<span class="comment"># compute the width and height of the bounding box</span></span><br><span class="line">			w = <span class="built_in">max</span>(<span class="number">0</span>, xx2 - xx1 + <span class="number">1</span>)</span><br><span class="line">			h = <span class="built_in">max</span>(<span class="number">0</span>, yy2 - yy1 + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment"># compute the ratio of overlap between the computed</span></span><br><span class="line">			<span class="comment"># bounding box and the bounding box in the area list</span></span><br><span class="line">			overlap = <span class="built_in">float</span>(w * h) / area[j]</span><br><span class="line"></span><br><span class="line">			<span class="comment"># if there is sufficient overlap, suppress the</span></span><br><span class="line">			<span class="comment"># current bounding box</span></span><br><span class="line">			<span class="keyword">if</span> overlap &gt; overlapThresh:</span><br><span class="line">				suppress.append(pos)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># delete all indexes from the index list that are in the</span></span><br><span class="line">		<span class="comment"># suppression list</span></span><br><span class="line">		idxs = np.delete(idxs, suppress)</span><br><span class="line">	<span class="comment"># return only the bounding boxes that were picked</span></span><br><span class="line">	<span class="keyword">return</span> boxes[pick]</span><br></pre></td></tr></table></figure><strong>nms_slow.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the necessary packages</span></span><br><span class="line"><span class="keyword">from</span> pyimagesearch.nms <span class="keyword">import</span> non_max_suppression_slow</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct a list containing the images that will be examined</span></span><br><span class="line"><span class="comment"># along with their respective bounding boxes</span></span><br><span class="line"><span class="comment"># 最后一位为：分类置信度*100</span></span><br><span class="line">images = [</span><br><span class="line">        (<span class="string">&quot;images/333.jpg&quot;</span>, np.array([</span><br><span class="line">        (<span class="number">285</span>,<span class="number">293</span>,<span class="number">713</span>,<span class="number">679</span>,<span class="number">96</span>),</span><br><span class="line">        (<span class="number">9</span>,<span class="number">309</span>,<span class="number">161</span>,<span class="number">719</span>,<span class="number">90</span>),</span><br><span class="line">        (<span class="number">703</span>,<span class="number">259</span>,<span class="number">959</span>,<span class="number">659</span>,<span class="number">93</span>),</span><br><span class="line">	    (<span class="number">291</span>,<span class="number">309</span>,<span class="number">693</span>,<span class="number">663</span>,<span class="number">90</span>),</span><br><span class="line">        (<span class="number">1</span>,<span class="number">371</span>,<span class="number">155</span>,<span class="number">621</span>,<span class="number">80</span>),</span><br><span class="line">        (<span class="number">511</span>,<span class="number">347</span>,<span class="number">681</span>,<span class="number">637</span>,<span class="number">89</span>),</span><br><span class="line">        (<span class="number">293</span>,<span class="number">587</span>,<span class="number">721</span>,<span class="number">671</span>,<span class="number">70</span>),</span><br><span class="line">        (<span class="number">757</span>,<span class="number">469</span>,<span class="number">957</span>,<span class="number">641</span>,<span class="number">60</span>)]))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop over the images</span></span><br><span class="line"><span class="keyword">for</span> (imagePath, boundingBoxes) <span class="keyword">in</span> images:</span><br><span class="line">	<span class="comment"># load the image and clone it</span></span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;[x] %d initial bounding boxes&quot;</span> % (<span class="built_in">len</span>(boundingBoxes))</span><br><span class="line">	image = cv2.imread(imagePath)</span><br><span class="line">	orig = image.copy()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># loop over the bounding boxes for each image and draw them</span></span><br><span class="line">	<span class="keyword">for</span> (startX, startY, endX, endY, c) <span class="keyword">in</span> boundingBoxes:</span><br><span class="line">		cv2.rectangle(orig, (startX, startY), (endX, endY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># perform non-maximum suppression on the bounding boxes</span></span><br><span class="line">	pick = non_max_suppression_slow(boundingBoxes, <span class="number">0.3</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;[x] after applying non-maximum, %d bounding boxes&quot;</span> % (<span class="built_in">len</span>(pick))</span><br><span class="line"></span><br><span class="line">	<span class="comment"># loop over the picked bounding boxes and draw them</span></span><br><span class="line">	<span class="keyword">for</span> (startX, startY, endX, endY,c) <span class="keyword">in</span> pick:</span><br><span class="line">		cv2.rectangle(image, (startX, startY), (endX, endY), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># display the images</span></span><br><span class="line">	cv2.imshow(<span class="string">&quot;Original&quot;</span>, orig)</span><br><span class="line">	cv2.imshow(<span class="string">&quot;After NMS&quot;</span>, image)</span><br><span class="line">	cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p></p><h3 id="map">8.3.3 mAP</h3><p>先介绍什么是AP，以PASCAL VOC CHALLENGE 2010以后的定义做说明。 假设<span class="math inline">\(m\)</span>个样本中有<span class="math inline">\(p\)</span>个正例，依据包含正例的个数，可以得到<span class="math inline">\(p\)</span>个recall值，分别为：<span class="math inline">\(1/p，2/p，3/p，...，p/p\)</span>，对于每个recall值<span class="math inline">\(r\)</span>可以计算出对应<span class="math inline">\(r^{&#39;} \geq r\)</span>的最大precision，然后对这<span class="math inline">\(p\)</span>个precision值取平均即得到AP值。 举个例子，假设是否为车的分类，一共有30个测试样本，预测结果及标注如下：</p><table><thead><tr class="header"><th>编号</th><th>预测值</th><th>实际值</th></tr></thead><tbody><tr class="odd"><td>1</td><td>0.88</td><td>1</td></tr><tr class="even"><td>2</td><td>0.76</td><td>0</td></tr><tr class="odd"><td>3</td><td>0.56</td><td>0</td></tr><tr class="even"><td>4</td><td>0.92</td><td>0</td></tr><tr class="odd"><td>5</td><td>0.10</td><td>1</td></tr><tr class="even"><td>6</td><td>0.77</td><td>1</td></tr><tr class="odd"><td>7</td><td>0.23</td><td>0</td></tr><tr class="even"><td>8</td><td>0.34</td><td>0</td></tr><tr class="odd"><td>9</td><td>0.35</td><td>0</td></tr><tr class="even"><td>10</td><td>0.66</td><td>1</td></tr><tr class="odd"><td>11</td><td>0.56</td><td>0</td></tr><tr class="even"><td>12</td><td>0.45</td><td>1</td></tr><tr class="odd"><td>13</td><td>0.93</td><td>1</td></tr><tr class="even"><td>14</td><td>0.97</td><td>0</td></tr><tr class="odd"><td>15</td><td>0.81</td><td>1</td></tr><tr class="even"><td>16</td><td>0.78</td><td>0</td></tr><tr class="odd"><td>17</td><td>0.66</td><td>0</td></tr><tr class="even"><td>18</td><td>0.54</td><td>0</td></tr><tr class="odd"><td>19</td><td>0.43</td><td>1</td></tr><tr class="even"><td>20</td><td>0.31</td><td>0</td></tr><tr class="odd"><td>21</td><td>0.22</td><td>0</td></tr><tr class="even"><td>22</td><td>0.12</td><td>0</td></tr><tr class="odd"><td>23</td><td>0.02</td><td>0</td></tr><tr class="even"><td>24</td><td>0.05</td><td>1</td></tr><tr class="odd"><td>25</td><td>0.15</td><td>0</td></tr><tr class="even"><td>26</td><td>0.01</td><td>0</td></tr><tr class="odd"><td>27</td><td>0.77</td><td>1</td></tr><tr class="even"><td>28</td><td>0.37</td><td>0</td></tr><tr class="odd"><td>29</td><td>0.43</td><td>1</td></tr><tr class="even"><td>30</td><td>0.99</td><td>1</td></tr></tbody></table><p>按照预测得分降序排列后如下：</p><table><thead><tr class="header"><th>编号</th><th>预测值</th><th>实际值</th></tr></thead><tbody><tr class="odd"><td>30</td><td>0.99</td><td>1</td></tr><tr class="even"><td>14</td><td>0.97</td><td>0</td></tr><tr class="odd"><td>13</td><td>0.93</td><td>1</td></tr><tr class="even"><td>4</td><td>0.92</td><td>0</td></tr><tr class="odd"><td>1</td><td>0.88</td><td>1</td></tr><tr class="even"><td>15</td><td>0.81</td><td>1</td></tr><tr class="odd"><td>16</td><td>0.78</td><td>0</td></tr><tr class="even"><td>6</td><td>0.77</td><td>1</td></tr><tr class="odd"><td>27</td><td>0.77</td><td>1</td></tr><tr class="even"><td>2</td><td>0.76</td><td>0</td></tr><tr class="odd"><td>10</td><td>0.66</td><td>1</td></tr><tr class="even"><td>17</td><td>0.66</td><td>0</td></tr><tr class="odd"><td>3</td><td>0.56</td><td>0</td></tr><tr class="even"><td>11</td><td>0.56</td><td>0</td></tr><tr class="odd"><td>18</td><td>0.54</td><td>0</td></tr><tr class="even"><td>12</td><td>0.45</td><td>1</td></tr><tr class="odd"><td>19</td><td>0.43</td><td>1</td></tr><tr class="even"><td>29</td><td>0.43</td><td>1</td></tr><tr class="odd"><td>28</td><td>0.37</td><td>0</td></tr><tr class="even"><td>9</td><td>0.35</td><td>0</td></tr><tr class="odd"><td>8</td><td>0.34</td><td>0</td></tr><tr class="even"><td>20</td><td>0.31</td><td>0</td></tr><tr class="odd"><td>7</td><td>0.23</td><td>0</td></tr><tr class="even"><td>21</td><td>0.22</td><td>0</td></tr><tr class="odd"><td>25</td><td>0.15</td><td>0</td></tr><tr class="even"><td>22</td><td>0.12</td><td>0</td></tr><tr class="odd"><td>5</td><td>0.10</td><td>1</td></tr><tr class="even"><td>24</td><td>0.05</td><td>1</td></tr><tr class="odd"><td>23</td><td>0.02</td><td>0</td></tr><tr class="even"><td>26</td><td>0.01</td><td>0</td></tr></tbody></table>AP计算过程如下(注意与AUC之间的异同)：<table><tr><td>编号</td><td>预测值</td><td>实际值</td><td>Precision</td><td>Recall（r）</td><td>Max Precision with Recall（r'≥r）</td><td>AP</td></tr><tr><td>30</td><td>0.99</td><td>1</td><td>1/1=1</td><td>1/12=0.08</td><td rowspan="2">1</td><td rowspan="30">0.609</td></tr><tr><td>14</td><td>0.97</td><td>0</td><td>1/2=0.5</td><td>1/12=0.08</td><td></td><td></td></tr><tr><td>13</td><td>0.93</td><td>1</td><td>2/3=0.67</td><td>2/12=0.17</td><td rowspan="2">0.67</td><td></td></tr><tr><td>4</td><td>0.92</td><td>0</td><td>2/4=0.5</td><td>2/12=0.17</td><td></td><td></td></tr><tr><td>1</td><td>0.88</td><td>1</td><td>3/5=0.6</td><td>3/12=0.25</td><td>0.6</td><td></td></tr><tr><td>15</td><td>0.81</td><td>1</td><td>4/6=0.67</td><td>4/12=0.33</td><td rowspan="2">0.67</td><td></td></tr><tr><td>16</td><td>0.78</td><td>0</td><td>4/7=0.57</td><td>4/12=0.33</td><td></td><td></td></tr><tr><td>6</td><td>0.77</td><td>1</td><td>5/8=0.63</td><td>5/12=0.42</td><td>0.63</td><td></td></tr><tr><td>27</td><td>0.77</td><td>1</td><td>6/9=0.67</td><td>6/12=0.5</td><td rowspan="2">0.67</td><td></td></tr><tr><td>2</td><td>0.76</td><td>0</td><td>6/10=0.6</td><td>6/12=0.5</td><td></td><td></td></tr><tr><td>10</td><td>0.66</td><td>1</td><td>7/11=0.64</td><td>7/12=0.58</td><td rowspan="5">0.64</td><td></td></tr><tr><td>17</td><td>0.66</td><td>0</td><td>7/12=0.58</td><td>7/12=0.58</td><td></td><td></td></tr><tr><td>3</td><td>0.56</td><td>0</td><td>7/13=0.54</td><td>7/12=0.58</td><td></td><td></td></tr><tr><td>11</td><td>0.56</td><td>0</td><td>7/14=0.5</td><td>7/12=0.58</td><td></td><td></td></tr><tr><td>18</td><td>0.54</td><td>0</td><td>7/15=0.47</td><td>7/12=0.58</td><td></td><td></td></tr><tr><td>12</td><td>0.45</td><td>1</td><td>8/16=0.5</td><td>8/12=0.67</td><td>0.5</td><td></td></tr><tr><td>19</td><td>0.43</td><td>1</td><td>9/17=0.53</td><td>9/12=0.75</td><td>0.53</td><td></td></tr><tr><td>29</td><td>0.43</td><td>1</td><td>10/18=0.56</td><td>10/12=0.83</td><td rowspan="9">0.56</td><td></td></tr><tr><td>28</td><td>0.37</td><td>0</td><td>10/19=0.53</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>9</td><td>0.35</td><td>0</td><td>10/20=0.5</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>8</td><td>0.34</td><td>0</td><td>10/21=0.48</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>20</td><td>0.31</td><td>0</td><td>10/22=0.45</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>7</td><td>0.23</td><td>0</td><td>10/23=0.43</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>21</td><td>0.22</td><td>0</td><td>10/24=0.42</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>25</td><td>0.15</td><td>0</td><td>10/25=0.4</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>22</td><td>0.12</td><td>0</td><td>10/26=0.38</td><td>10/12=0.83</td><td></td><td></td></tr><tr><td>5</td><td>0.1</td><td>1</td><td>11/27=0.41</td><td>11/12=0.92</td><td>0.41</td><td></td></tr><tr><td>24</td><td>0.05</td><td>1</td><td>12/28=0.43</td><td>12/12=1</td><td rowspan="3">0.43</td><td></td></tr><tr><td>23</td><td>0.02</td><td>0</td><td>12/29=0.41</td><td>12/12=1</td><td></td><td></td></tr><tr><td>26</td><td>0.01</td><td>0</td><td>12/30=0.4</td><td>12/12=1</td><td></td><td></td></tr></table><p>mAP是所有类别下的AP求算数平均值的结果。</p><h3 id="r-cnn原理">8.3.4 R-CNN原理</h3><strong>训练阶段</strong> 整个过程分4步：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgfh5oqq50153t9n15a4fr1t.png" width="500"></center><ul><li>候选框生成阶段 利用Selective Search生成2000个候选框（BB），之前很多年人们用的都是滑动窗口方式。需要注意的是，由于候选框图片大小不一，而后续用于提特征的CNN对输入要求是固定大小的(227×227)，所以需要做预处理，文中实验效果最好的方法是：不论长宽比例直接将图片缩放到227×227大小，并做padding=16的处理以保留上下文信息。</li><li>特征提取阶段 利用CNN提取图片特征，文中大部分实验结果采用AlexNet网络结构，小部分采用VGG16，前者训练速度快但精度相对低，后者反之，AlexNet结构如下。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1baou2biq9uhumh1tm1d95du99.png" width="600"></center><ul><li>有监督预训练 使用ImageNet ILSVRC2012分类任务的1000类训练数据训练一个AlexNet模型，由于CNN主要作用体现在特征提取中，同样是猫狗，在不同数据集上特征是一样的，所以可以在不同问题间共享特征，区别无非在最终任务目标和特征如何组合上；</li><li>基于领域知识的fine-tuning 以上述模型做权重初始化，将softmax层1000类输出改为随机初始化权重的N+1类输出（1为背景类，对VOC，N=20），在目标训练集上继续训练，其中正样本为：与ground truth框IoU≥0.5的样本，其余的为负样本。训练时优化器采用学习率为0.001的SGD，样本采用mini-batch方式学习，大小为128，其中每个batch由采用均匀分布随机抽取的针对所有分类的32个正样本和96个负样本（背景）组成。</li></ul></li><li>训练分类器阶段 每一类做一个线性SVM分类器（为配合候选框特征向量的维度，每个SVM分类器为4096个权重），正样本为：每一类的ground truth，负样本为：与ground truth的IoU≤0.3的候选框（0.3这个阈值是通过在{0，0.1，0.2，0.3，0.4，0.5}集合上做grid search后观察验证集效果得到的）。 例如，对于VOC：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgpup10fl1g1he71goo1o9617jem.png" width="500"></center></li><li>训练回归器阶段 主要目的是修正BB减少定位错误，借鉴DPM的方法，使用ridge regression修正BB位置，具体方法为： 假设输入为：候选框与ground truth框对集合，用<span class="math inline">\(\{(P^i,G^i)\}_{i=1,...,N}\)</span>，其中<span class="math inline">\(P_i=(P_x^i,P_y^i,P_w^i,P_h^i)\)</span>，括号中分别为候选框中心点的坐标及候选框宽与高，选取靠近（IoU≥0.6）ground truth的候选框，目标是学习一个映射使得候选框能被修正到ground truth框。利用SIT（scale-invariant translation）和LST（log-space translation）思想去学习这个变换（这里大家可以想想为什么？）： <span class="math display">\[ \begin{array}{l} \hat{G_x}=P_w\cdot d_x(P)+P_x\\ \hat{G_y}=P_h\cdot d_y(P)+P_y \\ \hat{G_w}=P_w\cdot e^{d_w(P)}\\ \hat{G_h}=P_h\cdot e^{d_h(P)} \end{array} \]</span> 变换函数<span class="math inline">\(d_*(P)\)</span>与AlexNet最后一个pooling层（4096个特征）的输出<span class="math inline">\(\phi_5(P)\)</span>关系为: <span class="math display">\[d_*(P)=w^T_*\phi_5(P)\]</span> 优化目标函数为： <span class="math display">\[w_*=argmin_{\hat{w_*}}\sum_i^N(t_*^i-\hat{w}_*^T\phi_5(P^i))^2+\lambda||\hat{w_*}||^2\]</span> 其中： <span class="math display">\[ \begin{array}{l} t_x=(G_x-P_x)/P_w\\ t_y=(G_y-P_y)/P_h \\ t_w=log(G_w/P_w)\\ t_h=log(G_h/P_h) \end{array} \]</span></li></ul><p>以上四个步骤是相互独立的，后验（马后炮）的来看，可以做这些改进：</p><p>1、把分类和回归放在一个网络做共享特征；</p><p>2、网络结构对输入图片大小自适应；</p><p>3、把候选框生成算法也放在同一个网络来做共享特征；</p><p>4、分类器抛弃SVM直接融合在神经网络中；</p><p>5、不用每个候选框都做一次特征提取。</p><p><strong>测试阶段</strong>过程如下：</p><ul><li>使用SS提取2000个候选框</li><li>将候选框大小缩放到227×227</li><li>每个候选框输入CNN，产生特征后对每一类做SVM分类输出置信度</li><li>对候选框做基于贪心的NMS</li><li>每个候选框的BB只做一次预测</li></ul><h3 id="代码实践-2">8.3.5 代码实践</h3><p>作者代码能力极强，具体可见：<a target="_blank" rel="noopener" href="https://github.com/rbgirshick/rcnn">R-CNN: Region-based Convolutional Neural Networks</a>。</p><h2 id="spp-net">8.4 SPP-Net</h2><p>SPP-Net是何凯明等人在《<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1406.4729">Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a>》一文中提出，文章亮点是主要解决了两个问题：</p><p>1、允许CNN网络的输入图片大小不固定（后面的FCN也可以解决这个问题）；</p><p>2、借鉴OverFeat只对整张图做一次特征提取，一些操作只在feature map上做而不用在原图进行且feature map上的点可以还原到原图上。</p><h3 id="问题回顾">8.4.1 问题回顾</h3>之前的CNN网络的输入都是固定大小的，好处是网络结构相对简单和计算量低，坏处是所有图片都需要做预处理，这个会损失原图信息或引入噪声。训练和预测的一般流程是：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgsbrok31sh917c5ju5jvrn1qm.png" width="600"></center>常用的缩放方式有裁剪和缩放，例如：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgs6vv3j1uqh179e1aalshh1r0h9.png" width="600"></center>分析CNN网络结构可以发现，卷积层和pooling层对图片输入大小都没有要求，唯独全连接层需要其输入是固定大小的，所以改进主要针对全连接层的输入，另外通过特征可视化观察到feature map包含了图片的空间信息，所以新方法同样需要包含空间信息，于是文中提出了通过增加SPP层解决问题，新的算法流程变为：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgscko9j1q99uf5fkaq31ifv13.png" width="600"></center><h3 id="spp详解">8.4.2 SPP详解</h3>可以把这个问题看做如何找到输入可变，输出固定且能保留空间信息的映射问题，问题三个相关变量：feature map的大小、bin的个数（借鉴BoW《<a target="_blank" rel="noopener" href="http://www.robots.ox.ac.uk/~vgg/publications/papers/sivic03.pdf">Video Google: A Text Retrieval Approach to Object Matching in Videos</a>》的思想，表示固定特征的维度数）、pooling步长。现在feature map的大小不固定但bin的个数固定，于是唯一能自适应可变的就是pooling步长了。 假设：最后一个卷积层产生的feature map大小为<span class="math inline">\(a×a\)</span>，希望产生<span class="math inline">\(n×n\)</span>个bins，则窗口大小为<span class="math inline">\(\lceil\frac{a}{n}\rceil\)</span>，步长为<span class="math inline">\(\lfloor\frac{a}{n}\rfloor\)</span>，例如：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgsg5gtkprvdbthhf4793bd1g.png" width="500"></center><p>每个bin的pooling方式可以是max pooling或其他pooling。</p>SPP同样支持多尺度特征，例如4×4、2×2、1×1三种尺度最后拼成21×256维特征向量：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgsg8da2e9abus1i219c61ulb1t.png" width="500"></center><h3 id="感受野receptive-field">8.4.3 感受野(Receptive Field)</h3>感受野来源于生物学，Levine and Shefner在《<a target="_blank" rel="noopener" href="https://www.amazon.co.uk/d/Books/Fundamentals-Sensation-Perception-Michael-Levine/0198524668">Fundamentals of sensation and perception</a>》中将感受野定义为：由于受到刺激导致特定神经元发生反应的区域。比如人在观察某个物体的某个部分时由于受到刺激，物体会投影到视网膜，之后传到给大脑并激活某个区域（橘色的框框住的区域）。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgunun1usbfjgt1p0o1rhq1fgq9.png" width="500"></center>CNN的任何一个卷积层或pooling层产生的任何一个feature map上的任何一点都会对应到原始图像上的某个区域，那个区域就是该点的感受野。例如，红、绿、橙三个点的感受野不同：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bgur286f1vmo1f71uau8jh1tp8m.png" width="500"></center><p>感受野的大小与以下两个因素有关但<strong>与是否padding无关</strong>： 1、filter的大小； 2、stride的大小。</p><h3 id="feature-map与原图对应关系转换">8.4.4 feature map与原图对应关系转换</h3><p>由于SPP只对原图做一次特征提取，省去了大量重复劳动，另外由于特征点的可还原性，使得后续对所有对候选框做SPP特征映射操作时只需要在最后一个卷积层产生的feature map上进行即可（否则需要考虑感受野上的所有特征映射将会产生巨大的计算量）。 详情可参考《<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1506.06981.pdf">R-CNN minus R</a>》. 简单的转换方法为： 需要对CNN网络的<strong>所有卷积层和pooling层</strong>做padding，使得原图中的任何一点与卷积或pooling后的图上的点一一对应（边缘信息也没有丢失）。</p><p>假设：</p><p>1、任何一层的核大小为<span class="math inline">\(p\)</span>；</p><p>2、每层padding值为<span class="math inline">\(\lfloor\frac{p}{2}\rfloor\)</span>；</p><p>3、原图中任何一点坐标为<span class="math inline">\((x,y)\)</span>，该点在任何一个feature map上的位置为<span class="math inline">\((x,^{&#39;},y^{&#39;})\)</span>；</p><p>4、从原图到该feature map感受野范围内的所有stride乘积为<span class="math inline">\(S\)</span>。</p><p>则： 原图候选框<strong>左上点</strong>的坐标与其在任意feature map上的坐标关系为： <span class="math display">\[ \begin{array}{l} x^{&#39;}=\lfloor\frac{x}{S}\rfloor+1\\ y^{&#39;}=\lfloor\frac{y}{S}\rfloor+1 \end{array} \]</span> 原图候选框<strong>右下点</strong>的坐标与其在任意feature map上的坐标关系为： <span class="math display">\[ \begin{array}{l} x^{&#39;}=\lceil\frac{x}{S}\rceil-1\\ y^{&#39;}=\lceil\frac{y}{S}\rceil-1 \end{array} \]</span></p><p><strong>通用</strong>的转换方法为： <span class="math display">\[ \begin{array}{l} i_0=\alpha_L(i_L-1)+\beta_L\\ \alpha_L=\prod_{p=1}^L S_p\\ \beta_L=1+\sum_{p=1}^L(\prod_{q=1}^{p-1}S_q)(\frac{F_p-1}{2}-P_p) \end{array} \]</span> 其中： <span class="math inline">\(i_0\)</span>是feature map上的特征点<span class="math inline">\(i_L\)</span>在<strong>感受野的中心位置</strong>坐标； <span class="math inline">\(L\)</span>是当前特征点处于由CNN的第几层产生的feature map中； <span class="math inline">\(S_p\)</span>第<span class="math inline">\(p\)</span>层的stride大小； <span class="math inline">\(F_p\)</span>第<span class="math inline">\(p\)</span>层的filter大小； <span class="math inline">\(P_p\)</span>第<span class="math inline">\(p\)</span>层的padding大小。 反过来可以知道原图任何一个候选框在任何一个feature map上的位置。</p><p>感受野大小的计算采用Top to Down的方式，从当前层往靠近输入层的方式逐层传递，具体方法为： 假设：待计算感受野的特征点所在feature map所处层为<span class="math inline">\(L\)</span>，<span class="math inline">\(r_0\)</span>为特征点在原图的感受野大小。 则： <span class="math display">\[ \begin{array}{l} r_L=1;\\ for \quad t=L;t&lt;=1;t--\\ \quad \quad \quad r_{t-1}=(r_{t}-1)*S_{t}+F_{t};\\ return \quad r_0; \end{array} \]</span></p><p>以下面两幅图为例：</p><ul><li>图一 无padding。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bh4i570957619rpopqks14r4p.png" width="600"></center><p>绿色点为第2层feature map上坐标为(1,1)的点，则它在原图的中心点为： <span class="math display">\[ \begin{array}{l} \alpha_2=1*2=2\\ \beta_2=1+(2-1)/2+1*(3-1)/2=2.5\\ i_0=2*(i_2-1)+2.5 \end{array} \]</span> 中心点坐标为图中<strong>红点</strong>：(2.5,2.5) 感受野大小为4： <span class="math display">\[ \begin{array}{l} r_2=1\\ r_1=(r_2-1)*2+3=3\\ r_0=(r_1-1)*1+2=4 \end{array} \]</span></p></li><li>图二 第一层有padding。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bh4kt6mh1vhbm2b1e161oob2eh16.png" width="600"></center><p>绿色点为第2层feature map上坐标为(1,1)的点，则它在原图的中心点为： <span class="math display">\[ \begin{array}{l} \alpha_2=1*3=3\\ \beta_2=1+(2-1)/2+1*((3-1)/2-1)=1.5\\ i_0=3*(i_2-1)+1.5 \end{array} \]</span> 中心点坐标为图中<strong>红点</strong>：(1.5,1.5) 感受野大小为4： <span class="math display">\[ \begin{array}{l} r_2=1\\ r_1=(r_2-1)*3+3=3\\ r_0=(r_1-1)*1+2=4 \end{array} \]</span></p></li></ul><h3 id="代码实践-3">8.4.5 代码实践</h3><ul><li>receptivefield.py<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一层表示为一个三元组： [filter size, stride, padding]</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forword</span>(<span class="params">conv, layerIn</span>):</span></span><br><span class="line">  n_in = layerIn</span><br><span class="line">  k = conv[<span class="number">0</span>]</span><br><span class="line">  s = conv[<span class="number">1</span>]</span><br><span class="line">  p = conv[<span class="number">2</span>]</span><br><span class="line">  <span class="keyword">return</span> math.floor((n_in - k + <span class="number">2</span>*p)/s) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alexnet</span>():</span></span><br><span class="line">  convnet = [[],[<span class="number">11</span>,<span class="number">4</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">  layer_names = [[<span class="string">&#x27;input&#x27;</span>],<span class="string">&#x27;conv1&#x27;</span>,<span class="string">&#x27;pool1&#x27;</span>,<span class="string">&#x27;conv2&#x27;</span>,<span class="string">&#x27;pool2&#x27;</span>,<span class="string">&#x27;conv3&#x27;</span>,<span class="string">&#x27;conv4&#x27;</span>,<span class="string">&#x27;conv5&#x27;</span>,<span class="string">&#x27;pool5&#x27;</span>,<span class="string">&#x27;fc6-conv&#x27;</span>, <span class="string">&#x27;fc7-conv&#x27;</span>]</span><br><span class="line">  <span class="keyword">return</span> [convnet, layer_names]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testnet</span>():</span></span><br><span class="line">  convnet = [[],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">  layer_names = [[<span class="string">&#x27;input&#x27;</span>],<span class="string">&#x27;conv1&#x27;</span>,<span class="string">&#x27;conv2&#x27;</span>]</span><br><span class="line">  <span class="keyword">return</span> [convnet, layer_names]</span><br><span class="line"></span><br><span class="line"><span class="comment"># layerid &gt;= 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receptivefield</span>(<span class="params">net, layerid</span>):</span></span><br><span class="line">  <span class="keyword">if</span> layerid &gt; <span class="built_in">len</span>(net[<span class="number">0</span>]):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[error] receptivefield:no such layerid!&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  rf = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(layerid)):</span><br><span class="line">    filtersize, stride, padding = net[<span class="number">0</span>][i+<span class="number">1</span>]</span><br><span class="line">    rf = (rf - <span class="number">1</span>)*stride + filtersize</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;                感受野大小为:%d.&#x27;</span> % (<span class="built_in">int</span>(rf))</span><br><span class="line">  <span class="keyword">return</span> rf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anylayerout</span>(<span class="params">net, layerin, layerid</span>):</span></span><br><span class="line">  <span class="keyword">if</span> layerid &gt; <span class="built_in">len</span>(net[<span class="number">0</span>]):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[error] anylayerout:no such layerid!&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layerid):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">      fout = forword(net[<span class="number">0</span>][i+<span class="number">1</span>], layerin)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    fout = forword(net[<span class="number">0</span>][i+<span class="number">1</span>], fout)</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;当前层为:%s, 输出节点维度为:%d.&#x27;</span> % (net[<span class="number">1</span>][layerid], <span class="built_in">int</span>(fout))</span><br><span class="line"></span><br><span class="line"><span class="comment">#x,y&gt;=1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receptivefieldcenter</span>(<span class="params">net, layerid, x, y</span>):</span></span><br><span class="line">  <span class="keyword">if</span> layerid &gt; <span class="built_in">len</span>(net[<span class="number">0</span>]):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[error] receptivefieldcenter:no such layerid!&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  al = <span class="number">1</span></span><br><span class="line">  bl = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layerid):</span><br><span class="line">    filtersize, stride, padding = net[<span class="number">0</span>][i+<span class="number">1</span>]</span><br><span class="line">    al = al * stride</span><br><span class="line">    ss = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">      fsize, std, pad = net[<span class="number">0</span>][j+<span class="number">1</span>]</span><br><span class="line">      ss = ss * std</span><br><span class="line"></span><br><span class="line">    bl = bl + ss * (<span class="built_in">float</span>(filtersize-<span class="number">1</span>)/<span class="number">2</span> - padding)</span><br><span class="line"></span><br><span class="line">  xi0 = al * (x - <span class="number">1</span>) + <span class="built_in">float</span>(bl)</span><br><span class="line">  yi0 = al * (y - <span class="number">1</span>) + bl</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;                该层上的特征点(%d,%d)在原图的感受野中心坐标为:(%.1f,%.1f).&#x27;</span> % (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y), <span class="built_in">float</span>(xi0), <span class="built_in">float</span>(yi0))</span><br><span class="line">  <span class="keyword">return</span> (xi0, yi0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># net:为某个CNN网络</span></span><br><span class="line"><span class="comment"># insize:为输入层大小</span></span><br><span class="line"><span class="comment"># totallayers：为除了输入层外的所有层个数</span></span><br><span class="line"><span class="comment"># x,y为某层特征点坐标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printlayer</span>(<span class="params">net, insize, totallayers, x, y</span>):</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(totallayers):</span><br><span class="line">    <span class="comment"># 计算每一层的输出大小</span></span><br><span class="line">    anylayerout(net, insize, i+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 计算每层的感受野大小</span></span><br><span class="line">    receptivefield(net, i+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 计算feature map上(x,y)点在原图感受野的中心位置坐标</span></span><br><span class="line">    receptivefieldcenter(net, i+<span class="number">1</span>, x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  <span class="comment">#net = testnet()</span></span><br><span class="line">  <span class="comment">#printlayer(net, insize=6, totallayers=2, x=1, y=1)</span></span><br><span class="line">  net = alexnet()</span><br><span class="line">  printlayer(net, insize=<span class="number">227</span>, totallayers=<span class="number">8</span>, x=<span class="number">2</span>, y=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li>输出<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bhehjb06nst2511lbr19d64jt39.png" width="600"></center></li></ul><h2 id="fast-r-cnn">8.5 Fast R-CNN</h2><p>《<a target="_blank" rel="noopener" href="http://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Girshick_Fast_R-CNN_ICCV_2015_paper.pdf">Fast R-CNN</a>》的出现解决了R-CNN+SPP中的以下问题：</p><ul><li>把分类和回归放在一个网络做共享特征，提取的特征向量不用落地</li><li>借鉴SPP，网络结构对输入图片大小自适应</li><li>抛弃SVM分类器，利用softmax直接融合在神经网络中</li><li>借鉴SPP，只做一次全图的特征提取，不用每个候选框都做</li></ul><h3 id="算法概述">8.5.1 算法概述</h3>算法基本步骤为：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bhes1rl71nh81e9ljv41nnbpr23m.png" width="500"></center><ul><li>候选框生成阶段 方法同R-CNN。</li><li>特征提取阶段 注意整个网络的输入为两部分：整个图和候选框信息。特征提取会对整张图进行，利用输入的候选框坐标及大小信息可以方便低成本的在任何一个feature map上找到任何一个原图点的特征映射点(方法回看SPP-net)，大大提高了特征提取效率。</li><li>RoI pooling阶段 借鉴SPP的思想，对每个候选框生成一个自适应候选框大小的固定长度的ROI（region of interest）特征向量，除此之外，大家还可以想想RoI Pooling的更深层次作用。</li><li>多任务学习阶段 把得到的RoI特征向量用全连接层做组合后分别送入两个分支：一个做分类，一个做Bounding Box回归，并为此设计一个多任务损失函数。</li></ul>直观对比R-CNN与Fast R-CNN的<a target="_blank" rel="noopener" href="http://kaiminghe.com/iccv15tutorial/iccv2015_tutorial_convolutional_feature_maps_kaiminghe.pdf">forward pipeline</a>：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bhet2nk1per1nd3c3tg5f1u7m43.png" width="600"></center><h3 id="训练阶段">8.5.2 训练阶段</h3><ul><li><p>RoI pooling层生成说明</p><p>RoI pooling是SPP的特殊形式（金字塔层数为1，pooling采用max pooling），具体原理类比SPP即可，feature map通过该层后会产生<span class="math inline">\(H × W\)</span>大小（例如7 × 7）的特征向量，例如： 某个RoI坐标表示为四元组<span class="math inline">\((r,c,h,w)\)</span>，其中<span class="math inline">\(r,c\)</span>为RoI最左上角坐标，<span class="math inline">\(h,w\)</span>为其高与宽，则RoI pooling会划分<span class="math inline">\(H × W\)</span>个大小<span class="math inline">\(为\frac{h}{H} × \frac{w}{W}\)</span>的小网格，之后对每个小网格做max pooling即可。</p></li><li><p>RoI pooling层反向传播</p>RoI pooling的反向传播比较简单，输入feature map上的任意特征元素的梯度信息为：所有由它产生的roi pooling feature map的特征元素所带梯度信息的累加和。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bivqa5cb1hbeksa7gbdm123o1g.png" width="500"></center><p>假设：</p><p>1、<span class="math inline">\(x_i \in R\)</span>是 RoI pooling层输入feature map的第<span class="math inline">\(i\)</span>个特征元素；</p><p>2、<span class="math inline">\(y_{rj}\)</span>是第<span class="math inline">\(r\)</span>个RoI的roi pooling后得到feature map的第<span class="math inline">\(j\)</span>个特征元素；</p><p>3、<span class="math inline">\(R(r,j)\)</span>是第<span class="math inline">\(r\)</span>个RoI通过roi pooling得到的feature map上的第<span class="math inline">\(j\)</span>个输出特征元素对应原feature map上的子图；</p><p><span class="math inline">\(i^*_{r,j}=argmax_{i^{\text{&#39;}} \in R(r,j)}x_i^\text{&#39;}\)</span>为在上述子图中做max pooling后得到的原feature map元素索引号。</p><p>则反向传播得到的原feature map元素的梯度为： <span class="math display">\[ \frac{\partial L}{\partial x_i}=\sum_r \sum_j[i=i^*_{r,j}]\frac{\partial L}{\partial y_{rj}} \]</span> <span class="math inline">\([x]\)</span>函数表示：如果<span class="math inline">\(x\)</span>为真则返回1，否则返回0。</p></li><li><p>多任务损失函数</p><p>使用smooth L1函数并融合分类和bounding box回归损失，损失函数如下： <span class="math display">\[ L(p,u,t^u,v)=L_{cls}(p,u)+\lambda \cdot [u \geq 1]L_{loc}(t^u,v) \]</span> 其中: <span class="math display">\[L_{cls}(p,u)=-log \text{ }p_u\]</span> <span class="math display">\[L_{loc}(t^u,v)=\sum_{i \in \{x,y,w,h\}}smooth_{L_1}(t_i^u-v_i)\]</span></p><span class="math display">\[ smooth_{L_1}(x)= \begin{cases} 0.5x^2&amp; \text{if |x|&lt;1}\\ |x|-0.5&amp; \text{otherwise} \end{cases} \]</span> smooth L1函数对异常点不敏感（在|x|值较大时使用线性分段函数而不是二次函数），如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bivr14vrusab6vouf12a9la11t.png" width="400"></center></li></ul><h3 id="代码实践-4">8.5.3 代码实践</h3><p>fast r-cnn完整代码请参考<a target="_blank" rel="noopener" href="https://github.com/rbgirshick/fast-rcnn">rbgirshick/fast-rcnn</a>。</p><ul><li>RoI Pooling层实现解析<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Fast R-CNN</span></span><br><span class="line"><span class="comment">// Copyright (c) 2015 Microsoft</span></span><br><span class="line"><span class="comment">// Licensed under The MIT License [see fast-rcnn/LICENSE for details]</span></span><br><span class="line"><span class="comment">// Written by Ross Girshick</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;caffe/fast_rcnn_layers.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> caffe &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下参数解释以VGG16为例，即进入roi pooling前的网络结构采用经典VGG16.</span></span><br><span class="line"><span class="comment">// 在Layer类中输入数据用bottom表示, 输出数据用top表示</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">ROIPoolForward</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> nthreads,			<span class="comment">// 任务数，对应通过roi pooling后的输出feature map的神经元节点总数，</span></span></span></span><br><span class="line"><span class="params"><span class="function">	                            <span class="comment">// 具体为：RoI的个数(m) × channel个数(VGG16的conv5_3的输出为512个) × roi pooling输出宽(配置为7) × roi pooling输出高(配置为7) = 25088×m个</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> Dtype* bottom_data,	<span class="comment">// 输入的feature map，原图经过各种卷积、pooling等前向传播后得到（VGG16的conv5_3卷积产生的feature map，大小为：512×14×14）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Dtype spatial_scale,	<span class="comment">// 由之前所有卷积层的strides相乘得到，在fast rcnn中为1/16，注：从原图往conv5_3的feature map上映射为缩小过程，所以乘以1/16，反之需要乘以16</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> channels,			<span class="comment">// 输入层（VGG16为卷积层conv5_3）feature map的channel个数(512)</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> height,			<span class="comment">// 输入层（VGG16为卷积层conv5_3）feature map的高(14)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> width,			<span class="comment">// 输入层（VGG16为卷积层conv5_3）feature map的宽(14)</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> pooled_height,	<span class="comment">// roi pooling输出feature map的高，fast rcnn中配置为h=7</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> pooled_width,		<span class="comment">// roi pooling输出feature map的宽，fast rcnn中配置为w=7</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Dtype* bottom_rois,	<span class="comment">// 输入的roi信息，存储所有rois或一个batch的rois，数据结构为[batch_ind,x1,y1,x2,y2]，包含roi的：索引、左上角坐标及右下角坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Dtype* top_data,			<span class="comment">// 存储roi pooling后得到的feature map</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>* argmax_data)</span> </span>&#123;         <span class="comment">// 为每个roi pooling后的feature map元素存储max pooling后对应conv5_3 feature map元素的索引信息，长度等于nthreads</span></span><br><span class="line">    <span class="comment">// index为线程索引，个数为roi pooling后的feature map上所有值的个数，索引范围为：[0,nthreads-1]</span></span><br><span class="line">	CUDA_KERNEL_LOOP(index, nthreads) &#123;</span><br><span class="line">    <span class="comment">// 该线程对应的top blob（N,C,H,W）中的W,输出roi pooling后feature map的中的宽的坐标，即feature map的第i=[0,k-1]列</span></span><br><span class="line">    <span class="keyword">int</span> pw = index % pooled_width;</span><br><span class="line">    <span class="comment">// 该线程对应的top blob（N,C,H,W）中的H,输出roi pooling后feature map的中的高的坐标，即feature map的第j=[0,k-1]行</span></span><br><span class="line">    <span class="keyword">int</span> ph = (index / pooled_width) % pooled_height;</span><br><span class="line">    <span class="comment">// 该线程对应的top blob（N,C,H,W）中的C,即第c个channel，channel数最大值为输入feature map的channel数（VGG16中为512）.</span></span><br><span class="line">    <span class="keyword">int</span> c = (index / pooled_width / pooled_height) % channels;</span><br><span class="line">    <span class="comment">// 该线程对应的是第几个RoI,一共m个.</span></span><br><span class="line">    <span class="keyword">int</span> n = index / pooled_width / pooled_height / channels;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [start, end)，指定RoI信息的存储范围，指针每次移动5的倍数是因为包含信息的数据结构大小为5，包含信息为：[batch_ind,x1,y1,x2,y2]，含义同上</span></span><br><span class="line">    bottom_rois += n * <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 将每个原图的RoI区域映射到feature map(VGG16为conv5_3产生的feature mao)上的坐标,bottom_rois第0个位置存放的是roi索引.</span></span><br><span class="line">    <span class="keyword">int</span> roi_batch_ind = bottom_rois[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 原图到feature map的映射为乘以1/16，这里采用粗映射而不是上文讲的精确映射，原因你懂的.</span></span><br><span class="line">    <span class="keyword">int</span> roi_start_w = round(bottom_rois[<span class="number">1</span>] * spatial_scale);</span><br><span class="line">    <span class="keyword">int</span> roi_start_h = round(bottom_rois[<span class="number">2</span>] * spatial_scale);</span><br><span class="line">    <span class="keyword">int</span> roi_end_w = round(bottom_rois[<span class="number">3</span>] * spatial_scale);</span><br><span class="line">    <span class="keyword">int</span> roi_end_h = round(bottom_rois[<span class="number">4</span>] * spatial_scale);</span><br><span class="line">    <span class="comment">// 强制把RoI的宽和高限制在1x1，防止出现映射后的RoI大小为0的情况</span></span><br><span class="line">    <span class="keyword">int</span> roi_width = max(roi_end_w - roi_start_w + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> roi_height = max(roi_end_h - roi_start_h + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据原图映射得到的roi的高和配置的roi pooling的高(这里大小配置为7)自适应计算bin桶的高度</span></span><br><span class="line">    Dtype bin_size_h = <span class="keyword">static_cast</span>&lt;Dtype&gt;(roi_height)</span><br><span class="line">                       / <span class="keyword">static_cast</span>&lt;Dtype&gt;(pooled_height);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据原图映射得到的roi的宽和配置的roi pooling的宽(这里大小配置为7)自适应计算bin桶的宽度</span></span><br><span class="line">    Dtype bin_size_w = <span class="keyword">static_cast</span>&lt;Dtype&gt;(roi_width)</span><br><span class="line">                       / <span class="keyword">static_cast</span>&lt;Dtype&gt;(pooled_width);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算第(i,j)个bin桶在feature map上的坐标范围，需要依据它们确定后续max pooling的范围</span></span><br><span class="line">    <span class="keyword">int</span> hstart = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">floor</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(ph)</span><br><span class="line">                                        * bin_size_h));</span><br><span class="line">    <span class="keyword">int</span> wstart = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">floor</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(pw)</span><br><span class="line">                                        * bin_size_w));</span><br><span class="line">    <span class="keyword">int</span> hend = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">ceil</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(ph + <span class="number">1</span>)</span><br><span class="line">                                     * bin_size_h));</span><br><span class="line">    <span class="keyword">int</span> wend = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">ceil</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(pw + <span class="number">1</span>)</span><br><span class="line">                                     * bin_size_w));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确定max pooling具体范围，注意由于RoI取自原图，其左上角不是从(0,0)开始，</span></span><br><span class="line">	<span class="comment">// 所以需要加上 roi_start_h 或 roi_start_w作为偏移量，并且超出feature map尺寸范围的部分会被舍弃</span></span><br><span class="line">    hstart = min(max(hstart + roi_start_h, <span class="number">0</span>), height);</span><br><span class="line">    hend = min(max(hend + roi_start_h, <span class="number">0</span>), height);</span><br><span class="line">    wstart = min(max(wstart + roi_start_w, <span class="number">0</span>), width);</span><br><span class="line">    wend = min(max(wend + roi_start_w, <span class="number">0</span>), width);</span><br><span class="line">    <span class="keyword">bool</span> is_empty = (hend &lt;= hstart) || (wend &lt;= wstart);</span><br><span class="line">    <span class="comment">// 如果区域为0返回错误代码</span></span><br><span class="line">    Dtype maxval = is_empty ? <span class="number">0</span> : -FLT_MAX;</span><br><span class="line">    <span class="comment">// If nothing is pooled, argmax = -1 causes nothing to be backprop&#x27;d</span></span><br><span class="line">    <span class="keyword">int</span> maxidx = <span class="number">-1</span>;</span><br><span class="line">    bottom_data += (roi_batch_ind * channels + c) * height * width;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在给定bin桶的区域中做max pooling</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = hstart; h &lt; hend; ++h) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> w = wstart; w &lt; wend; ++w) &#123;</span><br><span class="line">        <span class="keyword">int</span> bottom_index = h * width + w;</span><br><span class="line">        <span class="keyword">if</span> (bottom_data[bottom_index] &gt; maxval) &#123;</span><br><span class="line">          maxval = bottom_data[bottom_index];</span><br><span class="line">          maxidx = bottom_index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为某个roi pooling的feature map元素记录其由对conv5_3(VGG16)的feature map做max pooling后产生元素的索引号及值</span></span><br><span class="line">    top_data[index] = maxval;</span><br><span class="line">    argmax_data[index] = maxidx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="keyword">void</span> ROIPoolingLayer&lt;Dtype&gt;::Forward_gpu(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,	<span class="comment">// 以VGG16为例，bottom[0]为最后一个卷积层conv5_3产生的feature map，shape[1, 512, 14, 14],</span></span><br><span class="line">	                                    <span class="comment">//              bottom[1]为rois数据，shape[roi个数m, 5]</span></span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;	<span class="comment">// top为输出层结构， top-&gt;count() = top.n（RoI的个数) × top.channel(channel数)</span></span><br><span class="line">		                                <span class="comment">//                               × top.w(输出feature map的宽) × top.h(输出feature map的高)</span></span><br><span class="line">  <span class="keyword">const</span> Dtype* bottom_data = bottom[<span class="number">0</span>]-&gt;gpu_data();</span><br><span class="line">  <span class="keyword">const</span> Dtype* bottom_rois = bottom[<span class="number">1</span>]-&gt;gpu_data();</span><br><span class="line">  Dtype* top_data = top[<span class="number">0</span>]-&gt;mutable_gpu_data();</span><br><span class="line">  <span class="keyword">int</span>* argmax_data = max_idx_.mutable_gpu_data();</span><br><span class="line">  <span class="keyword">int</span> count = top[<span class="number">0</span>]-&gt;count();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   参照caffe-fast-rcnn/src/caffe/layers/roi_pooling_layer.cpp中的代码：</span></span><br><span class="line"><span class="comment">   template &lt;typename Dtype&gt;</span></span><br><span class="line"><span class="comment">   void ROIPoolingLayer&lt;Dtype&gt;::Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span></span><br><span class="line"><span class="comment">      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;</span></span><br><span class="line"><span class="comment">     channels_ = bottom[0]-&gt;channels();</span></span><br><span class="line"><span class="comment">     height_ = bottom[0]-&gt;height();</span></span><br><span class="line"><span class="comment">     width_ = bottom[0]-&gt;width();</span></span><br><span class="line"><span class="comment">     top[0]-&gt;Reshape(bottom[1]-&gt;num(), channels_, pooled_height_, pooled_width_);</span></span><br><span class="line"><span class="comment">     max_idx_.Reshape(bottom[1]-&gt;num(), channels_, pooled_height_, pooled_width_);</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  参照caffe-fast-rcnn/include/caffe/util/device_alternate.hpp中的代码：</span></span><br><span class="line"><span class="comment">  // CUDA_KERNEL_LOOP</span></span><br><span class="line"><span class="comment">  #define CUDA_KERNEL_LOOP(i, n) \</span></span><br><span class="line"><span class="comment">  for (int i = blockIdx.x * blockDim.x + threadIdx.x; \</span></span><br><span class="line"><span class="comment">       i &lt; (n); \</span></span><br><span class="line"><span class="comment">       i += blockDim.x * gridDim.x)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  // CAFFE_GET_BLOCKS</span></span><br><span class="line"><span class="comment">  // CUDA: number of blocks for threads.</span></span><br><span class="line"><span class="comment">  inline int CAFFE_GET_BLOCKS(const int N) &#123;</span></span><br><span class="line"><span class="comment">       return (N + CAFFE_CUDA_NUM_THREADS - 1) / CAFFE_CUDA_NUM_THREADS;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  // CAFFE_CUDA_NUM_THREADS</span></span><br><span class="line"><span class="comment">  // CUDA: thread number configuration.</span></span><br><span class="line"><span class="comment">  // Use 1024 threads per block, which requires cuda sm_2x or above,</span></span><br><span class="line"><span class="comment">  // or fall back to attempt compatibility (best of luck to you).</span></span><br><span class="line"><span class="comment">  #if __CUDA_ARCH__ &gt;= 200</span></span><br><span class="line"><span class="comment">      const int CAFFE_CUDA_NUM_THREADS = 1024;</span></span><br><span class="line"><span class="comment">  #else</span></span><br><span class="line"><span class="comment">      const int CAFFE_CUDA_NUM_THREADS = 512;</span></span><br><span class="line"><span class="comment">  #endif</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  ROIPoolForward&lt;Dtype&gt;&lt;&lt;&lt;CAFFE_GET_BLOCKS(count), CAFFE_CUDA_NUM_THREADS&gt;&gt;&gt;(</span><br><span class="line">      count, bottom_data, spatial_scale_, channels_, height_, width_,</span><br><span class="line">      pooled_height_, pooled_width_, bottom_rois, top_data, argmax_data);</span><br><span class="line">  CUDA_POST_KERNEL_CHECK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="comment">// 反向传播的过程与论文中&quot;Back-propagation through RoI pooling layers&quot;这一小节的公式完全一致</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">ROIPoolBackward</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> nthreads,			<span class="comment">// 输入feature map的元素数(VGG16为：512×14×14)</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> Dtype* top_diff,		<span class="comment">// roi pooling输出feature map所带的梯度信息∂L/∂y(r,j)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span>* argmax_data,		<span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> num_rois,			<span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> Dtype spatial_scale,  <span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> channels,			<span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> height,			<span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> width,			<span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> pooled_height,	<span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">int</span> pooled_width,		<span class="comment">// 同前向，不解释</span></span></span></span><br><span class="line"><span class="params"><span class="function">	Dtype* bottom_diff,			<span class="comment">// 保留输入feature map每个元素通过梯度反向传播得到的梯度信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Dtype* bottom_rois)</span> </span>&#123;	<span class="comment">// 同前向，不解释</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 含义同前向，需要注意的是这里表示的是输入feature map的元素数(反向传播嘛)</span></span><br><span class="line">  CUDA_KERNEL_LOOP(index, nthreads) &#123;</span><br><span class="line">    <span class="comment">// 同前向，不解释</span></span><br><span class="line">    <span class="keyword">int</span> w = index % width;</span><br><span class="line">    <span class="keyword">int</span> h = (index / width) % height;</span><br><span class="line">    <span class="keyword">int</span> c = (index / width / height) % channels;</span><br><span class="line">    <span class="keyword">int</span> n = index / width / height / channels;</span><br><span class="line">    Dtype gradient = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 同论文中公式，任何一个输入feature map的元素的梯度信息为：</span></span><br><span class="line">	<span class="comment">// 所有max pooling时被该元素落入且该元素值被选中(最大值)的</span></span><br><span class="line">	<span class="comment">// roi pooling feature map元素的梯度信息累加和</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有RoI，以判断是否满足上述条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> roi_n = <span class="number">0</span>; roi_n &lt; num_rois; ++roi_n) &#123;</span><br><span class="line">      <span class="keyword">const</span> Dtype* offset_bottom_rois = bottom_rois + roi_n * <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> roi_batch_ind = offset_bottom_rois[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 如果RoI的索引号不满足条件则跳过</span></span><br><span class="line">      <span class="keyword">if</span> (n != roi_batch_ind) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 找原图RoI在feature map上的映射位置，解释同前向传播</span></span><br><span class="line">      <span class="keyword">int</span> roi_start_w = round(offset_bottom_rois[<span class="number">1</span>] * spatial_scale);</span><br><span class="line">      <span class="keyword">int</span> roi_start_h = round(offset_bottom_rois[<span class="number">2</span>] * spatial_scale);</span><br><span class="line">      <span class="keyword">int</span> roi_end_w = round(offset_bottom_rois[<span class="number">3</span>] * spatial_scale);</span><br><span class="line">      <span class="keyword">int</span> roi_end_h = round(offset_bottom_rois[<span class="number">4</span>] * spatial_scale);</span><br><span class="line">      <span class="comment">// (h,w)不在RoI范围则跳过</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">bool</span> in_roi = (w &gt;= roi_start_w &amp;&amp; w &lt;= roi_end_w &amp;&amp;</span><br><span class="line">                           h &gt;= roi_start_h &amp;&amp; h &lt;= roi_end_h);</span><br><span class="line">      <span class="keyword">if</span> (!in_roi) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> offset = (roi_n * channels + c) * pooled_height * pooled_width;</span><br><span class="line">      <span class="keyword">const</span> Dtype* offset_top_diff = top_diff + offset;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>* offset_argmax_data = argmax_data + offset;</span><br><span class="line">      <span class="comment">// 同前向</span></span><br><span class="line">      <span class="keyword">int</span> roi_width = max(roi_end_w - roi_start_w + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> roi_height = max(roi_end_h - roi_start_h + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 同前向</span></span><br><span class="line">      Dtype bin_size_h = <span class="keyword">static_cast</span>&lt;Dtype&gt;(roi_height)</span><br><span class="line">                         / <span class="keyword">static_cast</span>&lt;Dtype&gt;(pooled_height);</span><br><span class="line">      Dtype bin_size_w = <span class="keyword">static_cast</span>&lt;Dtype&gt;(roi_width)</span><br><span class="line">                         / <span class="keyword">static_cast</span>&lt;Dtype&gt;(pooled_width);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 类比前向，看做一个逆过程</span></span><br><span class="line">      <span class="keyword">int</span> phstart = <span class="built_in">floor</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(h - roi_start_h) / bin_size_h);</span><br><span class="line">      <span class="keyword">int</span> phend = <span class="built_in">ceil</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(h - roi_start_h + <span class="number">1</span>) / bin_size_h);</span><br><span class="line">      <span class="keyword">int</span> pwstart = <span class="built_in">floor</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(w - roi_start_w) / bin_size_w);</span><br><span class="line">      <span class="keyword">int</span> pwend = <span class="built_in">ceil</span>(<span class="keyword">static_cast</span>&lt;Dtype&gt;(w - roi_start_w + <span class="number">1</span>) / bin_size_w);</span><br><span class="line">      phstart = min(max(phstart, <span class="number">0</span>), pooled_height);</span><br><span class="line">      phend = min(max(phend, <span class="number">0</span>), pooled_height);</span><br><span class="line">      pwstart = min(max(pwstart, <span class="number">0</span>), pooled_width);</span><br><span class="line">      pwend = min(max(pwend, <span class="number">0</span>), pooled_width);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 累积所有与当前输入feature map上的元素相关的roi pooling元素的梯度信息</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> ph = phstart; ph &lt; phend; ++ph) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pw = pwstart; pw &lt; pwend; ++pw) &#123;</span><br><span class="line">          <span class="keyword">if</span> (offset_argmax_data[ph * pooled_width + pw] == (h * width + w)) &#123;</span><br><span class="line">            gradient += offset_top_diff[ph * pooled_width + pw];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 存储当前输入feature map上元素的反向传播梯度信息</span></span><br><span class="line">    bottom_diff[index] = gradient;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="keyword">void</span> ROIPoolingLayer&lt;Dtype&gt;::Backward_gpu(</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,		<span class="comment">// roi pooling输出feature map</span></span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; propagate_down,	<span class="comment">// 是否做反向传播，回忆前向传播时的那个bool值</span></span><br><span class="line">	  <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) &#123;	<span class="comment">// roi pooling输入feature map(VGG16中的conv5_3产生的feature map)</span></span><br><span class="line">  <span class="keyword">if</span> (!propagate_down[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Dtype* bottom_rois = bottom[<span class="number">1</span>]-&gt;gpu_data();		<span class="comment">// 原始RoI信息</span></span><br><span class="line">  <span class="keyword">const</span> Dtype* top_diff = top[<span class="number">0</span>]-&gt;gpu_diff();			<span class="comment">// roi pooling feature map梯度信息</span></span><br><span class="line">  Dtype* bottom_diff = bottom[<span class="number">0</span>]-&gt;mutable_gpu_diff();	<span class="comment">// 待写入的输入feature map梯度信息</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> count = bottom[<span class="number">0</span>]-&gt;count();					<span class="comment">// 输入feature map元素总数</span></span><br><span class="line">  caffe_gpu_set(count, Dtype(<span class="number">0.</span>), bottom_diff);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* argmax_data = max_idx_.gpu_data();</span><br><span class="line">  <span class="comment">// NOLINT_NEXT_LINE(whitespace/operators)</span></span><br><span class="line">  ROIPoolBackward&lt;Dtype&gt;&lt;&lt;&lt;CAFFE_GET_BLOCKS(count), CAFFE_CUDA_NUM_THREADS&gt;&gt;&gt;(</span><br><span class="line">      count, top_diff, argmax_data, top[<span class="number">0</span>]-&gt;num(), spatial_scale_, channels_,</span><br><span class="line">      height_, width_, pooled_height_, pooled_width_, bottom_diff, bottom_rois);</span><br><span class="line">  CUDA_POST_KERNEL_CHECK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTANTIATE_LAYER_GPU_FUNCS(ROIPoolingLayer);</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace caffe</span></span><br></pre></td></tr></table></figure></li></ul><p>实现代码参考，GPU版本：<a target="_blank" rel="noopener" href="https://github.com/rbgirshick/caffe-fast-rcnn/blob/bcd9b4eadc7d8fbc433aeefd564e82ec63aaf69c/src/caffe/layers/roi_pooling_layer.cu">roi_pooling_layer.cu</a>和CPU版本：<a target="_blank" rel="noopener" href="https://github.com/rbgirshick/caffe-fast-rcnn/blob/bcd9b4eadc7d8fbc433aeefd564e82ec63aaf69c/src/caffe/layers/roi_pooling_layer.cpp">roi_pooling_layer.cpp</a>。</p><p>conv5_3及roi相关层配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;conv5_3&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv5_2&quot;</span></span><br><span class="line">  top: <span class="string">&quot;conv5_3&quot;</span></span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  param &#123;</span><br><span class="line">    lr_mult: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: <span class="number">512</span></span><br><span class="line">    pad: <span class="number">1</span></span><br><span class="line">    kernel_size: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;relu5_3&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv5_3&quot;</span></span><br><span class="line">  top: <span class="string">&quot;conv5_3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;roi_pool5&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;ROIPooling&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv5_3&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rois&quot;</span></span><br><span class="line">  top: <span class="string">&quot;pool5&quot;</span></span><br><span class="line">  roi_pooling_param &#123;</span><br><span class="line">    pooled_w: <span class="number">7</span></span><br><span class="line">    pooled_h: <span class="number">7</span></span><br><span class="line">    spatial_scale: <span class="number">0.0625</span> <span class="comment"># 1/16</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>一些直观解释<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bivq6gre1al81aqq1cgcflq78m.png" width="800"></center></li></ul><h2 id="faster-r-cnn">8.6 Faster R-CNN</h2><p>《<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1506.01497">Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</a>》提出了Region Proposal Network(RPN)，解决了基于Region的检测算法需要事先通过Selective Search生成候选框的问题，让候选框生成、分类、bounding box回归公用同一套特征提取网络，从而使这类检测算法真正意义上实现End to End。</p><h3 id="算法概述-1">8.6.1 算法概述</h3>如上所述，Faster R-CNN设计了RPN使得候选框生成可以共用特征提取网络，算法流程如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bj1mie6rheb17fo2hh1sk3js59.png" width="800"></center><p>RPN负责生成Proposal候选框，其他过程类似Fast R-CNN，同样，生成候选框的扫描过程发生在最后一个卷积层产生的feature map上（而不是扫描原图），通过之前讲的坐标换算关系可以将feature map任意一点映射回原图。</p><h3 id="rpn">8.6.2 RPN</h3>RPN的结构如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjht1v6fjkca6cpa49jh11j926.png" width="450"></center><p>1、RPN的输入是特征提取器最后一个卷积(pooling)产生的feature map，例如VGG16为conv5_3产生的512维（channel数）的feature map（图中例子是256维）；</p><p>2、之后以m×m大小的滑动窗口扫描feature map，如果feature map大小为h×w，则扫描h×w次（即以每个像素点为中心做一次），文中m的取值为3，取值与具体网络结构有关，感受野的不同导致候选框的初始大小不同；</p><p>3、每做一次滑动窗口会生成k个初始候选框，初始候选框的大小与anchor（<strong>原理8.6.3解释</strong>）有关，中心点为滑动窗口中心点，即对一次滑动窗口行为，所有利用anchor生成的候选框都有相同的中心点（图中蓝点），一定注意：这里的anchor及利用它生成的候选框都是<strong>相对于原图的位置</strong>；</p><p>4、定义两个分支，第一个分支（左边）是一个二分类器，用来区分当前候选框是否为物体，如果有k个由anchor生成的候选框，则输出2<em>k个值（2维向量为:[是物体的概率，是背景的概率]）；第二个分支（右边）为回归器，用来回归候选框的中心点坐标和宽与高（4维向量[x,y,w,h]），如果有k个由anchor生成的候选框，则输出4</em>k个值，显然这里候选框的生成要短、平、快，精调细选由后续网络来做。</p><h3 id="anchor">8.6.3 Anchor</h3><p>RPN里很重要的一个概念是anchor，可以把它理解为生成候选框的模板，在RPN里只生成一次，anchor是用原图为参照物，以(0,0,指定宽,指定高)四元组采用不同缩放比例和尺度后产生的候选框模板集合，而候选框由滑动窗口(中心点x，中心点y)利用anchor生成。也可以从逆SPP角度去理解，SPP可以把一个feature map通过多尺度变换为金字塔式的多个feature map，反过来任何一个feature map也可利用多尺度变成多个feature map，这么做的好处是压根儿不用在原图上做各种尺度缩放而只用在feature map上做就好，并且这种变换具有不变性(Translation-Invariant Anchor)：候选框生成及其预测函数具有可复现性，例如通过k-means聚类得到800个anchor，如果重复做一次实验不一定还是原来那800个，这个性质可以降低模型大小以及过拟合的风险。</p><p>以16×16大小为，base anchor[0,0,15,15]为例：</p>1、只使用_ratio_enum生成候选框如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjjioarcna9g52sdk98v1ko72j.png" width="800"></center>2、只使用_scale_enum生成候选框如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjjiq26o181l1m5r1d6r1ktq1td30.png" width="800"></center>3、混合使用生成候选框如下： 这种模板生成只需要做一次，之后大家以此为基准做中心点漂移即可。(所有其他像素点横纵坐标总是大于0的)<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjhhinlo1b97tjeralm8r1iddv.png" width="800"></center><p>代码可参考<a target="_blank" rel="noopener" href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py">generate_anchors.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Faster R-CNN</span></span><br><span class="line"><span class="comment"># Copyright (c) 2015 Microsoft</span></span><br><span class="line"><span class="comment"># Licensed under The MIT License [see LICENSE for details]</span></span><br><span class="line"><span class="comment"># Written by Ross Girshick and Sean Bell</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify that we compute the same anchors as Shaoqing&#x27;s matlab implementation:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    &gt;&gt; load output/rpn_cachedir/faster_rcnn_VOC2007_ZF_stage1_rpn/anchors.mat</span></span><br><span class="line"><span class="comment">#    &gt;&gt; anchors</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    anchors =</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       -83   -39   100    56</span></span><br><span class="line"><span class="comment">#      -175   -87   192   104</span></span><br><span class="line"><span class="comment">#      -359  -183   376   200</span></span><br><span class="line"><span class="comment">#       -55   -55    72    72</span></span><br><span class="line"><span class="comment">#      -119  -119   136   136</span></span><br><span class="line"><span class="comment">#      -247  -247   264   264</span></span><br><span class="line"><span class="comment">#       -35   -79    52    96</span></span><br><span class="line"><span class="comment">#       -79  -167    96   184</span></span><br><span class="line"><span class="comment">#      -167  -343   184   360</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#array([[ -83.,  -39.,  100.,   56.],</span></span><br><span class="line"><span class="comment">#       [-175.,  -87.,  192.,  104.],</span></span><br><span class="line"><span class="comment">#       [-359., -183.,  376.,  200.],</span></span><br><span class="line"><span class="comment">#       [ -55.,  -55.,   72.,   72.],</span></span><br><span class="line"><span class="comment">#       [-119., -119.,  136.,  136.],</span></span><br><span class="line"><span class="comment">#       [-247., -247.,  264.,  264.],</span></span><br><span class="line"><span class="comment">#       [ -35.,  -79.,   52.,   96.],</span></span><br><span class="line"><span class="comment">#       [ -79., -167.,   96.,  184.],</span></span><br><span class="line"><span class="comment">#       [-167., -343.,  184.,  360.]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成多尺度anchors，默认实现是大小为16，起始anchor位置是(0, 0, 15, 15)[左下角和右上角坐标]，宽高比例为1/2,1,2，尺度缩放倍数为8,16,32。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_anchors</span>(<span class="params">base_size=<span class="number">16</span>, ratios=[<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                     scales=<span class="number">2</span>**np.arange(<span class="params"><span class="number">3</span>, <span class="number">6</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generate anchor (reference) windows by enumerating aspect ratios X</span></span><br><span class="line"><span class="string">    scales wrt a reference (0, 0, 15, 15) window.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 生成起始anchor位置是(0, 0, 15, 15)</span></span><br><span class="line">    base_anchor = np.array([<span class="number">1</span>, <span class="number">1</span>, base_size, base_size]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 枚举1/2,1,2三种宽高缩放比例</span></span><br><span class="line">    ratio_anchors = _ratio_enum(base_anchor, ratios)</span><br><span class="line">    <span class="comment"># 在以上比例的基础上做8,16,32三类尺度缩放，最终生成9个anchor。</span></span><br><span class="line">    anchors = np.vstack([_scale_enum(ratio_anchors[i, :], scales)</span><br><span class="line">                         <span class="keyword">for</span> i <span class="keyword">in</span> xrange(ratio_anchors.shape[<span class="number">0</span>])])</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"><span class="comment"># 对给定anchor返回宽、高和中心点坐标（anchor存储的是左下角和右上角）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_whctrs</span>(<span class="params">anchor</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return width, height, x center, and y center for an anchor (window).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    w = anchor[<span class="number">2</span>] - anchor[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    h = anchor[<span class="number">3</span>] - anchor[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    x_ctr = anchor[<span class="number">0</span>] + <span class="number">0.5</span> * (w - <span class="number">1</span>)</span><br><span class="line">    y_ctr = anchor[<span class="number">1</span>] + <span class="number">0.5</span> * (h - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> w, h, x_ctr, y_ctr</span><br><span class="line"><span class="comment"># 给定宽、高和中心点，输出anchor的左下角和右上角坐标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_mkanchors</span>(<span class="params">ws, hs, x_ctr, y_ctr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a vector of widths (ws) and heights (hs) around a center</span></span><br><span class="line"><span class="string">    (x_ctr, y_ctr), output a set of anchors (windows).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ws = ws[:, np.newaxis]</span><br><span class="line">    hs = hs[:, np.newaxis]</span><br><span class="line">    anchors = np.hstack((x_ctr - <span class="number">0.5</span> * (ws - <span class="number">1</span>),</span><br><span class="line">                         y_ctr - <span class="number">0.5</span> * (hs - <span class="number">1</span>),</span><br><span class="line">                         x_ctr + <span class="number">0.5</span> * (ws - <span class="number">1</span>),</span><br><span class="line">                         y_ctr + <span class="number">0.5</span> * (hs - <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举anchor的三种宽高比 1:2,1:1,2:1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ratio_enum</span>(<span class="params">anchor, ratios</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Enumerate a set of anchors for each aspect ratio wrt an anchor.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor)</span><br><span class="line">    size = w * h</span><br><span class="line">    size_ratios = size / ratios</span><br><span class="line">    ws = np.<span class="built_in">round</span>(np.sqrt(size_ratios))</span><br><span class="line">    hs = np.<span class="built_in">round</span>(ws * ratios)</span><br><span class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr)</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举anchor的各种尺度，如：anchor为[0 0 15 15],尺度为[8 16 32]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_scale_enum</span>(<span class="params">anchor, scales</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Enumerate a set of anchors for each scale wrt an anchor.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor)</span><br><span class="line">    ws = w * scales</span><br><span class="line">    hs = h * scales</span><br><span class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr)</span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    t = time.time()</span><br><span class="line">    a = generate_anchors()</span><br><span class="line">    <span class="built_in">print</span> time.time() - t</span><br><span class="line">    <span class="built_in">print</span> a</span><br><span class="line">    <span class="keyword">from</span> IPython <span class="keyword">import</span> embed; embed()</span><br></pre></td></tr></table></figure><p></p><h3 id="代码实践-5">8.6.4 代码实践</h3><p>集中介绍RPN中proposal层的实现，以特征提取网络采用VGG16在poscal_voc数据集上为例。</p><ul><li>网络结构<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/VGG16-fasterrcnn.png" width="800"></center></li><li><p>RPN配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;rpn_conv/3x3&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;conv5_3&quot;</span></span><br><span class="line">  top: <span class="string">&quot;rpn/output&quot;</span></span><br><span class="line">  param &#123; lr_mult: <span class="number">1.0</span> &#125;</span><br><span class="line">  param &#123; lr_mult: <span class="number">2.0</span> &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: <span class="number">512</span></span><br><span class="line">    kernel_size: <span class="number">3</span> pad: <span class="number">1</span> stride: <span class="number">1</span></span><br><span class="line">    weight_filler &#123; <span class="built_in">type</span>: <span class="string">&quot;gaussian&quot;</span> std: <span class="number">0.01</span> &#125;</span><br><span class="line">    bias_filler &#123; <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span> value: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;rpn_relu/3x3&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rpn/output&quot;</span></span><br><span class="line">  top: <span class="string">&quot;rpn/output&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;rpn_cls_score&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rpn/output&quot;</span></span><br><span class="line">  top: <span class="string">&quot;rpn_cls_score&quot;</span></span><br><span class="line">  param &#123; lr_mult: <span class="number">1.0</span> &#125;</span><br><span class="line">  param &#123; lr_mult: <span class="number">2.0</span> &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: <span class="number">18</span>   <span class="comment"># 2(bg/fg) * 9(anchors)</span></span><br><span class="line">    kernel_size: <span class="number">1</span> pad: <span class="number">0</span> stride: <span class="number">1</span></span><br><span class="line">    weight_filler &#123; <span class="built_in">type</span>: <span class="string">&quot;gaussian&quot;</span> std: <span class="number">0.01</span> &#125;</span><br><span class="line">    bias_filler &#123; <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span> value: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;rpn_bbox_pred&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rpn/output&quot;</span></span><br><span class="line">  top: <span class="string">&quot;rpn_bbox_pred&quot;</span></span><br><span class="line">  param &#123; lr_mult: <span class="number">1.0</span> &#125;</span><br><span class="line">  param &#123; lr_mult: <span class="number">2.0</span> &#125;</span><br><span class="line">  convolution_param &#123;</span><br><span class="line">    num_output: <span class="number">36</span>   <span class="comment"># 4 * 9(anchors)</span></span><br><span class="line">    kernel_size: <span class="number">1</span> pad: <span class="number">0</span> stride: <span class="number">1</span></span><br><span class="line">    weight_filler &#123; <span class="built_in">type</span>: <span class="string">&quot;gaussian&quot;</span> std: <span class="number">0.01</span> &#125;</span><br><span class="line">    bias_filler &#123; <span class="built_in">type</span>: <span class="string">&quot;constant&quot;</span> value: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer &#123;</span><br><span class="line">   bottom: <span class="string">&quot;rpn_cls_score&quot;</span></span><br><span class="line">   top: <span class="string">&quot;rpn_cls_score_reshape&quot;</span></span><br><span class="line">   name: <span class="string">&quot;rpn_cls_score_reshape&quot;</span></span><br><span class="line">   <span class="built_in">type</span>: <span class="string">&quot;Reshape&quot;</span></span><br><span class="line">   reshape_param &#123; shape &#123; dim: <span class="number">0</span> dim: <span class="number">2</span> dim: -<span class="number">1</span> dim: <span class="number">0</span> &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&#x27;rpn-data&#x27;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">  bottom: <span class="string">&#x27;rpn_cls_score&#x27;</span></span><br><span class="line">  bottom: <span class="string">&#x27;gt_boxes&#x27;</span></span><br><span class="line">  bottom: <span class="string">&#x27;im_info&#x27;</span></span><br><span class="line">  bottom: <span class="string">&#x27;data&#x27;</span></span><br><span class="line">  top: <span class="string">&#x27;rpn_labels&#x27;</span></span><br><span class="line">  top: <span class="string">&#x27;rpn_bbox_targets&#x27;</span></span><br><span class="line">  top: <span class="string">&#x27;rpn_bbox_inside_weights&#x27;</span></span><br><span class="line">  top: <span class="string">&#x27;rpn_bbox_outside_weights&#x27;</span></span><br><span class="line">  python_param &#123;</span><br><span class="line">    module: <span class="string">&#x27;rpn.anchor_target_layer&#x27;</span></span><br><span class="line">    layer: <span class="string">&#x27;AnchorTargetLayer&#x27;</span></span><br><span class="line">    param_str: <span class="string">&quot;&#x27;feat_stride&#x27;: 16&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;rpn_loss_cls&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;SoftmaxWithLoss&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rpn_cls_score_reshape&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rpn_labels&quot;</span></span><br><span class="line">  propagate_down: <span class="number">1</span></span><br><span class="line">  propagate_down: <span class="number">0</span></span><br><span class="line">  top: <span class="string">&quot;rpn_cls_loss&quot;</span></span><br><span class="line">  loss_weight: <span class="number">1</span></span><br><span class="line">  loss_param &#123;</span><br><span class="line">    ignore_label: -<span class="number">1</span></span><br><span class="line">    normalize: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">&quot;rpn_loss_bbox&quot;</span></span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&quot;SmoothL1Loss&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rpn_bbox_pred&quot;</span></span><br><span class="line">  bottom: <span class="string">&quot;rpn_bbox_targets&quot;</span></span><br><span class="line">  bottom: <span class="string">&#x27;rpn_bbox_inside_weights&#x27;</span></span><br><span class="line">  bottom: <span class="string">&#x27;rpn_bbox_outside_weights&#x27;</span></span><br><span class="line">  top: <span class="string">&quot;rpn_loss_bbox&quot;</span></span><br><span class="line">  loss_weight: <span class="number">1</span></span><br><span class="line">  smooth_l1_loss_param &#123; sigma: <span class="number">3.0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>准备阶段 配置参数和生成anchor模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self, bottom, top</span>):</span></span><br><span class="line">        <span class="comment"># parse the layer parameter string, which must be valid YAML</span></span><br><span class="line">        layer_params = yaml.load(self.param_str_)</span><br><span class="line">        <span class="comment"># 获取所有特征提取层stride的乘积。（例如VGG为16）</span></span><br><span class="line">        self._feat_stride = layer_params[<span class="string">&#x27;feat_stride&#x27;</span>]</span><br><span class="line">        <span class="comment"># 设置初始尺度变换比例为8、16、32。</span></span><br><span class="line">        anchor_scales = layer_params.get(<span class="string">&#x27;scales&#x27;</span>, (<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>))</span><br><span class="line">        <span class="comment"># 使用上面介绍的方法生成anchor模板。</span></span><br><span class="line">        self._anchors = generate_anchors(scales=np.array(anchor_scales))</span><br><span class="line">        <span class="comment"># anchor数量。（例如：9）</span></span><br><span class="line">        self._num_anchors = self._anchors.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> DEBUG:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;feat_stride: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self._feat_stride)</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;anchors:&#x27;</span></span><br><span class="line">            <span class="built_in">print</span> self._anchors</span><br><span class="line"></span><br><span class="line">        <span class="comment"># rois blob: holds R regions of interest, each is a 5-tuple</span></span><br><span class="line">        <span class="comment"># (n, x1, y1, x2, y2) specifying an image batch index n and a</span></span><br><span class="line">        <span class="comment"># rectangle (x1, y1, x2, y2)</span></span><br><span class="line">        top[<span class="number">0</span>].reshape(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># scores blob: holds scores for R regions of interest</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(top) &gt; <span class="number">1</span>:</span><br><span class="line">            top[<span class="number">1</span>].reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p></li><li>前向传播<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjk8ruf11p2rkalrqph4u1jk53p.png" width="300"></center></li></ul>以i为中心利用anchor模板生成anchor过程如下(蓝色为模板，用红色为i中心点生成)：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjhi2u9n1aahsa712s5s2gi621c.png" width="800"></center><p>实现上就是中心点i的各个坐标直接加到anchor模板的各个坐标即可（anchor模板是以0为中心点的），代码类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = self._num_anchors</span><br><span class="line">K = shifts.shape[<span class="number">0</span>]</span><br><span class="line">anchors = self._anchors.reshape((<span class="number">1</span>, A, <span class="number">4</span>)) + \</span><br><span class="line">          shifts.reshape((<span class="number">1</span>, K, <span class="number">4</span>)).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">anchors = anchors.reshape((K * A, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p></p><h3 id="faster-r-cnn训练流程">8.6.5 Faster R-CNN训练流程</h3><p>采用四阶段交替方式训练(4-Step Alternating Training)</p><p>1、使用ImageNet预训练模型权重初始化并fine-tuned训练一个RPN；</p><p>2、使用ImageNet预训练模型权重初始化并将上一步产生的候选框(proposal)作为输入训练独立的Faster R-CNN检测模型（此时没有卷积网络共享）；</p><p>3、生成新的RPN并使用上一步Fast-RCNN模型参数初始化，设置RPN、Fast-RCNN共享的那部分网络权重不做更新，只fine-tuned训练RPN独有的网络层，达到两者共享用于提取特征的卷积层的目的；</p><p>4、固定共享的那些卷积层权重，只训练Fast-RCNN独有的网络层。</p><p>Faster R-CNN是效果最好的目标检测与分类模型之一，但如果想用于实时监测和前置到客户端则需要做大量模型裁剪、压缩和优化工作，具体做法我以后介绍，目前我们做的比较初步，模型大小压缩到10m左右，准确率损失小于1.5%，线上inference响应时间在500k左右大小图片、k80单机单卡单次请求下为20ms左右（在高并发情况下会通过打batch的方式及其他方法提高并发量）。</p><strong>未做优化</strong>的汽车检测demo：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjmrl00f1l1f8pnpg2qkbb1o9.png" width="600" height="400"></center><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer0"),loop:"yes",screenshot:"yes",video:{url:"https://vivounicorn.github.io/images/ai_chapter_8/output.mp4"},danmaku:{api:"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><h3 id="faster-r-cnn-with-caffe">8.6.6 Faster R-CNN with Caffe</h3>源码地址：<a target="_blank" rel="noopener" href="https://github.com/rbgirshick/py-faster-rcnn">Faster R-CNN</a>（rbgirshick版）。 一定注意，caffe有个问题（我认为是架构上的设计缺陷，这个问题tensorflow就没有）：由于要支持自定义的网络层之类的需求，每个人的caffe版本可能是不一样的，所以在编译时需要注意，比如这里的caffe必须使用0dcd397这个branch，否则编译不通过，因为这里有自定义的proposal层以及相关参数。 目录结构如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bjka01lv1t6k184g1pt81r69ek746.png" width="600" height="400"></center><hr><p><strong>Centos 7上编译运行caffe及Faster R-CNN</strong></p><ul><li><p>编译准备 1、 为你的账号添加sudo权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -a user_name wheel</span><br></pre></td></tr></table></figure>2、安装编译器<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gcc gcc-c++</span><br></pre></td></tr></table></figure>3、安装 git<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git</span><br></pre></td></tr></table></figure>4、clone代码<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rbgirshick/py-faster-rcnn.git</span><br></pre></td></tr></table></figure>5、安装依赖项<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install snappy-devel opencv-devel atlas-devel boost-devel protobuf-devel</span><br></pre></td></tr></table></figure>6、安装cmake<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake</span><br></pre></td></tr></table></figure>7、安装automake<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> wget http://ftp.gnu.org/gnu/automake/automake-1.14.tar.gz</span><br><span class="line">tar -xvf automake-1.14.tar.gz</span><br><span class="line">cd automake-1.14</span><br><span class="line">./configure</span><br><span class="line">make -j</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>8、安装gflags<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gflags/gflags</span><br><span class="line"></span><br><span class="line">cd gflags</span><br><span class="line"></span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line"></span><br><span class="line">export CXXFLAGS=&quot;-fPIC&quot; &amp;&amp; cmake ..</span><br><span class="line"></span><br><span class="line">make VERBOSE=1 -j</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>9、安装glog<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/google/glog</span><br><span class="line"></span><br><span class="line">cd glog</span><br><span class="line"></span><br><span class="line">./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>10、安装 lmdb<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LMDB/lmdb</span><br><span class="line"></span><br><span class="line">cd lmdb/libraries/liblmdb</span><br><span class="line"></span><br><span class="line">make -j</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>11、安装 hdf5<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://support.hdfgroup.org/ftp/HDF5/current18/src/hdf5-1.8.19.tar.gz</span><br><span class="line"></span><br><span class="line"> tar -xvf hdf5-1.8.19.tar.gz</span><br><span class="line"></span><br><span class="line">cd hdf5-1.8.19</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line"></span><br><span class="line">make -j</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p></p>12、安装 leveldb<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/google/leveldb</span><br><span class="line"></span><br><span class="line">cd leveldb</span><br><span class="line"></span><br><span class="line">make -j</span><br><span class="line"></span><br><span class="line">sudo cp out-shared/libleveldb.so* /usr/local/lib</span><br><span class="line"></span><br><span class="line">sudo cp out-static/*.a /usr/local/lib</span><br><span class="line"></span><br><span class="line">sudo cp -r include/* /usr/local/include</span><br></pre></td></tr></table></figure></li><li><p>编译caffe</p><p>1、下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd py-faster-rcnn</span><br><span class="line">git clone  https://github.com/rbgirshick/caffe-fast-rcnn.git</span><br></pre></td></tr></table></figure><p></p><p>检查文件/src/caffe/proto/caffe.proto是否与下面文件一致： <a href="https://vivounicorn.github.io/images/ai_chapter_8/caffe.proto">点击下载 caffe.proto 文件</a></p><p>2、修改配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd caffe-fast-rcnn</span><br><span class="line"></span><br><span class="line">cp Makefile.config.example Makefile.config</span><br><span class="line"></span><br><span class="line">vim Makefile.config</span><br></pre></td></tr></table></figure>修改它的几个地方：<p></p><pre><code>  1)、指定CUDA_DIR，如：CUDA_DIR := /usr/local/cuda

  2)、BLAS := open

  3)、WITH_PYTHON_LAYER := 1</code></pre>3、编译caffe-fast-rcnn<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make all -j</span><br><span class="line"></span><br><span class="line">make test -j</span><br><span class="line"></span><br><span class="line">make runtest -j</span><br><span class="line"></span><br><span class="line">make pycaffe -j</span><br></pre></td></tr></table></figure>4、编译py-faster-rcnn的lib<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd py-faster-rcnn/lib/</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure>5、配置环境变量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">export PYTHONPATH=/data/liyiran/py-R-FCN/tools/python:$PYTHONPATH</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>运行示例</p><p>1、下载pascal_voc数据集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd py-faster-rcnn/data</span><br><span class="line"></span><br><span class="line">wget http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar</span><br><span class="line"></span><br><span class="line">tar -xvf VOCtrainval_06-Nov-2007.tar</span><br><span class="line"></span><br><span class="line">mv VOCtrainval_06-Nov-2007 VOCdevkit2007</span><br></pre></td></tr></table></figure>2、下载预训练模型<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd py-faster-rcnn/model</span><br><span class="line"></span><br><span class="line">wget https://dl.dropboxusercontent.com/s/gstw7122padlf0l/imagenet_models.tgz?dl=0</span><br></pre></td></tr></table></figure><p></p><p>3、使用VGG16，应用于pascal_voc 2007数据集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh experiments/scripts/faster_rcnn_end2end.sh 1 VGG16 pascal_voc</span><br></pre></td></tr></table></figure><p></p></li></ul><h2 id="r-fcn">8.7 R-FCN</h2><p>回想之前所有基于Region的检测算法，有一个共同点是：整个网络被分成两部分：共享计算的、与Region无关的全卷积子网络和RoI Pooling之后不共享计算的、与Region相关的子网络(如RPN和BBox Regression网络)。再回想之前所有的分类网络，尤其到残差和GoogLeNet系列，都可以看做是全卷积网络，且在分类问题上的效果已经非常赞了，但当把这些网络直接用于检测问题时，效果往往特别差，甚至不如VGG-16，原因也是明确的：分类问题往往会忽略位置信息，只需要判断是否为某个物体，所以要求提取出来的特征具有平移不变性，不管图片特征放大、缩小还是位移都能很好的适应，而卷积操作、pooling操作都能较好的保持这个性质，并且网络越深模型越对位置不敏感；但在检测问题中，提取的特征还需要能敏锐的捕捉到位置信息，即具备平移变化性，这就尴尬了。为此，大家插入类似RoI Pooling这样的层结构，一方面是的任意大小图片都可以输入，更重要的是一定程度上弥补了位置信息的缺失，所以检测效果也就嗖嗖的上来了。但带来一个副作用是：RoI后每个Region都需要跑一遍后续子网络，计算不共享就导致训练和Inference的速度慢，为此代季峰、何凯明几位提出《<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1605.06409.pdf">R-FCN: Object Detection via Region-based Fully Convolutional Networks</a>》检测框架，用Position-Sensitive RoI Pooling代替原来的RoI Pooling，共享了所有计算，很好的tradeoff了平移不变性和平移变化性，并且由于是全卷积，训练和Inference的速度更快。</p>以ResNet-101为例，图片<a target="_blank" rel="noopener" href="https://www.robots.ox.ac.uk/~vgg/rg/slides/vgg_rg_16_feb_2017_rfcn.pdf">来源</a>：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bord2chg3k91e1918ga1lb4dcb9.png" width="500"></center><h3 id="算法概述-2">8.7.1 算法概述</h3><p>1、核心思想</p>如上所述，算法核心就是position-sentitive RoI pooling的加入，核心思想是这样的：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bordnnep1lfsh8h13hdu2lo0h1m.png" width="600"></center><p>这里的feature map是过去RoI Pooling前的全卷积特征提取子网络，之后接着的（彩色立方体）是position-sensitive feature map，它其实是一个<strong>普通的卷积层</strong>，权重通过position-sensitive RoI Pooling层反向传播时修正。假设position-sensitive feature map（后面简写为ps feature map）的大小为k×k，检测分类数为C+1（1为背景类），则ps feature map的通道数为：k×k×(C+1)，假如K=3，则每一类的 ps feature map会有k×k=9个，每个feature map含有一类位置特征（如：左上、左中、左右、......，下右，图中用不同颜色代表）；接着，通过ps RoI Pooling后，每个RoI Region在C+1的每一类上都会得到一个k×k网格，对每个网格做分类判断，之后所有网格一起投票。最终得到C+1维向量，然后接个softmax做分类。</p><p>2、整体结构</p>考虑RPN子网络，整体结构是这样的：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1borduslh1ghka2p1odb2o1fk323.png" width="600"></center><p>对RPN来说也是类似，每个Bounding Box候选框的位置为一类（左上角坐标、长和宽），ps feature map的通道数为k×k×4。</p><p>3、position-sensitive feature map</p><p>以ResNet-101作为基础网络结构为例，做以下结构上的更改：</p><ul><li>去掉GAP层和所有fc层</li><li>保留前100层，最后一个卷积层后接一个(1×1)×1024卷积层做降维</li></ul><p>为了显示编码位置信息，假如ps feature map网格大小k×k，RoI大小为：<span class="math inline">\(w×h\)</span>，则每个bin大小约为：<span class="math inline">\(\frac{w}{k} ×\frac{h}{k}\)</span>，对于第(i,j)个bin（<span class="math inline">\(0\leq i,j\leq k-1\)</span>）做ps RoI Pooling为：</p><p><span class="math display">\[ r_c(i,j|\Theta)=\sum_{(x,y)\in bin(i,j)}z_{i,j,c}(x+x_0,y+y_0|\Theta)/n. \]</span></p><p>其中：</p><p><span class="math inline">\(r_c(i,j)\)</span>为第c类在第(i,j)个bin的pooling响应值；</p><p><span class="math inline">\(z_{i,j,c}\)</span>为是k×k×(C+1)个feature map中的一个；</p><p><span class="math inline">\((x_0,y_0)\)</span>为RoI的左上角坐标；</p><p><span class="math inline">\(n\)</span>是当前bin中的像素数；</p><p><span class="math inline">\(\Theta\)</span>是网络所有可学习参数；</p><p>x、y的取值范围为：<span class="math inline">\(\lfloor i\frac{w}{k}\rfloor \leq x \leq \lceil(i+1)\frac{w}{k}\rceil\)</span>，<span class="math inline">\(\lfloor j\frac{h}{k}\rfloor \leq y \leq \lceil(j+1)\frac{h}{k}\rceil\)</span>；</p><p>pooling采用average、max甚至其他自定义的操作。</p><p>4、损失函数定义</p><p>由分类部分和回归部分损失组成：</p><p><span class="math display">\[ L(s,t_{x,y,w,h})=L_{cls}(s_{c^*})+\lambda [c^*&gt;0]L_{reg}(t,t^*) \]</span> 其中：</p><p><span class="math inline">\(c^*\)</span>是每一类的label，<span class="math inline">\(c^*=0\)</span>代表背景类；</p><p><span class="math inline">\(L_{cls}(s_{c^*})=-log(s_{c^*})=-log(\frac{e^{r_{c^*}(\Theta)}}{\sum_{c=0}^{C}e^{r_{c(\Theta)}}})\)</span>，是交叉熵损失函数；</p><p><span class="math inline">\(L_{reg}(t,t^*)=\sum_{i \in \{x,y,w,h\}}smooth_{L_1}(t-t^*)\)</span>，与Fast R-CNN的定义一致；</p><p><span class="math inline">\([c^*&gt;0] = \begin{cases}1&amp; \text{if }c^*&gt;0\\0&amp; \text{otherwise}\end{cases}\)</span></p><p>5、可视化效果</p>预测正例：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1borjgjtc16vu1od1qk619t61k8f30.png" width="600"></center>预测负例：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1borjid0t1m1qeeaj281ja31o1j3d.png" width="600"></center><h3 id="position-sentitive-roi-pooling">8.7.2 position-sentitive RoI pooling</h3><ul><li>原图及检测图</li></ul><center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bnq3ig3p88edhnnlq17ml1ng2v.png" width="600"></center><ul><li>所有分类下的位置敏感特征图<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bnq32c2323o12giggg1q6ri5k9.png" width="600"></center></li></ul><h3 id="模型训练">8.7.3 模型训练</h3><p>1、训练使用<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1604.03540.pdf">Online Hard Example Mining</a></p><p>OHEM是一种boosting策略，目的是使得训练更加高效，简单说，它不是使用简单的抽样策略，而是对容易判断的样本做抑制，对模型不容易判断的样本重复添加。 在检测中，正样本定义为：与ground-truth的<span class="math inline">\(IoU\geq0.5\)</span>，反之为负样本，应用过程为：</p><ul><li>前向传播：所有候选框在Inference后做损失排序，选取B(一共N个)个损失最高的候选框，当然，由于临近位置的候选框的损失相近，所以还需要对其做NMS(如取IoU=0.7)，然后再选出这B个样本；</li><li>反向传播：仅用这B个样本做反向传播更新权重。</li></ul><p>2、训练参数</p><ul><li>权重衰减系数：0.0005</li><li>动量项取值：0.9</li><li>图像被缩放为600像素</li><li>每个GPU使用一张图像，选择B=128个候选框做反向传播</li><li>利用VOC数据做fine-tune</li><li>采用 Faster R-CNN的四步交替法训练</li></ul><h3 id="代码实践-6">8.7.4 代码实践</h3>源码可在<a target="_blank" rel="noopener" href="https://github.com/YuwenXiong/py-R-FCN">py-R-FCN</a>下载，需要把下载<a target="_blank" rel="noopener" href="https://github.com/daijifeng001/caffe-rfcn">R-FCN版本caffe</a>，编译方式类似Faster RCNN，目录类似：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1bnmv6i6n181gsds1ea7r1q13v49.png" width="600"></center><ul><li>PSROIPooling</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">// ------------------------------------------------------------------</span><br><span class="line">// R-FCN</span><br><span class="line">// Copyright (c) <span class="number">2016</span> Microsoft</span><br><span class="line">// Licensed under The MIT License [see r-fcn/LICENSE <span class="keyword">for</span> details]</span><br><span class="line">// Written by Yi Li</span><br><span class="line">// ------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;cfloat&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;caffe/rfcn_layers.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;caffe/util/gpu_util.cuh&quot;</span></span><br><span class="line"></span><br><span class="line">using std::<span class="built_in">max</span>;</span><br><span class="line">using std::<span class="built_in">min</span>;</span><br><span class="line"></span><br><span class="line">namespace caffe &#123;</span><br><span class="line"></span><br><span class="line">  template &lt;typename Dtype&gt;</span><br><span class="line">  __global__ void PSROIPoolingForward(</span><br><span class="line">    const <span class="built_in">int</span> nthreads,			// 任务数，对应通过roi pooling后的输出feature <span class="built_in">map</span>的神经元节点总数，RoI的个数(m) × channel个数(<span class="number">21</span>类) × psroi pooling输出宽(配置为<span class="number">7</span>) × psroi pooling输出高(配置为<span class="number">7</span>) = <span class="number">1029</span>×m个</span><br><span class="line">    const Dtype* bottom_data,	// 输入的feature <span class="built_in">map</span>，原图经过各种卷积、pooling等前向传播后得到（ResNet50的rfcn_cls卷积产生的position sensitive feature <span class="built_in">map</span>，大小为：<span class="number">1029</span>×<span class="number">14</span>×<span class="number">14</span>）</span><br><span class="line">    const Dtype spatial_scale,	// 由之前所有卷积层的strides相乘得到，在rfcn中为<span class="number">1</span>/<span class="number">16</span>，注：从原图往rfcn_cls的feature <span class="built_in">map</span>上映射为缩小过程，所以乘以<span class="number">1</span>/<span class="number">16</span>，反之需要乘以<span class="number">16</span></span><br><span class="line">    const <span class="built_in">int</span> channels,			// 输入层（ResNet50为卷积层rfcn_cls）feature <span class="built_in">map</span>的channel个数(k×k×(C+<span class="number">1</span>)=<span class="number">7</span>×<span class="number">7</span>×<span class="number">21</span>=<span class="number">1029</span>)</span><br><span class="line">    const <span class="built_in">int</span> height,			// feature <span class="built_in">map</span>的宽度(<span class="number">14</span>)</span><br><span class="line">	const <span class="built_in">int</span> width,			// feature <span class="built_in">map</span>的高度(<span class="number">14</span>)</span><br><span class="line">    const <span class="built_in">int</span> pooled_height,	// psroi pooling输出feature <span class="built_in">map</span>的高，fast rcnn中配置为h=<span class="number">7</span></span><br><span class="line">	const <span class="built_in">int</span> pooled_width,		// psroi pooling输出feature <span class="built_in">map</span>的宽，fast rcnn中配置为w=<span class="number">7</span></span><br><span class="line">    const Dtype* bottom_rois,	// 输入的roi信息，存储所有rois或一个batch的rois，数据结构为[batch_ind,x1,y1,x2,y2]，包含roi的：索引、左上角坐标及右下角坐标</span><br><span class="line">    const <span class="built_in">int</span> output_dim,		// 输出feature <span class="built_in">map</span>的维度，psroipooled_cls_rois为<span class="number">21</span>（<span class="number">21</span>个类别），psroipooled_loc_rois为<span class="number">8</span></span><br><span class="line">    const <span class="built_in">int</span> group_size,		// k=<span class="number">7</span></span><br><span class="line">    Dtype* top_data,			// 存储psroi pooling后得到的feature <span class="built_in">map</span></span><br><span class="line">    <span class="built_in">int</span>* mapping_channel) &#123;</span><br><span class="line">								// index为线程索引，个数为psroi pooling后的feature <span class="built_in">map</span>上所有值的个数，索引范围为：[<span class="number">0</span>,nthreads-<span class="number">1</span>]</span><br><span class="line">    CUDA_KERNEL_LOOP(index, nthreads) &#123;</span><br><span class="line">      // 该线程对应的top blob（N,C,H,W）中的W,输出roi pooling后feature <span class="built_in">map</span>的中的宽的坐标，即feature <span class="built_in">map</span>的第i=[<span class="number">0</span>,k-<span class="number">1</span>]列</span><br><span class="line">      <span class="built_in">int</span> pw = index % pooled_width;</span><br><span class="line">	  // 该线程对应的top blob（N,C,H,W）中的H,输出roi pooling后feature <span class="built_in">map</span>的中的高的坐标，即feature <span class="built_in">map</span>的第j=[<span class="number">0</span>,k-<span class="number">1</span>]行</span><br><span class="line">      <span class="built_in">int</span> ph = (index / pooled_width) % pooled_height;</span><br><span class="line">	  // 该线程对应的top blob（N,C,H,W）中的C,即第c个channel，channel数最大值为<span class="number">21</span>（包含背景类的类别数）</span><br><span class="line">      <span class="built_in">int</span> ctop = (index / pooled_width / pooled_height) % output_dim;</span><br><span class="line">	  // 该线程对应的是第几个RoI,一共m个.</span><br><span class="line">      <span class="built_in">int</span> n = index / pooled_width / pooled_height / output_dim;</span><br><span class="line"></span><br><span class="line">      // [start, end)，指定RoI信息的存储范围，指针每次移动<span class="number">5</span>的倍数是因为包含信息的数据结构大小为<span class="number">5</span>，包含信息为：[batch_ind,x1,y1,x2,y2]，含义同上</span><br><span class="line">      bottom_rois += n * <span class="number">5</span>;</span><br><span class="line">	  // 将每个原图的RoI区域映射到feature <span class="built_in">map</span>(VGG16为conv5_3产生的feature mao)上的坐标,bottom_rois第<span class="number">0</span>个位置存放的是roi索引.</span><br><span class="line">      <span class="built_in">int</span> roi_batch_ind = bottom_rois[<span class="number">0</span>];</span><br><span class="line">	  // 原图到feature <span class="built_in">map</span>的映射为乘以<span class="number">1</span>/<span class="number">16</span>，这里采用粗映射而不是上文讲的精确映射，原因你懂的.</span><br><span class="line">      Dtype roi_start_w = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">1</span>])) * spatial_scale;</span><br><span class="line">      Dtype roi_start_h = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">2</span>])) * spatial_scale;</span><br><span class="line">      Dtype roi_end_w = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">3</span>]) + <span class="number">1.</span>) * spatial_scale;</span><br><span class="line">      Dtype roi_end_h = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">4</span>]) + <span class="number">1.</span>) * spatial_scale;</span><br><span class="line"></span><br><span class="line">      // 强制把RoI的宽和高限制在1x1，防止出现映射后的RoI大小为<span class="number">0</span>的情况</span><br><span class="line">      Dtype roi_width = <span class="built_in">max</span>(roi_end_w - roi_start_w, <span class="number">0.1</span>);</span><br><span class="line">      Dtype roi_height = <span class="built_in">max</span>(roi_end_h - roi_start_h, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">      // 根据原图映射得到的roi的高和配置的psroi pooling的高(这里大小配置为<span class="number">7</span>)自适应计算<span class="built_in">bin</span>桶的高度</span><br><span class="line">      Dtype bin_size_h = roi_height / static_cast&lt;Dtype&gt;(pooled_height);</span><br><span class="line">	  // 根据原图映射得到的roi的宽和配置的psroi pooling的宽(这里大小配置为<span class="number">7</span>)自适应计算<span class="built_in">bin</span>桶的宽度</span><br><span class="line">      Dtype bin_size_w = roi_width / static_cast&lt;Dtype&gt;(pooled_width);</span><br><span class="line"></span><br><span class="line">	  // 计算第(i,j)个<span class="built_in">bin</span>桶在feature <span class="built_in">map</span>上的坐标范围，需要依据它们确定后续pooling的范围</span><br><span class="line">      <span class="built_in">int</span> hstart = floor(static_cast&lt;Dtype&gt;(ph) * bin_size_h</span><br><span class="line">                          + roi_start_h);</span><br><span class="line">      <span class="built_in">int</span> wstart = floor(static_cast&lt;Dtype&gt;(pw)* bin_size_w</span><br><span class="line">                          + roi_start_w);</span><br><span class="line">      <span class="built_in">int</span> hend = ceil(static_cast&lt;Dtype&gt;(ph + <span class="number">1</span>) * bin_size_h</span><br><span class="line">                        + roi_start_h);</span><br><span class="line">      <span class="built_in">int</span> wend = ceil(static_cast&lt;Dtype&gt;(pw + <span class="number">1</span>) * bin_size_w</span><br><span class="line">                        + roi_start_w);</span><br><span class="line">      // 确定<span class="built_in">max</span> pooling具体范围，注意由于RoI取自原图，其左上角不是从(<span class="number">0</span>,<span class="number">0</span>)开始，</span><br><span class="line">	  // 所以需要加上 roi_start_h 或 roi_start_w作为偏移量，并且超出feature <span class="built_in">map</span>尺寸范围的部分会被舍弃</span><br><span class="line">      hstart = <span class="built_in">min</span>(<span class="built_in">max</span>(hstart, <span class="number">0</span>), height);</span><br><span class="line">      hend = <span class="built_in">min</span>(<span class="built_in">max</span>(hend, <span class="number">0</span>), height);</span><br><span class="line">      wstart = <span class="built_in">min</span>(<span class="built_in">max</span>(wstart, <span class="number">0</span>),width);</span><br><span class="line">      wend = <span class="built_in">min</span>(<span class="built_in">max</span>(wend, <span class="number">0</span>), width);</span><br><span class="line">      <span class="built_in">bool</span> is_empty = (hend &lt;= hstart) || (wend &lt;= wstart);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">int</span> gw = pw;</span><br><span class="line">      <span class="built_in">int</span> gh = ph;</span><br><span class="line">	  // 计算第C类的(ph,pw)位置索引 = ctop×group_size×group_size + gh×gh×group_size + gw</span><br><span class="line">      // 例如: ps feature <span class="built_in">map</span>上第C[=<span class="number">1</span>]类的第(i,j)[=(<span class="number">1</span>,<span class="number">1</span>)]位置，c=<span class="number">1</span>×<span class="number">7</span>×<span class="number">7</span> + <span class="number">1</span>×<span class="number">1</span>×<span class="number">7</span>+<span class="number">1</span>=<span class="number">57</span></span><br><span class="line">      <span class="built_in">int</span> c = (ctop*group_size + gh)*group_size + gw;</span><br><span class="line"></span><br><span class="line">	  // 逐层做average pooling</span><br><span class="line">      bottom_data += (roi_batch_ind * channels + c) * height * width;</span><br><span class="line">      Dtype out_sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> h = hstart; h &lt; hend; ++h)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = wstart; w &lt; wend; ++w)&#123;</span><br><span class="line">          <span class="built_in">int</span> bottom_index = h*width + w;</span><br><span class="line">          out_sum += bottom_data[bottom_index];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	  // 计算第(i,j)<span class="built_in">bin</span>桶在feature <span class="built_in">map</span>上的面积</span><br><span class="line">      Dtype bin_area = (hend - hstart)*(wend - wstart);</span><br><span class="line">	  // 若第(i,j)<span class="built_in">bin</span>桶宽高非法则设置为<span class="number">0</span>，否则为平均值</span><br><span class="line">      top_data[index] = is_empty? <span class="number">0.</span> : out_sum/bin_area;</span><br><span class="line">	  // 记录此次迭代计算ps feature <span class="built_in">map</span>上的索引位置</span><br><span class="line">      mapping_channel[index] = c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename Dtype&gt;</span><br><span class="line">  void PSROIPoolingLayer&lt;Dtype&gt;::Forward_gpu(</span><br><span class="line">	  const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,		// 以ResNet50为例，bottom[<span class="number">0</span>]为最后一个卷积层rfcn_cls产生的feature <span class="built_in">map</span>，shape[<span class="number">1</span>, <span class="number">1029</span>, <span class="number">14</span>, <span class="number">14</span>],</span><br><span class="line">	                                            //                 bottom[<span class="number">1</span>]为rois数据，shape[roi个数m, <span class="number">5</span>]</span><br><span class="line">	  const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;		// top为输出层结构， top-&gt;count() = top.n（RoI的个数) × top.channel(channel数)</span><br><span class="line">												//                               × top.w(输出feature <span class="built_in">map</span>的宽) × top.h(输出feature <span class="built_in">map</span>的高)</span><br><span class="line">    const Dtype* bottom_data = bottom[<span class="number">0</span>]-&gt;gpu_data();</span><br><span class="line">    const Dtype* bottom_rois = bottom[<span class="number">1</span>]-&gt;gpu_data();</span><br><span class="line">    Dtype* top_data = top[<span class="number">0</span>]-&gt;mutable_gpu_data();</span><br><span class="line">    <span class="built_in">int</span>* mapping_channel_ptr = mapping_channel_.mutable_gpu_data();</span><br><span class="line">    <span class="built_in">int</span> count = top[<span class="number">0</span>]-&gt;count();</span><br><span class="line">    caffe_gpu_set(count, Dtype(<span class="number">0</span>), top_data);</span><br><span class="line">    caffe_gpu_set(count, -<span class="number">1</span>, mapping_channel_ptr);</span><br><span class="line">    // NOLINT_NEXT_LINE(whitespace/operators)</span><br><span class="line">    PSROIPoolingForward&lt;Dtype&gt; &lt;&lt; &lt;CAFFE_GET_BLOCKS(count), CAFFE_CUDA_NUM_THREADS &gt;&gt; &gt;(</span><br><span class="line">      count, bottom_data, spatial_scale_, channels_, height_, width_, pooled_height_,</span><br><span class="line">      pooled_width_, bottom_rois, output_dim_, group_size_, top_data, mapping_channel_ptr);</span><br><span class="line">    CUDA_POST_KERNEL_CHECK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename Dtype&gt;</span><br><span class="line">  __global__ void PSROIPoolingBackwardAtomic(</span><br><span class="line">    const <span class="built_in">int</span> nthreads,						// 输入feature <span class="built_in">map</span>的元素数</span><br><span class="line">    const Dtype* top_diff,					// psroi pooling输出feature <span class="built_in">map</span>所带的梯度信息∂L/∂y(r,j)</span><br><span class="line">    const <span class="built_in">int</span>* mapping_channel,				// 同前向，不解释</span><br><span class="line">    const <span class="built_in">int</span> num_rois,						// 同前向，不解释</span><br><span class="line">    const Dtype spatial_scale,				// 同前向，不解释</span><br><span class="line">    const <span class="built_in">int</span> channels,						// 同前向，不解释</span><br><span class="line">    const <span class="built_in">int</span> height,						// 同前向，不解释</span><br><span class="line">	const <span class="built_in">int</span> width,						// 同前向，不解释</span><br><span class="line">    const <span class="built_in">int</span> pooled_height,				// 同前向，不解释</span><br><span class="line">	const <span class="built_in">int</span> pooled_width,					// 同前向，不解释</span><br><span class="line">    const <span class="built_in">int</span> output_dim,					// 同前向，不解释</span><br><span class="line">    Dtype* bottom_diff,						// 保留输入feature <span class="built_in">map</span>每个元素通过梯度反向传播得到的梯度信息</span><br><span class="line">    const Dtype* bottom_rois) &#123;				// 同前向，不解释</span><br><span class="line">	// 含义同前向，需要注意的是这里表示的是输入feature <span class="built_in">map</span>的元素数(反向传播嘛)</span><br><span class="line">    CUDA_KERNEL_LOOP(index, nthreads) &#123;</span><br><span class="line">      // 同前向，不解释</span><br><span class="line">      <span class="built_in">int</span> pw = index % pooled_width;</span><br><span class="line">      <span class="built_in">int</span> ph = (index / pooled_width) % pooled_height;</span><br><span class="line">      <span class="built_in">int</span> n = index / pooled_width / pooled_height / output_dim;</span><br><span class="line"></span><br><span class="line">      // 找原图RoI在feature <span class="built_in">map</span>上的映射位置，解释同前向传播</span><br><span class="line">      bottom_rois += n * <span class="number">5</span>;</span><br><span class="line">      <span class="built_in">int</span> roi_batch_ind = bottom_rois[<span class="number">0</span>];</span><br><span class="line">      Dtype roi_start_w = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">1</span>])) * spatial_scale;</span><br><span class="line">      Dtype roi_start_h = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">2</span>])) * spatial_scale;</span><br><span class="line">      Dtype roi_end_w = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">3</span>]) + <span class="number">1.</span>) * spatial_scale;</span><br><span class="line">      Dtype roi_end_h = static_cast&lt;Dtype&gt;(<span class="built_in">round</span>(bottom_rois[<span class="number">4</span>]) + <span class="number">1.</span>) * spatial_scale;</span><br><span class="line"></span><br><span class="line">      // 同前向</span><br><span class="line">      Dtype roi_width = <span class="built_in">max</span>(roi_end_w - roi_start_w, <span class="number">0.1</span>); //avoid <span class="number">0</span></span><br><span class="line">      Dtype roi_height = <span class="built_in">max</span>(roi_end_h - roi_start_h, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">      // 同前向</span><br><span class="line">      Dtype bin_size_h = roi_height / static_cast&lt;Dtype&gt;(pooled_height);</span><br><span class="line">      Dtype bin_size_w = roi_width / static_cast&lt;Dtype&gt;(pooled_width);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">int</span> hstart = floor(static_cast&lt;Dtype&gt;(ph)* bin_size_h</span><br><span class="line">        + roi_start_h);</span><br><span class="line">      <span class="built_in">int</span> wstart = floor(static_cast&lt;Dtype&gt;(pw)* bin_size_w</span><br><span class="line">        + roi_start_w);</span><br><span class="line">      <span class="built_in">int</span> hend = ceil(static_cast&lt;Dtype&gt;(ph + <span class="number">1</span>) * bin_size_h</span><br><span class="line">        + roi_start_h);</span><br><span class="line">      <span class="built_in">int</span> wend = ceil(static_cast&lt;Dtype&gt;(pw + <span class="number">1</span>) * bin_size_w</span><br><span class="line">        + roi_start_w);</span><br><span class="line">      // 同前向</span><br><span class="line">      hstart = <span class="built_in">min</span>(<span class="built_in">max</span>(hstart, <span class="number">0</span>), height);</span><br><span class="line">      hend = <span class="built_in">min</span>(<span class="built_in">max</span>(hend, <span class="number">0</span>), height);</span><br><span class="line">      wstart = <span class="built_in">min</span>(<span class="built_in">max</span>(wstart, <span class="number">0</span>), width);</span><br><span class="line">      wend = <span class="built_in">min</span>(<span class="built_in">max</span>(wend, <span class="number">0</span>), width);</span><br><span class="line">      <span class="built_in">bool</span> is_empty = (hend &lt;= hstart) || (wend &lt;= wstart);</span><br><span class="line"></span><br><span class="line">      // 计算第C类ps feature <span class="built_in">map</span>权重值，梯度信息会被平均分配</span><br><span class="line">      <span class="built_in">int</span> c = mapping_channel[index];</span><br><span class="line">      Dtype* offset_bottom_diff = bottom_diff + (roi_batch_ind * channels + c) * height * width;</span><br><span class="line">      Dtype bin_area = (hend - hstart)*(wend - wstart);</span><br><span class="line">      Dtype diff_val = is_empty ? <span class="number">0.</span> : top_diff[index] / bin_area;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> h = hstart; h &lt; hend; ++h)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = wstart; w &lt; wend; ++w)&#123;</span><br><span class="line">          <span class="built_in">int</span> bottom_index = h*width + w;</span><br><span class="line">          caffe_gpu_atomic_add(diff_val, offset_bottom_diff + bottom_index);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename Dtype&gt;</span><br><span class="line">  void PSROIPoolingLayer&lt;Dtype&gt;::Backward_gpu(</span><br><span class="line">	  const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,			// psroi pooling输出feature <span class="built_in">map</span></span><br><span class="line">	  const vector&lt;<span class="built_in">bool</span>&gt;&amp; propagate_down,		// 是否做反向传播，回忆前向传播时的那个<span class="built_in">bool</span>值</span><br><span class="line">	  const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) &#123;		// psroi pooling输入feature <span class="built_in">map</span>(ResNet中的rfcn_cls产生的feature <span class="built_in">map</span>)</span><br><span class="line">    <span class="keyword">if</span> (!propagate_down[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Dtype* bottom_rois = bottom[<span class="number">1</span>]-&gt;gpu_data();	// 原始RoI信息</span><br><span class="line">    const Dtype* top_diff = top[<span class="number">0</span>]-&gt;gpu_diff();			// psroi pooling feature <span class="built_in">map</span>梯度信息</span><br><span class="line">    Dtype* bottom_diff = bottom[<span class="number">0</span>]-&gt;mutable_gpu_diff();	// 待写入的输入feature <span class="built_in">map</span>梯度信息</span><br><span class="line">    const <span class="built_in">int</span> bottom_count = bottom[<span class="number">0</span>]-&gt;count();		// 输入feature <span class="built_in">map</span>元素总数</span><br><span class="line">    const <span class="built_in">int</span>* mapping_channel_ptr = mapping_channel_.gpu_data();</span><br><span class="line">    caffe_gpu_set(bottom[<span class="number">1</span>]-&gt;count(), Dtype(<span class="number">0</span>), bottom[<span class="number">1</span>]-&gt;mutable_gpu_diff());</span><br><span class="line">    caffe_gpu_set(bottom_count, Dtype(<span class="number">0</span>), bottom_diff);</span><br><span class="line">    const <span class="built_in">int</span> count = top[<span class="number">0</span>]-&gt;count();</span><br><span class="line">    // NOLINT_NEXT_LINE(whitespace/operators)</span><br><span class="line">    PSROIPoolingBackwardAtomic&lt;Dtype&gt; &lt;&lt; &lt;CAFFE_GET_BLOCKS(count), CAFFE_CUDA_NUM_THREADS &gt;&gt; &gt;(</span><br><span class="line">      count, top_diff, mapping_channel_ptr, top[<span class="number">0</span>]-&gt;num(), spatial_scale_,</span><br><span class="line">      channels_, height_, width_, pooled_height_, pooled_width_, output_dim_,</span><br><span class="line">      bottom_diff, bottom_rois);</span><br><span class="line">    CUDA_POST_KERNEL_CHECK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  INSTANTIATE_LAYER_GPU_FUNCS(PSROIPoolingLayer);</span><br><span class="line"></span><br><span class="line">&#125;  // namespace caffe</span><br></pre></td></tr></table></figure><ul><li>PS feature map可视化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- 2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Demo script showing detections in sample images.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">See README.md for installation instructions before running.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _init_paths</span><br><span class="line"><span class="keyword">from</span> fast_rcnn.config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">from</span> fast_rcnn.test <span class="keyword">import</span> im_detect</span><br><span class="line"><span class="keyword">from</span> fast_rcnn.nms_wrapper <span class="keyword">import</span> nms</span><br><span class="line"><span class="keyword">from</span> utils.timer <span class="keyword">import</span> Timer</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> caffe, os, sys, cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">CLASSES = (<span class="string">&#x27;__background__&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;aeroplane&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;diningtable&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;motorbike&#x27;</span>, <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;pottedplant&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;sofa&#x27;</span>, <span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;tvmonitor&#x27;</span>)</span><br><span class="line"></span><br><span class="line">NETS = &#123;<span class="string">&#x27;ResNet-101&#x27;</span>: (<span class="string">&#x27;ResNet-101&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;resnet101_rfcn_final.caffemodel&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;ResNet-50&#x27;</span>: (<span class="string">&#x27;ResNet-50&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;resnet50_rfcn_final.caffemodel&#x27;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_args</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse input arguments.&quot;&quot;&quot;</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Faster R-CNN demo&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--gpu&#x27;</span>, dest=<span class="string">&#x27;gpu_id&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;GPU device id to use [0]&#x27;</span>,</span><br><span class="line">                        default=<span class="number">0</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cpu&#x27;</span>, dest=<span class="string">&#x27;cpu_mode&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Use CPU mode (overrides --gpu)&#x27;</span>,</span><br><span class="line">                        action=<span class="string">&#x27;store_true&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--net&#x27;</span>, dest=<span class="string">&#x27;demo_net&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Network to use [ResNet-101]&#x27;</span>,</span><br><span class="line">                        choices=NETS.keys(), default=<span class="string">&#x27;ResNet-101&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vis_square</span>(<span class="params">data, i</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Take an array of shape (n, height, width) or (n, height, width, 3)</span></span><br><span class="line"><span class="string">       and visualize each (height, width) thing in a grid of size approx. sqrt(n) by sqrt(n)&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># normalize data for display</span></span><br><span class="line">    data = (data - data.<span class="built_in">min</span>()) / (data.<span class="built_in">max</span>() - data.<span class="built_in">min</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># force the number of filters to be square</span></span><br><span class="line">    n = <span class="built_in">int</span>(np.ceil(np.sqrt(data.shape[<span class="number">0</span>])))</span><br><span class="line">    padding = (((<span class="number">0</span>, n ** <span class="number">2</span> - data.shape[<span class="number">0</span>]),</span><br><span class="line">               (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>))                 <span class="comment"># add some space between filters</span></span><br><span class="line">               + ((<span class="number">0</span>, <span class="number">0</span>),) * (data.ndim - <span class="number">3</span>))  <span class="comment"># don&#x27;t pad the last dimension (if there is one)</span></span><br><span class="line">    data = np.pad(data, padding, mode=<span class="string">&#x27;constant&#x27;</span>, constant_values=<span class="number">1</span>)  <span class="comment"># pad with ones (white)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># tile the filters into an image</span></span><br><span class="line">    data = data.reshape((n, n) + data.shape[<span class="number">1</span>:]).transpose((<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>) + <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">4</span>, data.ndim + <span class="number">1</span>)))</span><br><span class="line">    data = data.reshape((n * data.shape[<span class="number">1</span>], n * data.shape[<span class="number">3</span>]) + data.shape[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">    plt.imshow(data); plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&#x27;feature-&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vis_demo</span>(<span class="params">net, image_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;可视化位置敏感特征图.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load the demo image</span></span><br><span class="line">    im_file = os.path.join(cfg.DATA_DIR, <span class="string">&#x27;demo&#x27;</span>, image_name)</span><br><span class="line">    im = cv2.imread(im_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Detect all object classes and regress object bounds</span></span><br><span class="line">    timer = Timer()</span><br><span class="line">    timer.tic()</span><br><span class="line">    scores, boxes = im_detect(net, im)</span><br><span class="line">    timer.toc()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;Detection took &#123;:.3f&#125;s for &#x27;</span></span><br><span class="line">           <span class="string">&#x27;&#123;:d&#125; object proposals&#x27;</span>).<span class="built_in">format</span>(timer.total_time, boxes.shape[<span class="number">0</span>])</span><br><span class="line">    conv = net.blobs[<span class="string">&#x27;data&#x27;</span>].data[<span class="number">0</span>]</span><br><span class="line">    ave = np.average(conv.transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), axis=<span class="number">2</span>)</span><br><span class="line">    plt.imshow(ave); plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&#x27;featurex.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Visualize detections for each class</span></span><br><span class="line">    CONF_THRESH = <span class="number">0.8</span></span><br><span class="line">    NMS_THRESH = <span class="number">0.3</span></span><br><span class="line">    <span class="keyword">for</span> cls_ind, cls <span class="keyword">in</span> <span class="built_in">enumerate</span>(CLASSES[<span class="number">1</span>:]):</span><br><span class="line">        cls_ind += <span class="number">1</span> <span class="comment"># because we skipped background</span></span><br><span class="line">        cls_boxes = boxes[:, <span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">        cls_scores = scores[:, cls_ind]</span><br><span class="line">        dets = np.hstack((cls_boxes,</span><br><span class="line">                          cls_scores[:, np.newaxis])).astype(np.float32)</span><br><span class="line">        keep = nms(dets, NMS_THRESH)</span><br><span class="line">        dets = dets[keep, :]</span><br><span class="line">        <span class="built_in">print</span> cls_ind, <span class="string">&#x27; &#x27;</span>, cls</span><br><span class="line">        <span class="comment"># rfcn_cls[0, 0:49] 是第0类的7×7map，rfcn_cls[0, 49:98] 是第1类的7×7map，以此类推。</span></span><br><span class="line">        feat = net.blobs[<span class="string">&#x27;rfcn_cls&#x27;</span>].data[<span class="number">0</span>, cls_ind*<span class="number">49</span>:(cls_ind+<span class="number">1</span>)*<span class="number">49</span>]</span><br><span class="line">        vis_square(feat, cls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cfg.TEST.HAS_RPN = <span class="literal">True</span>  <span class="comment"># Use RPN for proposals</span></span><br><span class="line"></span><br><span class="line">    args = parse_args()</span><br><span class="line"></span><br><span class="line">    prototxt = os.path.join(cfg.MODELS_DIR, NETS[args.demo_net][<span class="number">0</span>],</span><br><span class="line">                            <span class="string">&#x27;rfcn_end2end&#x27;</span>, <span class="string">&#x27;test_agnostic.prototxt&#x27;</span>)</span><br><span class="line">    caffemodel = os.path.join(cfg.DATA_DIR, <span class="string">&#x27;rfcn_models&#x27;</span>,</span><br><span class="line">                              NETS[args.demo_net][<span class="number">33</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(caffemodel):</span><br><span class="line">        <span class="keyword">raise</span> IOError((<span class="string">&#x27;&#123;:s&#125; not found.\n&#x27;</span>).<span class="built_in">format</span>(caffemodel))</span><br><span class="line">    <span class="keyword">if</span> args.cpu_mode:</span><br><span class="line">        caffe.set_mode_cpu()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        caffe.set_mode_gpu()</span><br><span class="line">        caffe.set_device(args.gpu_id)</span><br><span class="line">        cfg.GPU_ID = args.gpu_id</span><br><span class="line">    net = caffe.Net(prototxt, caffemodel, caffe.TEST)</span><br><span class="line">    <span class="keyword">for</span> layer_name, blob <span class="keyword">in</span> net.blobs.iteritems():</span><br><span class="line">        <span class="built_in">print</span> layer_name + <span class="string">&#x27;\t&#x27;</span> + <span class="built_in">str</span>(blob.data.shape)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\n\nLoaded network &#123;:s&#125;&#x27;</span>.<span class="built_in">format</span>(caffemodel)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Warmup on a dummy image</span></span><br><span class="line">    im = <span class="number">128</span> * np.ones((<span class="number">300</span>, <span class="number">500</span>, <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>):</span><br><span class="line">        _, _= im_detect(net, im)</span><br><span class="line">    im_names = [<span class="string">&#x27;car.jpg&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> im_name <span class="keyword">in</span> im_names:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Demo for data/demo/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(im_name)</span><br><span class="line">        vis_demo(net, im_name)</span><br><span class="line">    <span class="comment"># obtain the output probabilities</span></span><br><span class="line">    output_prob = net.blobs[<span class="string">&#x27;cls_prob&#x27;</span>].data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;probabilities:&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> output_prob</span><br></pre></td></tr></table></figure><h2 id="densenet">8.8 DenseNet</h2><h3 id="关于神经网络的深度">8.8.1 关于神经网络的深度</h3><p>理论上，当我们有足够大量的数据，能够完全体现当前问题的数据分布的时候，我们仅需要一个简单线性模型或最多用个有单隐层的RBF神经网络就可以完美建模。但实际情况是没有那么多数据，那就自然需要一个高复杂度的模型来拟合样本，但如果模型复杂度过高而样本数没有与其达到某种关系，又会造成其泛化性低下，所谓过拟合的问题。实际上，假设未来做testing的数据分布和training的数据分布是一致的，一个有<span class="math inline">\(N\)</span>个神经网络节点、<span class="math inline">\(W\)</span>个权重、线性阈值函数的前馈神经网络在泛化误差<span class="math inline">\(0&lt;\epsilon \le0.125\)</span>的前提下，训练数据规模的下界是：<span class="math inline">\(m\ge O(\frac{W}{\epsilon}log\frac{N}{\epsilon})\)</span>，详情可见论文《<a target="_blank" rel="noopener" href="https://papers.nips.cc/paper/154-what-size-net-gives-valid-generalization.pdf">What Size Net Gives Valid Generalization</a>》。</p><p>网络的深度则反映了模型的复杂度，深度直接决定了层数而间接影响了节点数和权重数，网络深度的增加意味着能得到更多的抽象特征，但原始输入信号和梯度信息会随着网络深度的增加而消失或无用，所以这又是一个折中权衡，像之前讲的Highway Network、ResNet及其衍生等等模型的思路是通过一个short path的连接让前一层的信号能够传递到后一层，我认为这个思路是开创性的。</p><h3 id="densenet思路">8.8.2 DenseNet思路</h3>《<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1608.06993">Densely Connected Convolutional Networks</a>》（CVPR 2017的最佳论文之一）提出的DenseNet则把ResNet的思路做的更加彻底：在一个Dense Block中，任意一个当前层都会与其后面的所有层直接连接，如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9b0b69pfu15spn1q1r8e3ug9.png" width="500"></center><p>假如包括当前层在内后面还有<span class="math inline">\(L\)</span>层，那么从当前层往后产生的直接连接数为：<span class="math inline">\(\frac{L(L+1)}{2}\)</span>。</p><p>回顾之前对ResNet的分析以及《<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1603.09382">Deep Networks with Stochastic Depth</a>》这篇论文的实验，可以得到以下信息：</p><p>神经网络不一定非得是逐层递进的，任意一层可以接收它前面任意一层的输入而扔掉它前面的其它层，也就是说当前层feature map的提取可以只依赖更前面层的feature map； 传统前馈神经网络架构可以被看做是有个状态维护机制，在层与层之间传递这个状态，后一层在接收前一层的状态后又加入自己的信息，修改状态后传给下一层； ResNet网络在路径选择的思想下展开（见ResNet一章的分析）后，其实也说明它有一定的冗余性，适当的随机Dropout一些层相当于扔掉了一些路径，实际实验看还会提高网络Inference的泛化性。</p><p>基于以上认知，作者设计了DenseNet：让每一层都与后面所有层直接连接，达到特征复用的目的；同时这些连接也可以看做网络的全局状态，大家共同维护，不用传来传去；降低每一层feature map数，让网络结构变“窄”，达到去除冗余的目的。</p><p>与ResNet比较：</p><ul><li><p>ResNet采用按照向量每个维度的Element-wise做加和的方式处理连接，而DenseNet采用按照每个通道的Channel-wise做直接向量拼接的方式处理连接。</p><center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9idtee10si1p1d1gvm1djp1uikm.png" width="800"></center><p><strong>PS：注意图中C操作符的位置</strong></p><p>DenseNet的前向传播过程可以像这样展开：</p><center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9ksjj1pmb1sa6cm92lv1pga52.png" width="800"></center><p>每一层的输入都包含所有前面层的feature map。</p><p>形式化的对比如下：</p><p>ResNet：第<span class="math inline">\(l\)</span>层的输出是<span class="math inline">\(x_l=H_l(x_{l-1})+x_{l-1}\)</span></p><p>DenseNet：第<span class="math inline">\(l\)</span>层的输出是<span class="math inline">\(x_l=H_l([x_0,x_1,...,x_{l-1}])\)</span></p>其中：<span class="math inline">\([]\)</span>为向量拼接操作，<span class="math inline">\(H_l\)</span>是一个复合函数，文中是batch normalization (BN)+rectified linear unit (ReLU)+3×3 convolution (Conv)的复合——BN(ReLU(Conv(x)))。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9l3s1j1ogm198q14ed1oc116fo5f.png" width="600"></center></li><li><p>dense blocks与transition layer DenseNet的拼接操作要求保证feature map大小具有一致性，但由于pooling下采样操作的存在一定会改变feature map的，所以作者用dense blocks+transition layers的方式解决问题：</p><p>1、dense blocks内部feature map大小都一致，借鉴Inception结构，利用bottleneck中的1×1卷积降低通道数，即 <strong>BN+ReLU+Conv(1x1)+BN+ReLU+Conv(3x3)</strong> 操作；</p>2、dense blocks之间增加transition layer，同样借鉴Inception结构，利用1×1卷积降低通道数，即<strong>BN+ReLU+Conv(1×1)+AvgPooling(2x2)</strong> 操作：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9m0fcunr3ou4143msh6160h5s.png" width="800"></center><p>transition layer可以起到压缩模型的作用：假设dense block有<span class="math inline">\(m\)</span>个feature map，我们让紧接着的transition layer产生<span class="math inline">\(\lfloor \theta m\rfloor\)</span>，这里<span class="math inline">\(0&lt;\theta\le1\)</span>为压缩系数。</p>宏观来看，整个DenseNet如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9mgbktmq3qm6tt17bd1g746p.png" width="800"></center></li><li>利用Growth Rate和复合函数，DenseNet可以做的很“窄”：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/k-growth.png" width="600"></center>假设每个<span class="math inline">\(H_l\)</span>复合函数产生<span class="math inline">\(k\)</span>个feature map，那么第<span class="math inline">\(l\)</span>层的输入feature map数为：<span class="math inline">\(k_0+k\times(l-1)\)</span> ，可见越往后的dense block输入feature map越多，当然由于全局feature map的存在，每层只有 <span class="math inline">\(k\)</span> 个feature map是独有的，其余的都共享。 显然，“窄”的好处是参数少、计算效率高，比较如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9ne9qt9661umllgh1pif1rgc76.png" width="800"></center></li><li>DenseNet结构使得特征更加具有多样性 显然，由于从高到低引入了不同复杂度的特征，使得最终做预测的特征具有很强的多样性，提高模型的泛化性和鲁棒性。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ck9q7n3n1mrnnh555lvddl087j.png" width="800"></center></li></ul><h3 id="代码实践-7">8.8.3 代码实践</h3>看一个基于keras的简单例子，比较好重现了DenseNet的构建，看的时候对照着DenseNet的前向展开图更好理解原理：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> keras.backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Input, merge, Activation, Dropout, Dense</span><br><span class="line"><span class="keyword">from</span> keras.layers.convolutional <span class="keyword">import</span> Convolution2D</span><br><span class="line"><span class="keyword">from</span> keras.layers.pooling <span class="keyword">import</span> AveragePooling2D, GlobalAveragePooling2D</span><br><span class="line"><span class="keyword">from</span> keras.layers.normalization <span class="keyword">import</span> BatchNormalization</span><br><span class="line"><span class="keyword">from</span> keras.regularizers <span class="keyword">import</span> l2</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> ModelCheckpoint</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加一层并使用复合函数BN+ReLU+Conv(3x3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span>(<span class="params">x, nb_channels, kernel_size=<span class="number">3</span>, dropout=<span class="number">0.</span>, l2_reg=<span class="number">1e-4</span></span>):</span></span><br><span class="line">    out = BatchNormalization(gamma_regularizer=l2(l2_reg),</span><br><span class="line">                             beta_regularizer=l2(l2_reg))(x)</span><br><span class="line">    out = Activation(<span class="string">&#x27;relu&#x27;</span>)(out)</span><br><span class="line">    out = Convolution2D(nb_channels, kernel_size, kernel_size,</span><br><span class="line">                        border_mode=<span class="string">&#x27;same&#x27;</span>, init=<span class="string">&#x27;he_normal&#x27;</span>,</span><br><span class="line">                        W_regularizer=l2(l2_reg), bias=<span class="literal">False</span>)(out)</span><br><span class="line">    <span class="keyword">if</span> dropout &gt; <span class="number">0</span>:</span><br><span class="line">        out = Dropout(dropout)(out)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定层数和增长率，增加一个dense block</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dense_block</span>(<span class="params">x, nb_layers, growth_rate, dropout=<span class="number">0.</span>, l2_reg=<span class="number">1e-4</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nb_layers):</span><br><span class="line">        <span class="comment"># Get layer output</span></span><br><span class="line">        out = add_layer(x, growth_rate, dropout=dropout, l2_reg=l2_reg)</span><br><span class="line">        <span class="keyword">if</span> K.image_dim_ordering() == <span class="string">&#x27;tf&#x27;</span>:</span><br><span class="line">            merge_axis = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> K.image_dim_ordering() == <span class="string">&#x27;th&#x27;</span>:</span><br><span class="line">            merge_axis = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Invalid dim_ordering: &#x27;</span> + K.image_dim_ordering())</span><br><span class="line">        <span class="comment"># Concatenate input with layer ouput</span></span><br><span class="line">        x = merge([x, out], mode=<span class="string">&#x27;concat&#x27;</span>, concat_axis=merge_axis)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加一个transition layer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transition_block</span>(<span class="params">x, nb_channels, dropout=<span class="number">0.</span>, l2_reg=<span class="number">1e-4</span></span>):</span></span><br><span class="line">    x = add_layer(x, nb_channels, kernel_size=<span class="number">1</span>, dropout=dropout, l2_reg=l2_reg)</span><br><span class="line">    x = AveragePooling2D()(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定dense block数量、层数、增长率，构建DenseNet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">densenet_model</span>(<span class="params">nb_blocks, nb_layers, growth_rate, dropout=<span class="number">0.</span>, l2_reg=<span class="number">1e-4</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   init_channels=<span class="number">16</span></span>):</span></span><br><span class="line">    n_channels = init_channels</span><br><span class="line">    inputs = Input(shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>))</span><br><span class="line">    x = Convolution2D(init_channels, <span class="number">3</span>, <span class="number">3</span>, border_mode=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                      init=<span class="string">&#x27;he_normal&#x27;</span>, W_regularizer=l2(l2_reg),</span><br><span class="line">                      bias=<span class="literal">False</span>)(inputs)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nb_blocks - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># Create a dense block</span></span><br><span class="line">        x = dense_block(x, nb_layers, growth_rate,</span><br><span class="line">                        dropout=dropout, l2_reg=l2_reg)</span><br><span class="line">        <span class="comment"># Update the number of channels</span></span><br><span class="line">        n_channels += nb_layers*growth_rate</span><br><span class="line">        <span class="comment"># Transition layer</span></span><br><span class="line">        x = transition_block(x, n_channels, dropout=dropout, l2_reg=l2_reg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add last dense_block</span></span><br><span class="line">    x = dense_block(x, nb_layers, growth_rate, dropout=dropout, l2_reg=l2_reg)</span><br><span class="line">    <span class="comment"># Add final BN-Relu</span></span><br><span class="line">    x = BatchNormalization(gamma_regularizer=l2(l2_reg),</span><br><span class="line">                             beta_regularizer=l2(l2_reg))(x)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># Global average pooling</span></span><br><span class="line">    x = GlobalAveragePooling2D()(x)</span><br><span class="line">    x = Dense(<span class="number">10</span>, W_regularizer=l2(l2_reg))(x)</span><br><span class="line">    x = Activation(<span class="string">&#x27;softmax&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    model = Model(<span class="built_in">input</span>=inputs, output=x)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#1个dense block，里面共2层，feature map数为3</span></span><br><span class="line">    model = densenet_model(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">from</span> keras.utils.vis_utils <span class="keyword">import</span> plot_model</span><br><span class="line">    plot_model(model, to_file=<span class="string">&quot;DenseNet.jpg&quot;</span>, show_shapes=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>生成网络结构为：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ckcktrsoqnj16k0103c1o78vbi80.png" width="600"></center>对应的前向展开为：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/image_1ckckvl6c1jofn1i10ji1666cr58d.png" width="500"></center><h2 id="mask-r-cnn">8.9 Mask R-CNN</h2><h3 id="算法概述-3">8.9.1 算法概述</h3>Mask R-CNN是何恺明等人在《<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1703.06870.pdf">Mask R-CNN</a>》一文中提出的一个简单的、扩展性较强的用于目标检测、识别、实例和语义分割的通用框架，可以看做是Faster R-CNN的升级加强版，结构上也可以理解为：把原有Faster R-CNN的RoIPooling层替换为RoIAlign层，并加了第三个用来预测Mask的分支，以支持pixel2pixel像素粒度的分类预测（语义分割）。 演化过程如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/a07ym-aobhi.png" width="800"></center>换个角度看整体结构如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/mask-rcnn.png" width="800"></center><h3 id="mask">8.9.2 Mask</h3><p>需要注意的是，在Mask任务分枝下，假设有<span class="math inline">\(K\)</span>个分类，则对每个RoI会针对所有<span class="math inline">\(K\)</span>个分类产生一个<span class="math inline">\(m×m\)</span>的binary masks（0或非0）预测图（即mask任务分支对每个RoI产生一个维度为<span class="math inline">\(Km^2\)</span>的输出）。</p><p>由于这种像素级的分割对空间位置信息很敏感，而原有的RoI Pooling大量使用了取整操作（文中叫做harsh quantization），从而使得RoI Pooling的输出产生位移，会和原图像上的RoI对不上（ps：分类操作本就对位置不敏感，所以不受这种位移影响），所以文中采用了RoI Align来改进，使得提高了mask预测精度提高了10%到50%。 查看8.5 Fast R-CNN的代码介绍也可以发现，做原图到feature map的映射时用了round四舍五入以及计算bin在feature map上的坐标范围时用了floor取整操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// rbgirshick/fast-rcnn对ROIPoolForward的实现：</span><br><span class="line">......</span><br><span class="line">// 原图到feature <span class="built_in">map</span>的映射为乘以<span class="number">1</span>/<span class="number">16</span>，这里采用粗映射.</span><br><span class="line"><span class="built_in">int</span> roi_start_w = <span class="built_in">round</span>(bottom_rois[<span class="number">1</span>] * spatial_scale);</span><br><span class="line"><span class="built_in">int</span> roi_start_h = <span class="built_in">round</span>(bottom_rois[<span class="number">2</span>] * spatial_scale);</span><br><span class="line"><span class="built_in">int</span> roi_end_w = <span class="built_in">round</span>(bottom_rois[<span class="number">3</span>] * spatial_scale);</span><br><span class="line"><span class="built_in">int</span> roi_end_h = <span class="built_in">round</span>(bottom_rois[<span class="number">4</span>] * spatial_scale);</span><br><span class="line">......</span><br><span class="line">// 计算第(i,j)个<span class="built_in">bin</span>桶在feature <span class="built_in">map</span>上的坐标范围，需要依据它们确定后续<span class="built_in">max</span> pooling的范围</span><br><span class="line"><span class="built_in">int</span> hstart = static_cast&lt;<span class="built_in">int</span>&gt;(floor(static_cast&lt;Dtype&gt;(ph) * bin_size_h));</span><br><span class="line"><span class="built_in">int</span> wstart = static_cast&lt;<span class="built_in">int</span>&gt;(floor(static_cast&lt;Dtype&gt;(pw) * bin_size_w));</span><br><span class="line"><span class="built_in">int</span> hend = static_cast&lt;<span class="built_in">int</span>&gt;(ceil(static_cast&lt;Dtype&gt;(ph + <span class="number">1</span>) * bin_size_h));</span><br><span class="line"><span class="built_in">int</span> wend = static_cast&lt;<span class="built_in">int</span>&gt;(ceil(static_cast&lt;Dtype&gt;(pw + <span class="number">1</span>) * bin_size_w));</span><br></pre></td></tr></table></figure><p></p><h3 id="roialign">8.9.3 RoIAlign</h3><ul><li>图像的仿射变换 在图像处理中经常会用仿射变换去做各种图像处理，用数学表达为 ： 假设，<span class="math inline">\(x,y\)</span>是原始图像中某一点的位置，<span class="math inline">\(x^*,y^*\)</span>是做了图像变换后该点的位置，则这个变换过程表示为： <span class="math display">\[ \begin{bmatrix} x^* \\ y^* \end{bmatrix} =\begin{bmatrix} v_{11} &amp; v_{12} &amp; v_{13} \\ v_{21} &amp; v_{22} &amp; v_{23} \end{bmatrix} \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} \]</span> 假设有以下500×500图片：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/me.jpeg" width="300"></center><p>以opencv中的仿射变换为例，常用的变换有：</p><table><colgroup><col style="width:30%"><col style="width:26%"><col style="width:23%"><col style="width:19%"></colgroup><thead><tr class="header"><th>变换</th><th style="text-align:center">变换矩阵</th><th style="text-align:center">例子</th><th style="text-align:right">效果</th></tr></thead><tbody><tr class="odd"><td>恒等(Identity)</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:right"><img src="https://vivounicorn.github.io/images/ai_chapter_8/Identity.png" width="300"></td></tr><tr class="even"><td>平移(Translation)</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; v_{13}\geq 0 \\0 &amp; 1 &amp; v_{23}\geq 0 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 30 \\ 0 &amp; 1 &amp; 30 \end{bmatrix}\)</span></td><td style="text-align:right"><img src="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png" width="300"></td></tr><tr class="odd"><td>镜像(Reflection)</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} -1 &amp; 0 &amp; v_{13}\geq 0 \\ 0 &amp; 1 &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} -1 &amp; 0 &amp; 500 \\ 0 &amp; 1 &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:right"><img src="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png" width="300"></td></tr><tr class="even"><td>缩放(Scale)</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} v_{11} &amp; 0 &amp; 0 \\ 0 &amp; v_{22} &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1.5 &amp; 0 &amp; 0 \\ 0 &amp; 1.5 &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:right"><img src="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png" width="300"></td></tr><tr class="odd"><td>旋转(Rotate)</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} v_{11}=cos(\theta) &amp; v_{12}=-sin(\theta) &amp; 0 \\ v_{21}=sin(\theta) &amp; v_{22}=cos(\theta) &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 0.866 &amp; -0.5 &amp; 0 \\ 0.5 &amp; 0.866 &amp; 0 \end{bmatrix}_{\theta=\frac{\pi}{6}=30^\circ}\)</span></td><td style="text-align:right"><img src="https://vivounicorn.github.io/images/ai_chapter_8/Rotate.png" width="500"></td></tr><tr class="even"><td>剪切(Shear)</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; v_{12} &amp; 0 \\ v_{21} &amp;1 &amp;0 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0.5 &amp; 0 \\ 0.5 &amp; 1 &amp; 0 \end{bmatrix}\)</span></td><td style="text-align:right"><img src="https://vivounicorn.github.io/images/ai_chapter_8/Translation.png" width="300"></td></tr></tbody></table><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_transformation</span>(<span class="params">file_name, T</span>):</span></span><br><span class="line">    img = cv2.imread(file_name)</span><br><span class="line">    new_img = cv2.warpAffine(img, T, img.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.imshow(new_img)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像</span></span><br><span class="line">T1 = np.float32([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">500</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 恒等</span></span><br><span class="line">T2 = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># x和y同时平移平移</span></span><br><span class="line">T3 = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">30</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">30</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩放</span></span><br><span class="line">T4 = np.float32([[<span class="number">1.5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1.5</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 旋转</span></span><br><span class="line">T5 = np.float32([[<span class="number">0.866</span>, -<span class="number">0.5</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0.5</span>, <span class="number">0.866</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 剪切</span></span><br><span class="line">T6 = np.float32([[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">image_transformation(<span class="string">&#x27;me.jpeg&#x27;</span>, T1)</span><br><span class="line">image_transformation(<span class="string">&#x27;me.jpeg&#x27;</span>, T2)</span><br><span class="line">image_transformation(<span class="string">&#x27;me.jpeg&#x27;</span>, T3)</span><br><span class="line">image_transformation(<span class="string">&#x27;me.jpeg&#x27;</span>, T4)</span><br><span class="line">image_transformation(<span class="string">&#x27;me.jpeg&#x27;</span>, T5)</span><br><span class="line">image_transformation(<span class="string">&#x27;me.jpeg&#x27;</span>, T6)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p></li><li>线性插值 在要求没那么高的场景中，为了弥补相近两个数据中间缺失的数据，常常采用线性插值法，即假设两点之间的数据分布为线性分布，显然如果曲线曲率越大，线性插值的误差越大。 形式化表示如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/Linear_interpolation.png" width="300"></center><center><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">wikipedia</a></p></center><p>假设：已知坐标 <span class="math inline">\((x_0, y_0)\)</span> 和 <span class="math inline">\((x_1, y_1)\)</span>，要在两点间插入一点<span class="math inline">\((x,y)\)</span>作为补充数据，其中<span class="math inline">\(x\)</span>的值已指定，则<span class="math inline">\(y\)</span>的值为： <span class="math display">\[ \frac{y-y_0}{x-x_0}=\frac{y_1-y_0}{x_1-x_0} \]</span> 得到： <span class="math display">\[ \begin{align*} y&amp;=y_0+\frac{x-x_0}{x_1-x_0}y_1-\frac{x-x_0}{x_1-x_0}y_0\\ &amp;=\frac{x-x_0}{x_1-x_0}y_1+\frac{x_1-x}{x_1-x_0}y_0 \end{align*} \]</span></p></li><li>双线性插值 双线性插值是对线性插值在二维上的扩展，基本思想是利用某点周围的四个点估计出该点的值，形式化表示如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/Bilinear_interpolation.png" width="300"></center><center><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">wikipedia</a></p></center><p>问题：想得到未知函数<span class="math inline">\(f\)</span>在点<span class="math inline">\(P(x,y)\)</span>的值。（以图像为例：已知图像上某个位置，想得到在这个位置的灰度值）</p><p>假设：已知函数<span class="math inline">\(f\)</span>在<span class="math inline">\(P\)</span>点 <strong><em>周围</em></strong> 四个点的函数值：<span class="math inline">\(Q_{11}=(x_1,y_1)\)</span>、<span class="math inline">\(Q_{12}=(x_1,y_2)\)</span>、<span class="math inline">\(Q_{21}=(x_2,y_1)\)</span>、<span class="math inline">\(Q_{22}=(x_2,y_2)\)</span>。（以图像为例：“周围隐含<span class="math inline">\(x_2-x_1=1\)</span>且<span class="math inline">\(y_2-y_1=1\)</span>）</p><p>则：双线性插值会先在<span class="math inline">\(x\)</span>轴方向做线性插值2次，后在<span class="math inline">\(y\)</span>轴方向做线性插值1次，从而得到目标值。（ps：效果等同于在<span class="math inline">\(y\)</span>轴方向插值2次，后在<span class="math inline">\(x\)</span>轴方向插值1次） 即:在<span class="math inline">\(x\)</span>轴方向做线性插值2次得到， <span class="math display">\[ \begin{align*} f(R_1)=f(x,y_1)&amp;=\frac{x_2-x}{x_2-x_1}f(Q_{11})+\frac{x-x_1}{x_2-x_1}f(Q_{21})\\ f(R_2)=f(x,y_2)&amp;=\frac{x_2-x}{x_2-x_1}f(Q_{12})+\frac{x-x_1}{x_2-x_1}f(Q_{22}) \end{align*} \]</span> 在<span class="math inline">\(y\)</span>轴方向做线性插值1次得到， <span class="math display">\[ \begin{align*} f(P)=f(x,y)&amp;=\frac{y_2-y}{y_2-y_1}f(R_{1})+\frac{y-y_1}{y_2-y_1}f(R_{2})\\ &amp;=\frac{y_2-y}{y_2-y_1}(\frac{x_2-x}{x_2-x_1}f(Q_{11})+\frac{x-x_1}{x_2-x_1}f(Q_{21}))+\frac{y-y_1}{y_2-y_1}(\frac{x_2-x}{x_2-x_1}f(Q_{12})+\frac{x-x_1}{x_2-x_1}f(Q_{22}))\\ &amp;=\frac{1}{(x_2-x_1)(y_2-y_1)}(f(Q_{11})\underbrace{(x_2-x)(y_2-y)}_{w_{11}}+f(Q_{21})\underbrace{(x-x_1)(y_2-y)}_{w_{21}}+f(Q_{12})\underbrace{(x_2-x)(y-y_1)}_{w_{12}}+f(Q_{22})\underbrace{(x-x_1)(y-y_1)}_{w_{22}})\\ \end{align*} \]</span></p><p>细心的读者一定已经发现：插值后的<span class="math inline">\(P\)</span>点取值也可以看做是周围4个点取值的线性加权之和，且权重：<span class="math inline">\(w_{11}+w_{21}+w_{12}+w_{22}=1\)</span> 上式表达为矩阵形式为： <span class="math display">\[ f(x,y)=\frac{1}{(x_2-x_1)(y_2-y_1)}\begin{bmatrix} x_2-x &amp; x-x_1 \end{bmatrix}\cdot \begin{bmatrix} f(Q_{11}) &amp; f(Q_{12}) \\ f(Q_{21}) &amp; f(Q_{22}) \end{bmatrix} \cdot \begin{bmatrix} y_2-y \\ y-y_1 \end{bmatrix} \]</span></p><p>在图像矩阵上利用某点周围四个点的灰度值估计该点灰度值时，上式简化为矩阵形式： <span class="math display">\[ f(P)=f(x,y)=\begin{bmatrix} x_1+1-x &amp; x-x_1 \end{bmatrix}\cdot \begin{bmatrix} f(Q_{11}) &amp; f(Q_{12}) \\ f(Q_{21}) &amp; f(Q_{22}) \end{bmatrix} \cdot \begin{bmatrix} y_1+1-y \\ y-y_1 \end{bmatrix} \]</span> 或等式： <span class="math display">\[ f(x,y)=\sum_{i=1}^{2}\sum_{j=1}^{2}f(x_i,y_j)max(0,1-|x-x_i|)max(0,1-|y-y_i|)\tag{1} \]</span></p></li><li>RoIAlign 不管RoI Pooling还是RoI Align，都是为了把任意大小的RoI（注意这里不是bounding box）区域映射为相同固定大小的输出，前者由于量化误差的存在（四舍五入或取整），导致边界上的数据丢失，从而会使得RoI的边界从原图映射到Feature Map后出现偏离，如下图：<center><p><img src="https://vivounicorn.github.io/images/ai_chapter_8/RoiPooling.png" width="600"></p>绿色为RoI映射后的理论边界，蓝色为实际边界</center>这种偏离对分类问题无影响（忽略精确的边界信息反而会提高分类准确率），但对语义分割确影响比较大（因为每个像素都要分类，所以精确的空间位置信息很重要），作者使用RoIAlign后可以使mask的精度提高10%~50%。 具体做法使用了:《<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1506.02025.pdf">Spatial Transformer Networks</a>》一文介绍的双线性插值方法，如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/STN.png" width="600"></center><p>基本过程如下：</p><strong>1、保留边界</strong>，对边界不做量化操作，保持浮点数边界，并将RoI分为<span class="math inline">\(H×W\)</span>(如3×3)的个子网格（Bin），每个子网格的边界也保留浮点数边界，即：我们不需要处理位置“坐标”，只需要处理“值”（相比较，RoIPooling做了两次量化：一次是原图映射到Feature Map时，一次是划分bin做Pooling时）：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/RoiAligngrid.png" width="600"></center><strong>2、采样与插值</strong>，整体示意图如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/RoiAlignsimple.png" width="800"></center><p>每个Bin取4个规则的采样点，采样方法如下： <span class="math display">\[ \begin{align*} x&amp;=x_l+(i + 0.5)\frac{x_h-x_l}{n}\tag{2.1}\\ y&amp;=y_l+(j + 0.5)\frac{y_h-y_l}{n}\tag{2.2}\\ n&amp;=number \quad of \quad samples.\\ i,j&amp;=0,...,n \end{align*} \]</span> 对应上图中：<span class="math inline">\(x_l=min(x_1,x_2)\)</span>、<span class="math inline">\(x_h=max(x_1,x_2)\)</span>、<span class="math inline">\(y_l=min(y_1,y_2)\)</span>、<span class="math inline">\(y_h=max(y_1,y_2)\)</span>，当<span class="math inline">\(n=2\)</span>时，每个Bin采样后得到图中4个采样点(绿点)。</p>然后对每个采样点(以红点标注的那个采样点<span class="math inline">\(P\)</span>点为例)取周围4个点得到2×2个子区域，取每个子区域的中点（途中黑色的<span class="math inline">\(Q_{11}、Q_{12}、Q_{21}、Q_{22}\)</span>点）做双线性插值，得到该采样点<span class="math inline">\(P\)</span>处的值。<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/RoiAlignmax.png" width="800"></center></li><li>原理及细节说明 上面的描述比较抽象，现在我们看个例子帮助大家理解： 1、假设输入原图为<strong>512×512</strong>，以<strong>stride=32</strong>，产生的feature map为<strong>16×16</strong>，每个RoI会被处理输出为一个固定大小的<strong>3×3</strong>的feature map:<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/roialign_org.png" width="800"></center>2、以图中最下方的RoI为示例对象，假设其最左上角坐标为：<span class="math inline">\((5.26, 9.33)\)</span>，<span class="math inline">\(width=\frac{200}{32}=6.25\)</span>，<span class="math inline">\(height=\frac{185}{32}=5.78\)</span>，如下图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/roialign_roi.png" width="800"></center>3、显然边界坐标都不是整数，传统的RoI Pooling会做量化，把边界信息丢失，而使用RoIAlign不需要做这种量化。根据输出feature map 3× 3的大小要求，RoI会被划分为9个bin，如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/roialign_fm.png" width="800"></center>4、每个bin会做<span class="math inline">\(n\)</span>个点的抽样（文中<span class="math inline">\(n=2\)</span>），具体抽样方法为<strong><em>公式：2.1-2.2</em></strong>，抽样后如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/roialign_sample.png" width="800"></center>5、以图中标红抽样点为例，在feature map上获取距离其最近的4个近邻点，使用双线性插值得到该点的值，如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/roialign_ex.png" width="800"></center>6、对所有bin里的所有抽样点做上述估计，如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/roialign_all.png" width="800"></center>7、使用max或avg pooling得到输出feature map，如图：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/roialign_out.png" width="800"></center><p>以上为RoIAlign整个过程的过程模拟，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x_low, y_low, x_high, y_high, sample_num</span>):</span></span><br><span class="line">        self.x_low = x_low</span><br><span class="line">        self.y_low = y_low</span><br><span class="line">        self.x_high = x_high</span><br><span class="line">        self.y_high = y_high</span><br><span class="line">        self.sample_num = sample_num</span><br><span class="line">        <span class="comment"># sample_list的index和nearest_four的index一一对应，代表每个采样点附近最近的4个点</span></span><br><span class="line">        self.sample_list = []</span><br><span class="line">        self.nearest_four = []</span><br><span class="line">        self._generate_sample_point()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对某个bin做数据采样</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_sample_point</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.sample_num):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.sample_num):</span><br><span class="line">                x = self.x_low + (i + <span class="number">0.5</span>) * (self.x_high - self.x_low) / self.sample_num</span><br><span class="line">                y = self.y_low + (j + <span class="number">0.5</span>) * (self.y_high - self.y_low) / self.sample_num</span><br><span class="line">                self.sample_list.append((x, y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印某个bin里的所有采样点的位置坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_sample_points</span>(<span class="params">self, idx=<span class="number">0</span>, is_print_position=<span class="literal">True</span>, is_difference_marker=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.sample_list)):</span><br><span class="line">            (x, y) = self.sample_list[i]</span><br><span class="line">            <span class="keyword">if</span> i == idx:</span><br><span class="line">                clr = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">                mkr = <span class="string">&#x27;o&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                clr = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">                mkr = <span class="string">&#x27;v&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_difference_marker:</span><br><span class="line">                clr = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">                mkr = <span class="string">&#x27;o&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_print_position:</span><br><span class="line">                plt.text(x, y, <span class="string">&quot;(%.2f,%.2f)&quot;</span> % (x, y), fontsize=<span class="number">15</span>, color=clr)</span><br><span class="line"></span><br><span class="line">            plt.plot(x, y, marker=mkr, color=clr, markersize=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoiAlign</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, left_top, width_height, matrix, sample_num=<span class="number">2</span>, feature_map_size=(<span class="params"><span class="number">3</span>, <span class="number">3</span></span>)</span>):</span></span><br><span class="line">        self.fig = plt.figure(figsize=(<span class="number">50</span>, <span class="number">50</span>))</span><br><span class="line">        self.ax = self.fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.ax.xaxis.set_ticks_position(<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">        self.ax.invert_yaxis()</span><br><span class="line"></span><br><span class="line">        self.sample_num = sample_num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(matrix.shape) == <span class="number">2</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(feature_map_size) == <span class="number">2</span></span><br><span class="line">        self.matrix = matrix</span><br><span class="line">        self.in_shape = matrix.shape</span><br><span class="line">        self.out_shape = feature_map_size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(left_top) == <span class="number">2</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(width_height) == <span class="number">2</span></span><br><span class="line">        self.x_low = left_top[<span class="number">0</span>]</span><br><span class="line">        self.y_low = left_top[<span class="number">1</span>]</span><br><span class="line">        self.width = width_height[<span class="number">0</span>]</span><br><span class="line">        self.height = width_height[<span class="number">1</span>]</span><br><span class="line">        self.width = width_height[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        self.bins = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印整个feature map</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_matrix</span>(<span class="params">self</span>):</span></span><br><span class="line">        plt.pcolormesh(self.matrix, cmap=<span class="string">&#x27;PuBu_r&#x27;</span>, shading=<span class="string">&#x27;flat&#x27;</span>, edgecolors=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">        w = self.in_shape[<span class="number">0</span>]</span><br><span class="line">        h = self.in_shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">                plt.text((j + <span class="number">0.5</span>), (i + <span class="number">0.5</span>), self.matrix[i][j], fontsize=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到某个bin的某个采样点周围的所有4个最近邻点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_all_nearest_points</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.bins) &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.bins)):</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">len</span>(self.bins[i].sample_list) &gt; <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> self.bins[i].sample_list:</span><br><span class="line">                self.bins[i].nearest_four.append(self.find_nearest_point(x, y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在输入feature map上找到某个bin中的采样点(x,y)的4个最近邻点，并对该点做双线性插值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_nearest_point</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        y_l, y_h = np.floor(y).astype(<span class="string">&#x27;int32&#x27;</span>), np.ceil(y).astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line">        x_l, x_h = np.floor(x).astype(<span class="string">&#x27;int32&#x27;</span>), np.ceil(x).astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        a = self.matrix[y_l, x_l]</span><br><span class="line">        b = self.matrix[y_l, x_h]</span><br><span class="line">        c = self.matrix[y_h, x_l]</span><br><span class="line">        d = self.matrix[y_h, x_h]</span><br><span class="line"></span><br><span class="line">        y_weight = y - y_l</span><br><span class="line">        x_weight = x - x_l</span><br><span class="line"></span><br><span class="line">        val = a * (<span class="number">1</span> - x_weight) * (<span class="number">1</span> - y_weight) + \</span><br><span class="line">              b * x_weight * (<span class="number">1</span> - y_weight) + \</span><br><span class="line">              c * y_weight * (<span class="number">1</span> - x_weight) + \</span><br><span class="line">              d * x_weight * y_weight</span><br><span class="line">        <span class="keyword">return</span> [(x_l, y_l), (x_h, y_l), (x_l, y_h), (x_h, y_h), val]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印RoI及其宽度、高度、和最左上角位置坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_roi</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        x_l = self.x_low</span><br><span class="line">        y_l = self.y_low</span><br><span class="line">        width = self.width</span><br><span class="line">        height = self.height</span><br><span class="line">        self.ax.add_patch(plt.Rectangle((x_l, y_l), width, height, fill=<span class="literal">False</span>, edgecolor=<span class="string">&#x27;red&#x27;</span>, linewidth=<span class="number">5</span>))</span><br><span class="line">        plt.plot(x_l, y_l, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line">        plt.text(x_l - <span class="number">0.5</span>, y_l - <span class="number">0.1</span>, <span class="string">&quot;(&#123;&#125;,&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(x_l, y_l), fontsize=<span class="number">30</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        plt.text(x_l + width / <span class="number">2</span>, y_l - <span class="number">0.2</span>, <span class="string">&quot;width=%.2f&quot;</span> % width, fontsize=<span class="number">30</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        plt.text(x_l - <span class="number">0.25</span>, y_l + height / <span class="number">2</span> + <span class="number">1</span>, <span class="string">&quot;height=%.2f&quot;</span> % height, rotation=<span class="string">&#x27;vertical&#x27;</span>, fontsize=<span class="number">30</span>,</span><br><span class="line">                 color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        x_split = width / self.out_shape[<span class="number">0</span>]</span><br><span class="line">        y_split = height / self.out_shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.out_shape[<span class="number">0</span>]):</span><br><span class="line">            plt.plot([x_l + i * x_split, x_l + i * x_split], [y_l, y_l + height], color=<span class="string">&#x27;yellow&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.out_shape[<span class="number">1</span>]):</span><br><span class="line">            plt.plot([x_l, x_l + width], [y_l + j * y_split, y_l + j * y_split], color=<span class="string">&#x27;yellow&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.out_shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.out_shape[<span class="number">1</span>]):</span><br><span class="line">                bin_split = Bin(self.x_low + i * x_split, self.y_low + j * y_split,</span><br><span class="line">                                self.x_low + (i + <span class="number">1</span>) * x_split, self.y_low + (j + <span class="number">1</span>) * y_split,</span><br><span class="line">                                self.sample_num)</span><br><span class="line"></span><br><span class="line">                self.bins.append(bin_split)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印某个bin或者RoI内所有bin的采样点，并对第j（从上到下、从左到右编号）个采样点涂抹不同颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_bins</span>(<span class="params">self, i=<span class="number">0</span>, j=<span class="number">0</span>, is_print_all=<span class="literal">True</span>, is_print_position=<span class="literal">True</span>, is_difference_marker=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_print_all:</span><br><span class="line">            self.bins[i].print_sample_points(idx=j, is_print_position=is_print_position,</span><br><span class="line">                                             is_difference_marker=is_difference_marker)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">bin</span> <span class="keyword">in</span> self.bins:</span><br><span class="line">                <span class="built_in">bin</span>.print_sample_points(idx=j, is_print_position=is_print_position,</span><br><span class="line">                                        is_difference_marker=is_difference_marker)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印所有bin里的每个采样点的4个最近邻点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_all_bins_nearest_four</span>(<span class="params">self, is_print_4sample=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> s_bin <span class="keyword">in</span> self.bins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s_bin.nearest_four)):</span><br><span class="line">                tuple_five = s_bin.nearest_four[i]</span><br><span class="line">                cur = s_bin.sample_list[i]</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">len</span>(tuple_five) == <span class="number">5</span></span><br><span class="line">                q11 = tuple_five[<span class="number">0</span>]</span><br><span class="line">                q21 = tuple_five[<span class="number">1</span>]</span><br><span class="line">                q12 = tuple_five[<span class="number">2</span>]</span><br><span class="line">                q22 = tuple_five[<span class="number">3</span>]</span><br><span class="line">                val = tuple_five[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> is_print_4sample:</span><br><span class="line">                    plt.plot(q11[<span class="number">0</span>] + <span class="number">0.5</span>, q11[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line">                    plt.plot(q21[<span class="number">0</span>] + <span class="number">0.5</span>, q21[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;yellow&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line">                    plt.plot(q12[<span class="number">0</span>] + <span class="number">0.5</span>, q12[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line">                    plt.plot(q22[<span class="number">0</span>] + <span class="number">0.5</span>, q22[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">                plt.text(cur[<span class="number">0</span>] + <span class="number">0.1</span>, cur[<span class="number">1</span>] + <span class="number">0.2</span>, <span class="string">&quot;%.2f&quot;</span> % val, fontsize=<span class="number">20</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印第i（从上到下、从左到右编号）个bin，第j（从上到下、从左到右编号）个采样点的4个最近邻点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_single_bin_sample</span>(<span class="params">self, is_print_4sample=<span class="literal">True</span>, i=<span class="number">0</span>, j=<span class="number">0</span></span>):</span></span><br><span class="line">        tuple_five = self.bins[i].nearest_four[j]</span><br><span class="line">        cur = self.bins[i].sample_list[j]</span><br><span class="line"></span><br><span class="line">        q11 = tuple_five[<span class="number">0</span>]</span><br><span class="line">        q21 = tuple_five[<span class="number">1</span>]</span><br><span class="line">        q12 = tuple_five[<span class="number">2</span>]</span><br><span class="line">        q22 = tuple_five[<span class="number">3</span>]</span><br><span class="line">        val = tuple_five[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> is_print_4sample:</span><br><span class="line">            plt.plot(q11[<span class="number">0</span>] + <span class="number">0.5</span>, q11[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line">            plt.plot(q21[<span class="number">0</span>] + <span class="number">0.5</span>, q21[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;yellow&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line">            plt.plot(q12[<span class="number">0</span>] + <span class="number">0.5</span>, q12[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line">            plt.plot(q22[<span class="number">0</span>] + <span class="number">0.5</span>, q22[<span class="number">1</span>] + <span class="number">0.5</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>, markersize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">        plt.text(cur[<span class="number">0</span>] + <span class="number">0.1</span>, cur[<span class="number">1</span>] + <span class="number">0.2</span>, <span class="string">&quot;%.2f&quot;</span> % val, fontsize=<span class="number">20</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行max pooling或者average pooling.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_pooling</span>(<span class="params">self, max_or_avg=<span class="string">&#x27;max&#x27;</span></span>):</span></span><br><span class="line">        out_feature_map = np.zeros(self.out_shape)</span><br><span class="line">        w = self.out_shape[<span class="number">0</span>]</span><br><span class="line">        h = self.out_shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.bins) == w * h</span><br><span class="line"></span><br><span class="line">        bin_pooling = []</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">bin</span> <span class="keyword">in</span> self.bins:</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> tuple_five <span class="keyword">in</span> <span class="built_in">bin</span>.nearest_four:</span><br><span class="line">                res.append(tuple_five[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> max_or_avg == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                bin_pooling.append(np.<span class="built_in">max</span>(res))</span><br><span class="line">            <span class="keyword">elif</span> max_or_avg == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                bin_pooling.append(np.around(np.mean(res).astype(<span class="string">&#x27;float&#x27;</span>), <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">                out_feature_map[j, i] = np.around(bin_pooling[i * w + j], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">        ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        ax.xaxis.set_ticks_position(<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">        ax.invert_yaxis()</span><br><span class="line">        plt.pcolormesh(out_feature_map, cmap=<span class="string">&#x27;PuBu_r&#x27;</span>, shading=<span class="string">&#x27;flat&#x27;</span>, edgecolors=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">                plt.text((i + <span class="number">0.5</span>), (j + <span class="number">0.5</span>), out_feature_map[j][i], fontsize=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fm = np.array([[<span class="number">28</span>, <span class="number">148</span>, <span class="number">175</span>, <span class="number">42</span>, <span class="number">71</span>, <span class="number">121</span>, <span class="number">68</span>, <span class="number">52</span>, <span class="number">157</span>, <span class="number">65</span>, <span class="number">62</span>, <span class="number">15</span>, <span class="number">182</span>, <span class="number">210</span>, <span class="number">39</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">81</span>, <span class="number">209</span>, <span class="number">97</span>, <span class="number">200</span>, <span class="number">194</span>, <span class="number">11</span>, <span class="number">37</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">200</span>, <span class="number">104</span>, <span class="number">244</span>, <span class="number">43</span>, <span class="number">225</span>, <span class="number">192</span>, <span class="number">25</span>],</span><br><span class="line">                   [<span class="number">42</span>, <span class="number">189</span>, <span class="number">120</span>, <span class="number">52</span>, <span class="number">198</span>, <span class="number">180</span>, <span class="number">88</span>, <span class="number">23</span>, <span class="number">60</span>, <span class="number">178</span>, <span class="number">103</span>, <span class="number">2</span>, <span class="number">90</span>, <span class="number">32</span>, <span class="number">215</span>, <span class="number">86</span>],</span><br><span class="line">                   [<span class="number">60</span>, <span class="number">47</span>, <span class="number">211</span>, <span class="number">106</span>, <span class="number">118</span>, <span class="number">99</span>, <span class="number">28</span>, <span class="number">230</span>, <span class="number">99</span>, <span class="number">94</span>, <span class="number">237</span>, <span class="number">116</span>, <span class="number">172</span>, <span class="number">135</span>, <span class="number">201</span>, <span class="number">175</span>],</span><br><span class="line">                   [<span class="number">105</span>, <span class="number">250</span>, <span class="number">226</span>, <span class="number">142</span>, <span class="number">39</span>, <span class="number">148</span>, <span class="number">137</span>, <span class="number">43</span>, <span class="number">133</span>, <span class="number">254</span>, <span class="number">59</span>, <span class="number">180</span>, <span class="number">72</span>, <span class="number">79</span>, <span class="number">112</span>, <span class="number">187</span>],</span><br><span class="line">                   [<span class="number">153</span>, <span class="number">177</span>, <span class="number">48</span>, <span class="number">76</span>, <span class="number">198</span>, <span class="number">237</span>, <span class="number">133</span>, <span class="number">97</span>, <span class="number">137</span>, <span class="number">60</span>, <span class="number">78</span>, <span class="number">62</span>, <span class="number">83</span>, <span class="number">101</span>, <span class="number">169</span>, <span class="number">5</span>],</span><br><span class="line">                   [<span class="number">252</span>, <span class="number">167</span>, <span class="number">27</span>, <span class="number">8</span>, <span class="number">200</span>, <span class="number">72</span>, <span class="number">132</span>, <span class="number">171</span>, <span class="number">111</span>, <span class="number">137</span>, <span class="number">150</span>, <span class="number">116</span>, <span class="number">74</span>, <span class="number">3</span>, <span class="number">124</span>, <span class="number">238</span>],</span><br><span class="line">                   [<span class="number">252</span>, <span class="number">184</span>, <span class="number">146</span>, <span class="number">93</span>, <span class="number">95</span>, <span class="number">194</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">117</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">116</span>, <span class="number">182</span>, <span class="number">254</span>, <span class="number">106</span>, <span class="number">197</span>],</span><br><span class="line">                   [<span class="number">43</span>, <span class="number">6</span>, <span class="number">123</span>, <span class="number">73</span>, <span class="number">68</span>, <span class="number">39</span>, <span class="number">57</span>, <span class="number">189</span>, <span class="number">222</span>, <span class="number">122</span>, <span class="number">210</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">60</span>, <span class="number">77</span>, <span class="number">118</span>],</span><br><span class="line">                   [<span class="number">67</span>, <span class="number">68</span>, <span class="number">27</span>, <span class="number">216</span>, <span class="number">175</span>, <span class="number">122</span>, <span class="number">34</span>, <span class="number">122</span>, <span class="number">115</span>, <span class="number">131</span>, <span class="number">72</span>, <span class="number">121</span>, <span class="number">134</span>, <span class="number">252</span>, <span class="number">55</span>, <span class="number">115</span>],</span><br><span class="line">                   [<span class="number">55</span>, <span class="number">182</span>, <span class="number">125</span>, <span class="number">188</span>, <span class="number">157</span>, <span class="number">42</span>, <span class="number">194</span>, <span class="number">218</span>, <span class="number">82</span>, <span class="number">35</span>, <span class="number">129</span>, <span class="number">69</span>, <span class="number">186</span>, <span class="number">168</span>, <span class="number">217</span>, <span class="number">164</span>],</span><br><span class="line">                   [<span class="number">193</span>, <span class="number">76</span>, <span class="number">12</span>, <span class="number">201</span>, <span class="number">78</span>, <span class="number">106</span>, <span class="number">68</span>, <span class="number">36</span>, <span class="number">159</span>, <span class="number">246</span>, <span class="number">228</span>, <span class="number">24</span>, <span class="number">103</span>, <span class="number">141</span>, <span class="number">18</span>, <span class="number">137</span>],</span><br><span class="line">                   [<span class="number">191</span>, <span class="number">66</span>, <span class="number">94</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">149</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">115</span>, <span class="number">182</span>, <span class="number">87</span>, <span class="number">14</span>, <span class="number">223</span>, <span class="number">236</span>, <span class="number">122</span>, <span class="number">168</span>],</span><br><span class="line">                   [<span class="number">216</span>, <span class="number">49</span>, <span class="number">214</span>, <span class="number">157</span>, <span class="number">208</span>, <span class="number">117</span>, <span class="number">68</span>, <span class="number">38</span>, <span class="number">70</span>, <span class="number">12</span>, <span class="number">145</span>, <span class="number">80</span>, <span class="number">215</span>, <span class="number">70</span>, <span class="number">36</span>, <span class="number">130</span>],</span><br><span class="line">                   [<span class="number">201</span>, <span class="number">148</span>, <span class="number">125</span>, <span class="number">191</span>, <span class="number">41</span>, <span class="number">107</span>, <span class="number">29</span>, <span class="number">247</span>, <span class="number">211</span>, <span class="number">140</span>, <span class="number">56</span>, <span class="number">28</span>, <span class="number">203</span>, <span class="number">250</span>, <span class="number">48</span>, <span class="number">60</span>],</span><br><span class="line">                   [<span class="number">3</span>, <span class="number">184</span>, <span class="number">98</span>, <span class="number">221</span>, <span class="number">24</span>, <span class="number">56</span>, <span class="number">237</span>, <span class="number">79</span>, <span class="number">23</span>, <span class="number">225</span>, <span class="number">120</span>, <span class="number">137</span>, <span class="number">215</span>, <span class="number">190</span>, <span class="number">46</span>, <span class="number">226</span>]])</span><br><span class="line"></span><br><span class="line">    out_shape = (<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    roi = RoiAlign((<span class="number">5.26</span>, <span class="number">9.33</span>),  <span class="comment"># left top point</span></span><br><span class="line">                   (<span class="number">200</span> / <span class="number">32</span>, <span class="number">185</span> / <span class="number">32</span>),  <span class="comment"># width and height</span></span><br><span class="line">                   fm, <span class="number">2</span>, out_shape)</span><br><span class="line"></span><br><span class="line">    bin_idx = <span class="number">6</span></span><br><span class="line">    sample_idx = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    roi.print_matrix()</span><br><span class="line">    roi.print_roi()</span><br><span class="line">    roi.find_all_nearest_points()</span><br><span class="line">    roi.print_bins(i=bin_idx, j=sample_idx, is_print_all=<span class="literal">True</span>, is_print_position=<span class="literal">True</span>, is_difference_marker=<span class="literal">True</span>)</span><br><span class="line">    roi.print_single_bin_sample(<span class="literal">True</span>, bin_idx, sample_idx)</span><br><span class="line">    roi.print_all_bins_nearest_four(is_print_4sample=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    roi.do_pooling(<span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></li></ul><h3 id="网络结构及目标函数">8.9.4 网络结构及目标函数</h3><ul><li><p>网络结构</p>下图左右两图分别为：ResNet骨干网络+Head和FPN骨干网络+Head：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/maskrcnn_head.png" width="800"></center></li><li><p>目标函数</p><p>对Faster R-CNN做了些许扩展： <span class="math display">\[ L=\underbrace{L_{cls}+L_{box}}_{Faster R-CNN}+\underbrace{L_{mask}}_{MaskR-CNN} \]</span></p><p>Faster R-CNN部分：</p><p><span class="math display">\[ \underbrace{L(p,u,t^u,v)}_{\begin {align} p&amp;:预测分类\\u&amp;:分类标注\\t^u&amp;:分类u的预测bbox\\v&amp;:bbox标注 \end{align}}=\underbrace{L_{cls}(p,u)}_{log\text{ }loss}+\underbrace{\lambda[u\geq 1]}_{[u\geq 1]=\left\{\begin{matrix}1 &amp;若 u \geq 1\\0&amp;其他\end{matrix}\right.} \cdot \underbrace{L_{box}(t^u,v)}_{smooth\text{ }L1\text{ }loss} \]</span> 其中： <span class="math display">\[ \begin {align} log\text{ }loss&amp;:-logp_u=-ulog (p)-(1-u)log(1-p)\\ smooth\text{ }L1\text{ }loss&amp;:\sum_{i \in \{x,y,w,h\}}smooth_{L_i}(t_i^u-v_i)\\ smooth_{L_i}(x)&amp;=\left\{\begin{matrix}0.5x^2 \quad &amp;若 |x|&lt;1\\|x|-0.5&amp;其他\end{matrix}\right.\end{align} \]</span></p>Mask部分: <span class="math display">\[ \begin {align} L_{mask}&amp;= - \frac{1}{m×m} \sum_{i=1}^m \sum_{j=1}^m \big[ u_{ij} \log y^k_{ij} + (1-u_{ij}) \log (1- y^k_{ij}) \big]\\ y_{ij}&amp;:位置(i,j)处像素针对分类k的预测mask值\\ u_{ij}&amp;:位置(i,j)处像素的标注mask值\\ m&amp;:mask \text{ } feature \text{ } map矩阵维度(m×m)\\ \end{align} \]</span> 注意，对每个像素都会有一个二分类结果，以及每个类都会有一个mask矩阵(m×m)输出，所以总共会有<span class="math inline">\(K\cdot(m×m)\)</span>个sigmoid输出，而如果RoI判定为第<span class="math inline">\(k\)</span>个分类，则损失函数<span class="math inline">\(L_{mask}\)</span>为第<span class="math inline">\(k\)</span>个分类下的平均二分类交叉熵损失（average binary cross-entropy loss），也就是说所有分类之间不会产生竞争，文中这部分效果如下：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/bce.png" width="390"></center>分割效果：<center><img src="https://vivounicorn.github.io/images/ai_chapter_8/cm.jpg" width="390"> <img src="https://vivounicorn.github.io/images/ai_chapter_8/cm_mask.jpg" width="390"></center><center><img src="https://vivounicorn.github.io/images/ai_chapter_8/street1.png" width="390"> <img src="https://vivounicorn.github.io/images/ai_chapter_8/street1_mask.jpg" width="390"></center><center><img src="https://vivounicorn.github.io/images/ai_chapter_8/street2.png" width="390"> <img src="https://vivounicorn.github.io/images/ai_chapter_8/street2_mask.jpg" width="390"></center></li></ul><h1 id="references">References</h1><p>如有遗漏请提醒我补充：</p><p align="left">1、《Understanding the Bias-Variance Tradeoff》http://scott.fortmann-roe.com/docs/BiasVariance.html</p><p align="left">2、《Boosting Algorithms as Gradient Descent in Function Space》http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.51.6893&amp;rep=rep1&amp;type=pdf</p><p align="left">3、《Optimal Action Extraction for Random Forests and Boosted Trees》http://www.cse.wustl.edu/~ychen/public/OAE.pdf</p><p align="left">4、《Applying Neural Network Ensemble Concepts for Modelling Project Success》http://www.iaarc.org/publications/fulltext/Applying_Neural_Network_Ensemble_Concepts_for_Modelling_Project_Success.pdf</p><p align="left">5、《Introduction to Boosted Trees》https://homes.cs.washington.edu/~tqchen/data/pdf/BoostedTree.pdf</p><p align="left">6、《Machine Learning:Perceptrons》http://ml.informatik.uni-freiburg.de/_media/documents/teaching/ss09/ml/perceptrons.pdf</p><p align="left">7、《An overview of gradient descent optimization algorithms》http://sebastianruder.com/optimizing-gradient-descent/</p><p align="left">8、《Ad Click Prediction: a View from the Trenches》https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf</p><p align="left">9、《ADADELTA: AN ADAPTIVE LEARNING RATE METHOD》http://www.matthewzeiler.com/pubs/googleTR2012/googleTR2012.pdf</p><p align="left">9、《Improving the Convergence of Back-Propagation Learning with Second Order Methods》http://yann.lecun.com/exdb/publis/pdf/becker-lecun-89.pdf</p><p align="left">10、《ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION》https://arxiv.org/pdf/1412.6980v8.pdf</p><p align="left">11、《Adaptive Subgradient Methods for Online Learning and Stochastic Optimization》http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf</p><p align="left">11、《Sparse Allreduce: Efficient Scalable Communication for Power-Law Data》https://arxiv.org/pdf/1312.3020.pdf</p><p align="left">12、《Asynchronous Parallel Stochastic Gradient Descent》https://arxiv.org/pdf/1505.04956v5.pdf</p><p align="left">13、《Large Scale Distributed Deep Networks》https://papers.nips.cc/paper/4687-large-scale-distributed-deep-networks.pdf</p><p align="left">14、《Introduction to Optimization —— Second Order Optimization Methods》https://ipvs.informatik.uni-stuttgart.de/mlr/marc/teaching/13-Optimization/04-secondOrderOpt.pdf</p><p align="left">15、《On the complexity of steepest descent, Newton’s and regularized Newton’s methods for nonconvex unconstrained optimization》http://www.maths.ed.ac.uk/ERGO/pubs/ERGO-09-013.pdf</p><p align="left">16、《On Discriminative vs. Generative classifiers: A comparison of logistic regression and naive Bayes 》http://papers.nips.cc/paper/2020-on-discriminative-vs-generative-classifiers-a-comparison-of-logistic-regression-and-naive-bayes.pdf</p><p align="left">17、《Parametric vs Nonparametric Models》http://mlss.tuebingen.mpg.de/2015/slides/ghahramani/gp-neural-nets15.pdf</p><p align="left">18、《XGBoost: A Scalable Tree Boosting System》https://arxiv.org/abs/1603.02754</p><p align="left">19、一个可视化CNN的网站 http://shixialiu.com/publications/cnnvis/demo/</p><p align="left">20、《Computer vision: LeNet-5, AlexNet, VGG-19, GoogLeNet》http://euler.stat.yale.edu/~tba3/stat665/lectures/lec18/notebook18.html</p><p align="left">21、François Chollet在Quora上的专题问答：https://www.quora.com/session/Fran%C3%A7ois-Chollet/1</p><p align="left">22、《将Keras作为tensorflow的精简接口》https://keras-cn.readthedocs.io/en/latest/blog/keras_and_tensorflow/</p><p align="left">23、《Upsampling and Image Segmentation with Tensorflow and TF-Slim》https://warmspringwinds.github.io/tensorflow/tf-slim/2016/11/22/upsampling-and-image-segmentation-with-tensorflow-and-tf-slim/</p><p align="left">24、《DENSELY CONNECTED CONVOLUTIONAL NETWORKS》http://www.cs.cornell.edu/~gaohuang/papers/DenseNet-CVPR-Slides.pdf</p><p align="left">25、https://github.com/vivounicorn/convnet-study</p></div><div class="popular-posts-header">相关文章推荐</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/d677b2e0.html" rel="bookmark">机器学习与人工智能技术分享-第三章 机器学习中的统一框架</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/ad2261a2.html" rel="bookmark">机器学习与人工智能技术分享-第四章 最优化原理</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/b12a240.html" rel="bookmark">机器学习与人工智能技术分享-第九章 语义分割</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/fb9cd06d.html" rel="bookmark">机器学习与人工智能技术分享-第七章 金融风控</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/307f39c.html" rel="bookmark">机器学习与人工智能技术分享-第二章 建模方法回顾</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"># 机器学习</a> <a href="/tags/%E7%AC%AC%E5%85%AB%E7%AB%A0/" rel="tag"># 第八章</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" rel="tag"># 目标检测</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB/" rel="tag"># 目标识别</a></div><div class="post-nav"><div class="post-nav-item"><a href="/article/fb9cd06d.html" rel="prev" title="机器学习与人工智能技术分享-第七章 金融风控"><i class="fa fa-chevron-left"></i> 机器学习与人工智能技术分享-第七章 金融风控</a></div><div class="post-nav-item"><a href="/article/b12a240.html" rel="next" title="机器学习与人工智能技术分享-第九章 语义分割">机器学习与人工智能技术分享-第九章 语义分割 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB"><span class="nav-text">8. 目标检测与识别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#selective-search"><span class="nav-text">8.1 Selective Search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99"><span class="nav-text">8.1.1 启发式生成设计准则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selective-search-1"><span class="nav-text">8.1.2 Selective Search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8selective-search%E5%81%9A%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB"><span class="nav-text">8.1.3 使用Selective Search做目标识别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5"><span class="nav-text">8.1.4 代码实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overfeat"><span class="nav-text">8.2 OverFeat</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#overfeat%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1"><span class="nav-text">8.2.1 OverFeat分类任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overfeat%E5%AE%9A%E4%BD%8D%E4%BB%BB%E5%8A%A1"><span class="nav-text">8.2.2 OverFeat定位任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overfeat%E6%A3%80%E6%B5%8B%E4%BB%BB%E5%8A%A1"><span class="nav-text">8.2.3 OverFeat检测任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-1"><span class="nav-text">8.2.4 代码实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r-cnn"><span class="nav-text">8.3 R-CNN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#iou"><span class="nav-text">8.3.1 IoU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nms"><span class="nav-text">8.3.2 NMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-text">8.3.3 mAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#r-cnn%E5%8E%9F%E7%90%86"><span class="nav-text">8.3.4 R-CNN原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-2"><span class="nav-text">8.3.5 代码实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spp-net"><span class="nav-text">8.4 SPP-Net</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9E%E9%A1%BE"><span class="nav-text">8.4.1 问题回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spp%E8%AF%A6%E8%A7%A3"><span class="nav-text">8.4.2 SPP详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E5%8F%97%E9%87%8Ereceptive-field"><span class="nav-text">8.4.3 感受野(Receptive Field)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#feature-map%E4%B8%8E%E5%8E%9F%E5%9B%BE%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E8%BD%AC%E6%8D%A2"><span class="nav-text">8.4.4 feature map与原图对应关系转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-3"><span class="nav-text">8.4.5 代码实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fast-r-cnn"><span class="nav-text">8.5 Fast R-CNN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-text">8.5.1 算法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E9%98%B6%E6%AE%B5"><span class="nav-text">8.5.2 训练阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-4"><span class="nav-text">8.5.3 代码实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#faster-r-cnn"><span class="nav-text">8.6 Faster R-CNN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0-1"><span class="nav-text">8.6.1 算法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rpn"><span class="nav-text">8.6.2 RPN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anchor"><span class="nav-text">8.6.3 Anchor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-5"><span class="nav-text">8.6.4 代码实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#faster-r-cnn%E8%AE%AD%E7%BB%83%E6%B5%81%E7%A8%8B"><span class="nav-text">8.6.5 Faster R-CNN训练流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#faster-r-cnn-with-caffe"><span class="nav-text">8.6.6 Faster R-CNN with Caffe</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r-fcn"><span class="nav-text">8.7 R-FCN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0-2"><span class="nav-text">8.7.1 算法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#position-sentitive-roi-pooling"><span class="nav-text">8.7.2 position-sentitive RoI pooling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83"><span class="nav-text">8.7.3 模型训练</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-6"><span class="nav-text">8.7.4 代码实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#densenet"><span class="nav-text">8.8 DenseNet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-text">8.8.1 关于神经网络的深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#densenet%E6%80%9D%E8%B7%AF"><span class="nav-text">8.8.2 DenseNet思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-7"><span class="nav-text">8.8.3 代码实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mask-r-cnn"><span class="nav-text">8.9 Mask R-CNN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0-3"><span class="nav-text">8.9.1 算法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mask"><span class="nav-text">8.9.2 Mask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#roialign"><span class="nav-text">8.9.3 RoIAlign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%8A%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0"><span class="nav-text">8.9.4 网络结构及目标函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#references"><span class="nav-text">References</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="张磊" src="https://vivounicorn.github.io/images/wali.png"><p class="site-author-name" itemprop="name">张磊</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张磊</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">477k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">7:13</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="//cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{load:["[tex]/mhchem"],source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},packages:{"[+]":["mhchem"]},tags:"ams"},options:{renderActions:{findScript:[10,d=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new d.options.MathItem(e.textContent,d.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},d.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.5/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!0,appId:"m8FPP0CqMpxyTuUvaVOX9qVV-gzGzoHsz",appKey:"Ori6X9PXqQyURvwgl7HT5TJj",placeholder:"赠人玫瑰，手有余香",avatar:"mm",meta:e,pageSize:"10",visitor:!0,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script></body></html>